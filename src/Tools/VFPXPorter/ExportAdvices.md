
### Moving your VFP App to XSharp

After conversion, the newly created Visual Studio Project contains the definition of **VFP2XS** symbol.  
This means that you can already prepare your VFP code to XSharp using code construction like :  
~~~
    #ifndef VFP2XS
    * This is the original VFP code
    this.Label1.ForeColor = RGB(255,0,0)
    #else
    * This is the code that WinForms will need when compiled with XSharp
    this.Label1.ForeColor = System.Drawing.Color.FromARGB(255,0,0) 
    #endif
~~~ 



### Converting from VFP
#### Common troubles
Please find here a list of the common troubles we will face when converting your VFP GUI code to X# and WinForms.

### Events & Methods naming

When converting your Application from VFP to X# & WinForms, you have to keep in mind that these two "worlds" are using a different point-of view to your Form.  

In *VFP*, **events** are routed to the **Controls**.  
So we could consider that, for eg, each button on the Form has it's own class that INHERIT from the base-class CommandButton, and is an instance of that particular class: So you can override Events and Methods that that level, and it gives you a lot of control on what's happening there.  
In *WinForms*, **events** are routed to the Owner of the Controls: The **Form**  
So, the usage is to prefix the EventHandlers and Methods with the name of the Control.  
If  *button1* is raising a *click* event, the name of the handler is *button1_click*.  

If a *Form* is raising a event, as the *Form* is the class, the name will be *nameOfTheForm_Event*.  
You can change that via an exporter setting:
- Prefix Event methods with FORM name

#### Start() Function
The generated code contains a Start() Function, which is the Startup Object of the generated application.
If you are also using a Start() Function in your VFP Code, you will have to rename it after export.  

#### Init() Method
With VFP, the Init() method is called when an object is created.  
With X#, calling the Constructor() of a class (with the MyClass\{} syntax), won't automatically called the Init() Method.  
This process is emulated by the InitType.prg template that is used during export.  
With Controls, the Init() Method is called when the Handle is created. This code is generated by the InitType.prg template used during export.

#### Colors
*Unfortunately, these cannot be handled automatically as 
it would break the Windows Forms designer in Visual Studio.*

Setting a BackColor or ForeColor with an RGB, like :
~~~
    this.Label1.ForeColor = RGB(255,0,0)
~~~  
Should be converted to :
~~~
    this.Label1.ForeColor = System.Drawing.Color.FromARGB( 255,0,0) )
~~~  

BUT.... If you had a function called RGB() that returns a System.Drawing.Color in a PRG file, in the Tools folder of the Exporter, it will be part of your Exported Solution, and it will supersede the XSharp Runtime definition, and that will do the trick !!
   
#### Method Call without parenthesis
In X#, a Property holds a Value that is set/get with the equal sign, while a Method contains code that is executed when called : And you can make the difference because Method call ends with parenthesis.  

While this is allowed in VFP, you will have to correct that in X#
~~~~
    this.Refresh
~~~~
Should be corrected as
~~~~
    this.Refresh()
~~~~
These can be corrected at export time, if you check the "Convert Statement to Call" in settings.  
The handled statements are in the *Statements.json* file

#### Form Properties casing
In order to modify a Form with the **Windows Form Designer** in Visual Studio, the Properties must respect the WinForm casing.
So, you may have to add some properties to the PropRules.json in order to automatically convert them.  
That's why *ShowInTaskBar* appears in the rules as *ShowInTaskbar*. (Note the lowercased b)

> The following points have been addressed with the VFP2WinForms.json Rules
>#### Access to Parent
>The Parent Property is already defined in Windows Forms, and is strongly typed to a System.Windows.Forms.Control object.
>To avoid troubles, and ease the port of applications, the support library contains a property called _Parent that access the Control's parent, but as an weakly typed Object.  
>This will forced X# to a late-bound call, and could help in resolving access to ported code.  
>The call to _Parent is automatically generated by the XPorter.  
>
>#### Calling an Object Event in Your Code
>A with Parent, you may sometimes call directly Event handlers in your VFP code.  
>This might be problematic, and for eg a direct call to the **Click** event of a button will fail.  
>~~~~
>This.Parent.cmd_prec.Click
>~~~~
>During export, the **This** will be turned to **ThisObject**, the parent 
>

#### Array access
In X#, array elements are accessed using brackets [].  
In VFP, it is possible to use parenthesis ().  
But this can be a problem when accessing a .Net typed-array.   
So, in order to ease the port of VFP appls, some array access have been turned to method call in the XSharp.VFP.UI, the Control layer that ease access to .NET Controls with VFP syntax.  
~~~~
x = __screen.FormCount
__screen.Forms(x-1).Release() // Here, Forms array will be replaced by Forms Method call.
~~~~

#### Access Fields in the current Area/Cursor
In VFP, it is possible to reference the current WorkArea/Cursor using its name, and to point to specific fields by specifying their name after a Dot selector, like with :
~~~~
? movie.title
~~~~
Unfortunately, in X# the Dot selector is used for Objects, so you will have to use an arrow as selector, like with :
~~~~
? movie->title
~~~~

#### Undeclared Vars
You can use a undeclared var anywhere in your code.
This is something that X# will recognize and support.  
In such case, X# will create a MemVar: a local, untyped, var.

But, there are some cases, where this will not work. For eg:
~~~~
IF SQLExec(nHandle,"SELECT *  FROM employees ORDER BY id ASC  LIMIT 1","CurResult") <=0 THEN &&& validate error first. 
   Aerror(laErr)
   Messagebox("Check the following error: " + Chr(13) + laErr[2],'Alert',3000)
   RETURN .F.
ENDIF 
~~~~
In the previous code, the var **laErr** has never been declared at this level, but it is used as a **REF** var by the AError() function.   
This type of construction is **not** supported by X#.


#### Unsupported Functions
When building your VFP App, you may call some functions that are not supported by X#.  
The compiler will express a warning (**XS0618**), but will generate an Exe, that will certainly crash at Runtime.   

To avoid that, indicate these warnings as Errors.  
To do so, with MS Visual Studio, follow these indications :  
- Open the Properties of the Project
- Go To Build
- In section _Treat Warning as Errors_, enter the Specific Warning : XS0618  






