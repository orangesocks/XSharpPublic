//
// Copyright (c) XSharp B.V.  All Rights Reserved.  
// Licensed under the Apache License, Version 2.0.  
// See License.txt in the project root for license information.
//

using System
using System.Collections
using System.Collections.Generic
using System.Diagnostics
using System.Runtime.CompilerServices

begin namespace XSharp
	/// <summary>Internal type that implements the VO Compatible SYMBOL type.<br/>
	/// This type has many operators and implicit converters that normally are never directly called from user code.<br/>
	/// There are also some operators that handle implicit conversions between Symbols and Strings in your code.
	/// </summary>
	[DebuggerDisplay("{_value,nq}",Type := "SYMBOL")];
    [DebuggerTypeProxy(typeof(SymbolDebugView))];
	public structure __Symbol ;
		implements IEqualityComparer<__Symbol>, ;
		IEquatable<__Symbol>,;
		IComparable<__Symbol>, ;
		IComparable, ;
		ICloneable , ;
		IConvertible
		
		#region fields
			private initonly _index		as dword
			private static _PszDict			as Dictionary<DWORD, PSZ>
		#endregion
		
		#region constrúctors
			/// <summary>Construct the type and create the SymbolTable.</summary>
			static constructor
				SymbolTable.Initialize()

			/// <summary>This constructor is used in code generated by the compiler when needed.</summary>
			[MethodImpl(MethodImplOptions.AggressiveInlining)];        			
			constructor(value as string)
				self(value, true)
			
			/// <summary>This constructor is used in code generated by the compiler when needed.</summary>
			[MethodImpl(MethodImplOptions.AggressiveInlining)];        			
			constructor(value as string,  upperCase as logic)
				if (upperCase)
					value := value:ToUpperInvariant()
				endif
				_index := SymbolTable.Add(value)
				return
			
			[MethodImpl(MethodImplOptions.AggressiveInlining)];        			
			private constructor (value as dword)
				self:_index := value
			
		#endregion
		internal static method Find(sValue as string ) as __symbol
			if SymbolTable:LookupTable:ContainsKey(sValue)
				var index := __Symbol.SymbolTable:LookupTable[sValue]
				return __Symbol{index}
			endif
			return __Symbol{0}


		internal property _value as STRING
		get
			return SymbolTable.GetString(self:_index)
		end get
		end property
		internal static property PszDict as Dictionary<dword, Psz>
		get
			if _pszDict == null
				_pszDict := Dictionary<dword, Psz>{}
			endif
			return _PszDict
		end get
		end property
		
		#region methods
			/// <inheritdoc />	
			virtual method Equals(obj as object) as logic 
				local rhs as symbol
				if (obj == null)
					return false
				ENDIF
				rhs := (symbol) obj
				RETURN SELF:Equals(rhs)

			/// <inheritdoc />	
			virtual method GetHashCode() as long
				RETURN (INT) SELF:_index

			/// <inheritdoc />	
			method GetHashCode(s as __Symbol) as long
				RETURN (INT) s:_index

			/// <inheritdoc />	
			virtual method ToString() as string
				return _value

			/// <exclude />	
			method SysGetAtomName() as Psz
				if PszDict:ContainsKey(_index)
					return PszDict[_index]
				endif
				local pszAtom as PSZ
				pszAtom := __Psz.CreatePsz(_value)
				PszDict:add(_index, pszAtom)
				return pszAtom

		#endregion
		
		#region Equality
			/// <inheritdoc />		
			method Equals(symOther as symbol) as logic
				return self:_index == symOther:_index
			
			/// <inheritdoc />	
			method Equals(x as symbol, y as symbol) as logic
				return x:_index == y:_index
			
			/// <exclude />	
			method Equals(s as string) as logic
				return self:_value == s
			
		#endregion
		#region Operators
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator ==(lhs as symbol, rhs as symbol) as logic
				return lhs:_index == rhs:_index
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator !=(a as symbol, b as symbol) as logic
				return a:_index != b:_index
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator ==(lhs as symbol, rhs as string) as logic
				return lhs:_value == rhs
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator !=(lhs as Symbol, rhs as string) as logic
				return lhs:_value != rhs
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator ==(lhs as string, rhs as Symbol) as logic
				return lhs == rhs:_value
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator !=(lhs as string, rhs as Symbol) as logic
				return lhs != rhs:_value
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator ==(lhs as Symbol, rhs as dword) as logic
				return lhs:_index == rhs
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator !=(lhs as Symbol, rhs as dword) as logic
				return lhs:_index != rhs
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator ==(lhs as dword, rhs as Symbol) as logic
				return lhs == rhs:_index
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator !=(lhs as dword, rhs as Symbol) as logic
				return lhs != rhs:_index
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator explicit(value as dword) as Symbol
				if value <= SymbolTable.Count
					return Symbol{value}
				endif
				return Symbol{0}
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator explicit(value as Symbol) as dword
				return value:_index
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator implicit(value as string) as Symbol
				return Symbol{value, true}
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator implicit(value as Symbol) as string
				return value:_value
			
			// relative comparisons
			// compare symbols or symbols and strings
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator >(lhs as Symbol, rhs as Symbol) as logic
				return __StringCompare(lhs:_value, rhs:_value) > 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator >(lhs as Symbol, rhs as string) as logic
				return __StringCompare(lhs:_value, rhs) > 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator >(lhs as string, rhs as Symbol) as logic
				return __StringCompare(lhs, rhs:_value) > 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator <(lhs as Symbol, rhs as Symbol) as logic
				return __StringCompare(lhs:_value, rhs:_value) < 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator <(lhs as Symbol, rhs as string) as logic
				return __StringCompare(lhs:_value, rhs) < 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator <(lhs as string, rhs as Symbol) as logic
				return __StringCompare(lhs, rhs:_value) < 0
			
			// or Equals
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator >=(lhs as Symbol, rhs as Symbol) as logic
				return __StringCompare(lhs:_value, rhs:_value) >= 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator >=(lhs as Symbol, rhs as string) as logic
				return __StringCompare(lhs:_value, rhs) >= 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator >=(lhs as string, rhs as Symbol) as logic
				return __StringCompare(lhs, rhs:_value) >= 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator <=(lhs as Symbol, rhs as Symbol) as logic
				return __StringCompare(lhs:_value, rhs:_value) <= 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator <=(lhs as Symbol, rhs as string) as logic
				return __StringCompare(lhs:_value, rhs) <= 0
			
			/// <summary>This operator is used in code generated by the compiler when needed.</summary>
			static operator <=(lhs as string, rhs as Symbol) as logic
				return __StringCompare(lhs, rhs:_value) <= 0
			
		#endregion
		
		
		#region internal types
			internal static  class SymbolTable
				#region fields
					// Note that we are not using a ConcurrentDictionary since we want to keep the LookupTable and List
					// in sync. Therefore we handle our own locking in this class
					static internal LookupTable as Dictionary<string,dword>
					static internal Strings		as List<string>
					static private sync as object
				#endregion
				
				#region constructors
					static method Initialize() as void
						sync		:= object{}
						LookupTable := Dictionary<string,dword>{}
						Strings := List<string>{}
						LookupTable:Add("", 0)
						Strings:Add("")
				#endregion
				
				#region methods
					internal static method Add(strValue as string) as dword
						local index := 0 as dword
						begin lock sync
							if (LookupTable:ContainsKey(strValue))
								index := LookupTable[strValue]
							else
								index := (dword) LookupTable:Count
								LookupTable:Add(strValue, index)
								Strings:Add(strValue)
							endif
						end lock
						return index
					
					internal static method GetString(index as dword) as string
						if (int) index < Strings:Count
							return Strings[(int) index]
						endif
						return ""
					
					internal static property Count as long
						get
							return LookupTable:Count
						end get
					end property
					
				#endregion
				
			end class
		#endregion
		

		METHOD CompareTo(o AS OBJECT) AS LONG
			RETURN CompareTo((SYMBOL)o)
			

		METHOD CompareTo(rhs AS SYMBOL) AS LONG
			return __StringCompare(SELF:_value, rhs:_value) 
		
  #region IConvertible Methods
   
	/// <inheritdoc />
    METHOD IConvertible.GetTypeCode() AS TypeCode
      RETURN TypeCode.Object
      
	/// <inheritdoc />
    METHOD IConvertible.ToBoolean( provider AS IFormatProvider ) AS LOGIC
      RETURN ((IConvertible)_value):ToBoolean( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToByte( provider AS IFormatProvider ) AS BYTE
      RETURN ((IConvertible)_value):ToByte( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToChar( provider AS IFormatProvider ) AS Char
      RETURN ((IConvertible)_value):ToChar( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToDateTime( provider AS IFormatProvider ) AS DateTime
      RETURN ((IConvertible)_value):ToDateTime( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToDecimal( provider AS IFormatProvider ) AS Decimal
      RETURN ((IConvertible)_value):ToDecimal( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToDouble( provider AS IFormatProvider ) AS Double
      RETURN ((IConvertible)_value):ToDouble( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToInt16( provider AS IFormatProvider ) AS Int16
      RETURN ((IConvertible)_value):ToInt16( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToInt32( provider AS IFormatProvider ) AS Int32
      RETURN ((IConvertible)_value):ToInt32( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToInt64( provider AS IFormatProvider ) AS INT64
      RETURN ((IConvertible)_value):ToInt64( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToSByte( provider AS IFormatProvider ) AS SByte
      RETURN ((IConvertible)_value):ToSByte( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToSingle( provider AS IFormatProvider ) AS Single
      RETURN ((IConvertible)_value):ToSingle( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToString( provider AS IFormatProvider ) AS STRING
      RETURN ((IConvertible)_value):ToString( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToType( conversionType AS Type, provider AS IFormatProvider ) AS OBJECT
      RETURN ((IConvertible)_value):ToType( conversionType, provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToUInt16( provider AS IFormatProvider ) AS UInt16
      RETURN ((IConvertible)_value):ToUInt16( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToUInt32( provider AS IFormatProvider ) AS UInt32
      RETURN ((IConvertible)_value):ToUInt32( provider )
   
	/// <inheritdoc />
    METHOD IConvertible.ToUInt64( provider AS IFormatProvider ) AS UInt64
      RETURN ((IConvertible)_value):ToUInt64( provider )
   
   #endregion
		#region IClonable
			/// <exclude />	
			method Clone() as object
				return Symbol{self:_index}
		#endregion
		
		#region IEnumerable
			// Vulcan.Symbol
			//METHOD GetEnumerator() as IEnumerator
			//return SymbolTable.strings.GetEnumerator()
			
		#endregion
	end structure
    internal class SymbolDebugView
        private _svalue as Symbol
		constructor( s as Symbol)
        _svalue := s
            
        [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] ;
        public property Value as object get _svalue:_VALUE
            
    end class

end namespace