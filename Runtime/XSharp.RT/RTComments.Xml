<?xml version="1.0" encoding="utf-8" ?>
<Comments>
  <StaticMemory>
    <remarks>
      <note type="tip">
        The Static Memory Functions (MemAlloc, MemSet etc) are included for compatibility only.
        In most cases the static memory blocks can (and should) be replaced with arrays of bytes.<br/>
        Many of the functions in the runtime that take memory blocks as parameter, such as the low level IO functions, now have overloads that take arrays of bytes as parameter.<br/>
        We recommend that you use these overloads, because their performance is somewhat better.
      </note>
    </remarks>
  </StaticMemory>
  <PSZ>
    <remarks>
      <note type="tip">
        The PSZ type is included in the X# language and runtime for compatibility only.
        In most cases the type can and should be replaced with normal strings. <br/>
        If you need to interface with Win32 API functions that expect an ansi string, there is often also
        an alternative with a unicode string. We recommend to use that alternative when possible.
      </note>
    </remarks>
  </PSZ>
  <Symbol>
    <remarks>
      <note type="tip">
        The SYMBOL type is included in the X# language and runtime for compatibility only.
        In most cases the type can and should be replaced with normal strings.
      </note>
    </remarks>
  </Symbol>
  <Memvar>
    <remarks>
      <note type="tip">
        Dynamic memory variables (PUBLIC, PRIVATE, PARAMETERS) are supported in the X# language and runtime for compatibility only.<br/>
        In most cases the type can and should be replaced with lexically scoped variables, such as LOCALs and GLOBALs.
      </note>
    </remarks>
  </Memvar>
  <Operator>
    <summary>This operator is used in code generated by the compiler when needed.</summary>
  </Operator>
  <UsualCompare>
      <remarks>When comparing 2 usuals from different types, then the type of the Left Hand Side is taken as 'leading'.
      For example when comparing a usual of a LHS of type DATE with a RHS of type DateTime
      then the DateTime from the RHS is converted to a DATE first (the time is stripped off) becore comparing.
    </remarks>

  </UsualCompare>
  <Converter>
    <summary>This converter is used in code generated by the compiler when needed.</summary>
  </Converter>
  <Constructor>
    <summary>This constructor is used in code generated by the compiler when needed.</summary>
  </Constructor>
  <FileCompat>
    <remarks>
      <note type="tip">
        This function is included for compatibility. We do not recomment using static memory for file i/o operations.
        We recommend that you use the function overload that takes a byte array parameter in stead.
      </note>
    </remarks>
  </FileCompat>
  <ZeroBasedIndex>
    <remarks>
      The indexer in this type is <em>ZERO</em> based, however in your PRG code you can use <em>ONE</em> based array indices.
      When the compiler detects an index operation to a class that implements this interface then the compiler will automatically
      adjust the indices (by subtracting one) unless the /az compiler option is enabled.
    </remarks>
  </ZeroBasedIndex>
  <ZeroBasedIndexParam>
    <span>
      This indexer is <em>ZERO</em> based, however in your PRG code you can use <em>ONE</em> based array indices.
      The compiler will recognize that this property is part of a type that implements a special interface
      and will subtract one from the indexes, unless the /az compiler option is enabled.
    </span>
  </ZeroBasedIndexParam>
  <NameBasedIndexParam>
    <span>
      Name of the property from the element stored in the location index. If the element implements IIndexedProperties,
      then the indexer with a string parameter on this element will be called. Otherwise the runtime will use reflection to find
      the field or property on the element and return its value
    </span>
  </NameBasedIndexParam>
  <ZeroBasedIndexProperty>
    <summary>
      Get/Set array elements with a <em>ZERO</em> based array index.
    </summary>
    <remarks>
      In your PRG code you can assess the elements with a <em>ONE</em> based index.
      The compiler will recognize that this property is part of a type that implements a special interface
      and will subtract one from the indexes, unless the /az compiler option is enabled.
    </remarks>
  </ZeroBasedIndexProperty>
  <ScopeParams>
    <span>
      <list type="table">
        <listheader>
          <term>DEFINE</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>SCOPE_TOP</term>
          <description>The top scope.</description>
        </item>
        <item>
          <term>SCOPE_BOTTOM</term>
          <description>The bottom scope.</description>
        </item>
        <item>
          <term>SCOPE_BOTH</term>
          <description>The top and also the bottom scope. This is the <em>default</em>.</description>
        </item>
      </list>
    </span>
  </ScopeParams>
  <ScopeReturn>
    <span>
      The return value depends on the parameter that is passed in:<br/>
      <list type="table">
        <listheader>
          <term>Parameter</term>
          <description>Return value</description>
        </listheader>
        <item>
          <term>no parameter</term>
          <description>Returns .T. (true) if a scope is defined, and .F. when no scope is defined.</description>
        </item>
        <item>
          <term>SCOPE_TOP</term>
          <description>Returns the top scope value, or NIL if no top scope is set.</description>
        </item>
        <item>
          <term>SCOPE_BOTTOM</term>
          <description>Returns the bottom scope value, or NIL if no bottom scope is set.</description>
        </item>
        <item>
          <term>SCOPE_BOTH</term>
          <description>Returns an array with 2 elements with the Top scope in element 1 and the Bottom scope in element 2. When a scope is not set then the value NIL is stored in the array</description>
        </item>

      </list>
    </span>
  </ScopeReturn>
</Comments>