<?xml version="1.0" encoding="utf-8" ?>
<Comments>
  <StaticMemory>
    <remarks>
      <note type="tip">
        The Static Memory Functions (MemAlloc, MemSet etc) are included for compatibility only.
        In most cases the static memory blocks can (and should) be replaced with arrays of bytes.<br/>
        Many of the functions in the runtime that take memory blocks as parameter, such as the low level IO functions, now have overloads that take arrays of bytes as parameter.<br/>
        We recommend that you use these overloads, because their performance is somewhat better.
      </note>
    </remarks>
  </StaticMemory>
  <PSZ>
    <remarks>
      <note type="tip">
        The PSZ type is included in the X# language and runtime for compatibility only.
        In most cases the type can and should be replaced with normal strings. <br/>
        If you need to interface with Win32 API functions that expect an ansi string, there is often also
        an alternative with a unicode string. We recommend to use that alternative when possible.
      </note>
    </remarks>
  </PSZ>
  <Symbol>
    <remarks>
      <note type="tip">
        The SYMBOL type is included in the X# language and runtime for compatibility only.
        In most cases the type can and should be replaced with normal strings.
      </note>
    </remarks>
  </Symbol>
  <Memvar>
    <remarks>
      <note type="tip">
        Dynamic memory variables (PUBLIC, PRIVATE, PARAMETERS) are supported in the X# language and runtime for compatibility only.<br/>
        In most cases the type can and should be replaced with lexically scoped variables, such as LOCALs and GLOBALs.
      </note>
    </remarks>
  </Memvar>
  <Operator>
    <summary>This operator is used in code generated by the compiler when needed.</summary>
  </Operator>
  <Converter>
  <summary>This converter is used in code generated by the compiler when needed.</summary>
  </Converter>
  <Constructor>
    <summary>This constructor is used in code generated by the compiler when needed.</summary>  
  </Constructor>
  <FileCompat>
    <remarks>
      <note type="tip">
        This function is included for compatibility. We do not recomment using static memory for file i/o operations.
        We recommend that you use the function overload that takes a byte array parameter in stead.
      </note>
    </remarks>
  </FileCompat>
  <ZeroBasedIndex>
    <remarks>
      The indexer in this type is <em>ZERO</em> based, however in your PRG code you can use <em>ONE</em> based array indices.
      When the compiler detects an index operation to a class that implements this interface then the compiler will automatically
      adjust the indices (by subtracting one) unless the /az compiler option is enabled.
    </remarks>
  </ZeroBasedIndex>
  <ZeroBasedIndexParam>
    <param name="index">
      This indexer is <em>ZERO</em> based, however in your PRG code you can use <em>ONE</em> based array indices.
      The compiler will recognize that this property is part of a type that implements a special interface
      and will subtract one from the indexes, unless the /az compiler option is enabled.
    </param>
  </ZeroBasedIndexParam>
  <NameBasedIndexParam>
    <param name="index">
      Name of the property from the element stored in the location index. If the element implements IIndexedProperties, 
      then the indexer with a string parameter on this element will be called. Otherwise the runtime will use reflection to find
      the field or property on the element and return its value
    </param>
  </NameBasedIndexParam>
  <ZeroBasedIndexProperty>
    <summary>
      Get/Set array elements with a <em>ZERO</em> based array index. 
    </summary>
    <remarks>
      In your PRG code you can assess the elements with a <em>ONE</em> based index. 
      The compiler will recognize that this property is part of a type that implements a special interface 
      and will subtract one from the indexes, unless the /az compiler option is enabled.
    </remarks>
  </ZeroBasedIndexProperty>
</Comments>