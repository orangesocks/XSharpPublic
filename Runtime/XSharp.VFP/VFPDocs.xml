<?xml version="1.0" encoding="utf-8"?>
<Runtimefunctions>
  <aclass>
    <summary>
      Places an object's class name and its ancestor class names into a variable array.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array into which the class names are placed.
    </param>
    <param name="oExpression">
      Specifies an object whose class name and ancestor class names are placed into the array. 
      oExpression can be any object expression, such as an object reference, an object variable, or an object array element.
    </param>
    <returns>Numeric</returns>
    <remarks>
      If you specify the name of an array that doesn't exist, X# automatically creates the array. 
      If you specify the name of an existing array that isn't large enough to hold all the parent names, X# automatically increases the size of the array. 
      If the array is larger than necessary, the array size is truncated. If you specify the name of an existing two-dimensional array, 
      the array is redimensioned to a one-dimensional array. <br/> <br/>
      AClass( ) creates a one-dimensional array containing the class name of the specified object and its ancestor class names. 
      The first array element contains the class name of the object, the second element contains the name of the object's parent class, 
      the third element contains the name of the object's grandparent class, and so on. <br/>
      AClass( ) returns the number of class names in the array. AClass( ) returns 0 if the array cannot be created.<br/>
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        frmMyForm = CreateObject("FormGrandChild")
        FOR nCount = 1 TO AClass(gaNewarray, frmMyForm)    &amp;&amp; Creates an array
        ? gaNewarray(nCount)  &amp;&amp; Displays the names of the classes
        ENDFOR
        RELEASE frmMyForm
        DEFINE CLASS FormChild AS FORM
        ENDDEFINE
        DEFINE CLASS FormGrandChild AS FormChild
        ENDDEFINE
      </code>
    </example>
  </aclass>
  <adatabases>
    <summary>
      Places the names of all open databases and their paths into a variable array.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The names of all open databases are placed into a variable array.<br/> <br/>
      If the array you specify doesn't exist, X# automatically creates the array. 
      If the array exists and isn't large enough to contain all the database information, 
      X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array. 
      If the array exists and ADatabases( ) returns 0 because no databases are open, an existing array remains unchanged. 
      If the array doesn't exist, and ADatabases( ) returns 0, the array is not created.<br/><br/>
      ADatabases( ) creates a two-dimensional array. The first column of the array contains the names of the open databases, 
      and the second column contains the paths to the databases.<br/>
      ADatabases( ) returns the number of database names (rows) in the array. If no databases are open, ADatabases( ) returns 0 and the array isn't created.<br/>
    </remarks>
    <example>
       <code language="X#">
        SET PATH TO (HOME(2) + 'data\')     &amp;&amp; Sets path to database
        OPEN DATABASE testdata &amp;&amp; Opens the database
        CLEAR
        ? ADatabases(gaDatabase)     &amp;&amp; Creates an array of open databases
        DISPLAY MEMORY LIKE gadatabase  &amp;&amp; Displays the contents of the array
        CLOSE DATABASES
      </code>
    </example>
  </adatabases>
  <adbobjects>
    <summary>
      Places the names of named connections, relations, tables, or SQL views in the current database into a variable array.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array in which the names are placed.
    </param>
    <param name="cSetting">
      Specifies the names to place in the variable array. The table in remarks lists the values for cSetting and the corresponding names placed in the array:
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      A database must be open and current when ADBObjects( ) is issued; otherwise X# generates an error message.
      <list type="table">
        <listheader>
          <term>Value</term>
          <description>Name placed in array</description>
        </listheader>
        <item>
          <term>CONNECTION</term>
          <description>Connection names</description>
        </item>
        <item>
          <term>RELATION</term>
          <description>Table relationships</description>
        </item>
        <item>
          <term>TABLE</term>
          <description>Table names</description>
        </item>
        <item>
          <term>VIEW</term>
          <description>View names</description>
        </item>
      </list>
      The Connection, Relation, Table, and View settings cannot be abbreviated. <br/> <br/>
      ArrayName:  If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the names, 
      X# automatically increases the size of the array to accommodate the names. If the array is larger than necessary, X# truncates the array. 
      If the array exists and ADBObjects( ) returns 0 because no names are found, the array remains unchanged. 
      If the array doesn't exist, and ADBObjects( ) returns 0, the array is not created. <br/><br/>
      A one-dimensional array is created when you specify Connection, Table, or View for cSetting. 
      Each row in the one-dimensional array contains the name of a connection, table, or view in the database.<br/>
      A two-dimensional array is created when you specify Relation for cSetting. 
      Each row in the two-dimensional array corresponds to a relationship in the database. 
      The first column in an array row contains the name of the child table and the second column in an array row contains the name of the parent table. 
      The third column contains the name of the index tag for the child table and the fourth column contains the name of the index tag for the parent table.<br/>
      The fifth column in an array row contains referential integrity information. This column is empty if the relation has no referential integrity rules. 
      If the relationship does have referential integrity rules, 
      the column contains characters corresponding to the type of referential integrity rules for updates, deletions, and insertions.<br/>
      The first character indicates the type of update rule, the second character indicates the type of deletion rule, 
      and the third character indicates the type of insertion rule.<br/>
      Possible values for updates and deletions are "C" for cascade, 
      "R" for restrict, and "I" for ignore. Possible values for insertions are "R" for restrict, and "I" for ignore. 
      For example, if a relation has cascaded updates, restricted deletions, and ignores insertion referential integrity rules, the column contains "CRI".<br/>
    </remarks>
    <example>
       <code language="X#">
        * Close any open databases
        CLOSE DATABASES
        * Clear desktop to prepare for displaying the array
        CLEAR
        * Open sample testdata database
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        * Function call with cSetting for table names
        =ADBObjects(gaTables, "TABLE")
        * Displays array gaTables created by ADBObjects( ) function
        DISPLAY MEMORY LIKE gaTables
      </code>
    </example>
  </adbobjects>
  <addproperty>
    <summary>
      Adds a new property to an object at run time.<br/>
      You can use <b>AddProperty( )</b> to add properties and their values to valid X# objects, 
      including those created from X# classes, COM classes, and the <b>SCATTER...NAME</b> command.
    </summary>
    <param name="oObjectName">
      Specifies the name of the object to which the property is added.<br/>
      If oObjectName is not a valid object, X# generates the appropriate message.
    </param>
    <param name="cPropertyName">
      Specifies the name of the new property to add to the object.<br/>
      If the property with the name you specify does not exist, the property is created and added.
    </param>
    <param name="eNewValue">
      Specifies the value to set for the new property.<br/>
      If you omit eNewValue, and the property exists, X# leaves the value of the property unchanged. 
      If you omit eNewValue, and the property is new, X# sets the value of the new property to False (.F.).
    </param>
    <returns>
      Logical data type. The following table describes the return values for <b>AddProperty( )</b> and the behavior 
      when you attempt to add a property that already exists for an object.
      <list type="table">
        <listheader>
          <term>Return value</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>True (.T.)</term>
          <description>
            When <b>AddProperty( ) </b><br/>
            When the new property is an array property, and the array already exists, <b>AddProperty( )</b> redimensions the array with the dimensions 
            specified by cPropertyName. If you specify a value with eNewValue, all elements in the array are set to that value. 
            If you omit eNewValue, all array elements are set to False (.F.).<br/>
            If the new property is not an array property, but the existing property is an array property. 
            The property remains an array property with the same dimensions. If you specify a value with eNewValue, 
            all elements in the array are set to that value. If you omit eNewValue, all array elements are set to False (.F.).<br/>
            If the new property is not an array property, and the existing property is not an array property or is not a read-only X# native property. 
            If you specify a value with eNewValue, the existing property is set to that value. If you omit eNewValue, the existing property value remains unchanged.<br/>
            If the specified property is already a member of the object but is marked as <b>Hidden</b> or <b>Protected</b>. 
            X# generates an error, "Property name is not found (Error 1734)", and the property is not set to the value passed to <b>AddProperty( )</b>.<br/>
          </description>
        </item>
        <item>
          <term>
            False (.F.)
          </term>
          <description>
            When <b>AddProperty( )</b> did not add the property successfully. <br/>
            If the property is an array property, and the existing property is not an array property. The existing property remains unchanged.
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      You can create property arrays using <b>AddProperty( )</b> for an object. When you do so, every element in the array is initialized with eNewValue, 
      if provided. Otherwise, the value of each property in the array is set to False (.F.). For more information about creating a property array for an object, 
      see the Examples section.<br/>
      X# adds the new property as a <b>Public</b> property. You cannot specify the property as <b>Protected</b> or <b>Hidden</b>.<br/>
      If the existing property is a read-only X# native property, such as the <b>BaseClass</b> property, X# generates an error, "Property name is read-only (Error 1743)".<br/>
      If the property name is not valid, for example, the property name contains a space or other illegal characters, X# generates an error, "Incorrect property name (Error 1470)".<br/>
      For object instances derived from native X# classes, <b>AddProperty( )</b> respects the visibility setting of the intrinsic <b>AddProperty</b> method. 
      If <b>AddProperty</b> is marked as <b>Hidden</b> or <b>Protected</b>, <b>ADDPROPERTY( )</b> does not create the new property and returns False (.F.). 
      If the <b>AddProperty</b> method is marked as <b>Public</b> (default), <b>ADDPROPERTY( )</b> creates the property and returns True (.T.). 
      This protects the original class design.<br/>
      <note>This does not apply to COM objects created with X# OLEPUBLIC classes.</note>
      <b>AddProperty( )</b> does not work when using the <b>FOR EACH</b> command with object references. However, you can use the <b>AddProperty</b> method instead.
      <b>Example 1</b><br/>
      The following example adds a new property to an object created with the <b>SCATTER</b> command.<br/>
       <code language="X#">
        USE customers
        SCATTER NAME oCust
        ADDPROPERTY(oCust,"MyProperty")
      </code><br/>
      <b>Example 2</b><br/>
      The following example creates a property array for the object, codeoMyForm/code, and displays its contents, code1/code and code"Two"/code.
       <code language="X#">
        oMyForm = CreateObject('Form')
        ADDPROPERTY(oMyForm, 'MyArray(2)', 1)
        oMyForm.MyArray(2) = "Two"
        CLEAR
        ? oMyForm.MyArray(1)
        ? oMyForm.MyArray(2)
      </code>
    </remarks>
  </addproperty>
  <aelement>
    <summary>
      Returns the number of an array element from the element's subscripts.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array whose element number you want to return.
    </param>
    <param name="nRowSubscript">
      Specifies the row subscript. If the array is one-dimensional, AElement( ) identically returns nRowSubscript.<br/>
      If you include just nRowSubscript and it is greater than the number of rows in the array, X# generates an error message.
    </param>
    <param name="nColumnSubscript">
      Specifies the column subscript. If the array is two-dimensional, include both nRowSubscript and nColumnSubscript.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      You can refer to an element in a two-dimensional array in one of two ways. The first method uses two subscripts to specify the row and column position 
      of the element in the array, and the second method uses a single-element number. 
      AElement( ) returns the element number when supplied with an element's row and column subscripts.<br/>
      The X# functions ADel( ), ADir( ), AFields( ), AIns( ), ALen( ), AScan( ), ASort( ), and ASubscript( ) can manipulate two-dimensional arrays 
      and require that elements be referred to by their element number. AElement( ) facilitates conversion from subscripts to an element number 
      for use by these functions. The corresponding row and column subscripts can be returned from an element number with ASubscript( ).<br/>
      The following example illustrates the creation of an array with two rows and three columns. DISPLAY MEMORY shows the contents 
      of the elements of the array listed in element number order.
       <code language="X#">
        DIMENSION gaMyArray(2,3)
        DISPLAY MEMORY LIKE gaMyArray
        gaMyArray   Pub  A
        ( 1, 1)   L  .F. (element number 1)
        ( 1, 2)   L  .F. (element number 2)
        ( 1, 3)   L  .F. (element number 3)
        ( 2, 1)   L  .F. (element number 4)
        ( 2, 2)   L  .F. (element number 5)
        ( 2, 3)   L  .F. (element number 6)
      </code>
      An element can be referred to by its subscripts or its element number. The commands codeSTORE 'INVOICE' TO gaMyArray(2, 1)/code and 
      codeSTORE 'INVOICE' TO gaMyArray(4)/code both store the character string INVOICE to the same array element.<br/>
      In one-dimensional arrays, an element number is identical to its single-row subscript. It isn't necessary to use AElement( ) with one-dimensional arrays.
    </remarks>
  </aelement>
  <agetfileversion>
    <summary>
      Creates an array containing information about files with Windows version resources such as .exe, .dll, and .fll files, or automation servers created in X#.
      For a X# automation server to have Windows version resources, you must specify a value for at least one item in the EXE Version dialog box. 
      For more information, see EXE Version Dialog Box.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array in which the file information is placed. If the array you specify doesn't exist, X# automatically creates the array. 
      If the array exists and isn't large enough to contain the file information, X# automatically increases the size of the array. 
      If the array is larger than necessary, X# truncates the array.
    </param>
    <param name="cFileName">
      Specifies the name, and optionally the path, of the target file.
    </param>
    <returns>
      Numeric. <b>AGetfileversion( )</b> returns the number of elements in the array. 
      If the file you specify does not exist or does not contain Windows version resources, 
      <b>AGetfileversion( )</b> returns zero, and the array, if already created, remains unchanged.
    </returns>
    <remarks>
      The table below lists the contents of each element of the array.
      For example, you can use the following code to determine the Locale ID for the X# executable file:
       <code language="X#">
        DIMENSION aFiles[1]
        AGetfileversion(aFiles,"VFP9.EXE")
        ? EVAL("0x"+LEFT(aFiles[15],4))
        ** Returns 1033 for US version
      </code>
      <list type="table">
        <listheader>
          <term>element of the array</term>
          <description>contents</description>
        </listheader>
        <item>
          <term>1</term>
          <descripton>Comments</descripton>
        </item>
        <item>
          <term>2</term>
          <descripton>Company Name</descripton>
        </item>
        <item>
          <term>3</term>
          <descripton>File Description</descripton>
        </item>
        <item>
          <term>4</term>
          <descripton>File Version</descripton>
        </item>
        <item>
          <term>5</term>
          <descripton>Internal Name</descripton>
        </item>
        <item>
          <term>6</term>
          <descripton>Legal Copyright</descripton>
        </item>
        <item>
          <term>7</term>
          <descripton>Legal Trademarks</descripton>
        </item>
        <item>
          <term>8</term>
          <descripton>Original File Name</descripton>
        </item>
        <item>
          <term>9</term>
          <descripton>Private Build</descripton>
        </item>
        <item>
          <term>10</term>
          <descripton>Product Name</descripton>
        </item>
        <item>
          <term>11</term>
          <descripton>
            Product Version
            The format of this value is dependent on the version of X#. For details, see VERSION( ) Function.
          </descripton>
        </item>
        <item>
          <term>12</term>
          <descripton>Special Build</descripton>
        </item>
        <item>
          <term>13</term>
          <descripton>OLE Self Registration (contains "OLESelfRegister" if the file supports self-registration; otherwise contains the empty string)</descripton>
        </item>
        <item>
          <term>14</term>
          <descripton>Language (derived from the Translation Code)</descripton>
        </item>
      </list>
      <b>AGetfileversion( )</b> can be abbreviated to a minimum number of 5 characters.
    </remarks>
  </agetfileversion>
  <alines>
    <summary>
      Copies each line in a character expression or memo field to a corresponding row in an array.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array to store the copied lines in the character expression or memo field.
    </param>
    <param name="cExpression">
      Specifies the character expression or memo field containing the lines to copy to the array. All character expressions are case-sensitive.
      If cExpression is the empty string or the null value, an array with a single row is created and the row contains the empty string. 
      You can use double-byte expressions.
    </param>
    <param name="nFlags">
      In previous versions of X#, nFlags was the lTrim option. The lTrim option corresponds to a value of 1 for nFlag. Previous code will run identically in X# 9.0.
      The table below describes the values for nFlags.
    </param>
    <param name="cParseChar">
      Specifies one or more character strings that terminate the elements in cExpression.
    </param>
    <param name="cParseChar2">
      Specifies one or more character strings that terminate the elements in cExpression.
    </param>
    <returns>
      Numeric. <b>ALines( )</b> returns the number of rows in the array, or, identically, the number of lines in the character expression or memo field.
    </returns>
    <remarks>
      If the array you specify does not exist, X# automatically creates the array. 
      If the array exists but is not large enough to contain all the lines in the memo field, X# automatically increases the size of the array. 
      If the array is larger than necessary, X# truncates the array.<br/><br/>
      <list type="table">
        <listheader>
          <term>Bit</term>
          <description>Value</description>
          <description>Descripton</description>
        </listheader>
        <item>
          <term>0</term>
          <description>1</description>
          <description>(Default) Removes leading and trailing spaces from lines, or for Varbinary and Blob values, removes trailing zeroes (0) instead of spaces.</description>
        </item>
        <item>
          <term>1</term>
          <description>2</description>
          <description>Include the last element in the array even if the element is empty.</description>
        </item>
        <item>
          <term>2</term>
          <description>4</description>
          <description>Do not include empty elements in the array.</description>
        </item>
        <item>
          <term>3</term>
          <description>8</description>
          <description>Specifies case-insensitive parsing.</description>
        </item>
        <item>
          <term>4</term>
          <description>16</description>
          <description>Include the parsing characters in the array.</description>
        </item>
      </list>
      When used with binary values, such as <b>Varbinary</b> and <b>Blob</b>, <b>ALines( )</b> creates an array with elements that have <b>Varbinary</b> type.<br/><br/>
      When cParseChar is specified, the line breaks when cParseChar is found, and the next line continues with the character following cParseChar.<br/>
      The maximum number of strings permitted in cParseChar is 23.<br/>
      You can use a line feed (CHR(10)) or carriage return (CHR(13)) character to denote the end of a line. 
      You can also denote the end of the line with either combination of these two characters, for example, (CHR(10) + CHR(13) or CHR(13) + CHR(10)). 
      The default behavior for <b>ALines( )</b> is to ignore CHR(13) and CHR(10) when you specify one or more values for cParseChar, 
      unless you also specify the end of line characters.<br/>
      When cParseChar is omitted for <b>Varbinary</b> or <b>Blob</b> input, <b>ALines( )</b> treats the hexadecimal value 0hA (10) as a carriage return 
      and discontinues the line at that location. The value, 0hA, is not saved in the resulting array element and might result in an incorrect binary value. 
      For example, given the binary value, 0hFE0AF2, <b>ALines( )</b> creates a two-element array with the values, 0hFE and 0hF2.<br/>
      <b>ALines( )</b> provides an easy way to parse lines in a character expression or memo field. 
      While you can also use <b>MLINES( )</b> to parse a character expression or memo field, <b>ALines( )</b> is faster and requires less programming. 
      Also, <b>ALines( )</b> is not affected by the value of <b>SET MEMOWIDTH</b>.<br/>
      The first line of the character expression or memo field is copied to the first row of the array, 
      the second line of the character expression or memo field is copied to the second row of the array, and so on.<br/>
      You must have sufficient memory to copy the lines in a large memo field to an array. X# generates an error message if you lack sufficient memory.<br/>
      If you want to perform a case-insensitive parse, you can follow one of the following examples:
       <code language="X#">? ALines(aMyArray, UPPER(employee.notes), "R.") </code>
      - OR -
       <code language="X#">? ALines(aMyArray, employee.notes, "R.", "r.")</code>
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        SET TALK OFF
        OPEN DATABASE (HOME(2) + "data\testdata")
        USE employee  &amp;&amp; Open Employee table
        ? ALines(aMyArray, employee.notes)            &amp;&amp; Displays 1
        ? ALines(aMyArray, employee.notes, CHR(13))   &amp;&amp; Displays 1
        ? ALines(aMyArray, employee.notes, " ")       &amp;&amp; Displays 75
        ? ALines(aMyArray, employee.notes, ".")       &amp;&amp; Displays 7
        ? ALines(aMyArray, employee.notes, ",")       &amp;&amp; Displays 4
        ? ALines(aMyArray, employee.notes, ".", ",")  &amp;&amp; Displays 10
        ? ALines(aMyArray, employee.notes, 8, "m")    &amp;&amp; Displays 14
        ? ALines(aMyArray, employee.notes, "m")       &amp;&amp; Displays 11
        ? ALines(aMyArray, employee.notes, "M")       &amp;&amp; Displays 4
      </code>
    </example>
  </alines>
  <amembers>
    <summary>
      Places the names of properties, procedures, and member objects for an object into a variable array.
    </summary>
    <param name="ArrayName">
      Specifies the array into which the names of the member properties for oObjectName are placed. 
      If you specify the name of an array that doesn't exist, the array is automatically created. 
      If the array isn't large enough to contain all the names, X# automatically increases the size of the array.
    </param>
    <param name="oObjectNameOrClassName">
      Specifies the object or X# class whose member properties are placed in the variable array specified with ArrayName. 
      This can be any expression that evaluates to an object, such as an object reference, an object variable, or an object array element.<br/>
    </param>
    <param name="nArrayContentsID">
      Specifies the contents of an array.
    </param>
    <param name="cFlags">
      Specify the filtering applied to the array returned by the AMembers( ) function. 
      cFlags will not function when AMembers( ) is passed a COM object (the value of ArrayContentsID is 3). 
      Some flags are mutually exclusive so that if you use more than one cFlag, use them in the following groupings:
      <code>[P | H | G] [N | U] [C] [I | B] [R]</code>
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term> </term>
          <description>Description</description>
        </listheader>
        <item>
          <term>0</term>
          <description>
            Specifies that the array contains a single column of property names. Omitting the nArrayContentsID parameter is the same as passing a 0.
          </description>
        </item>
        <item>
          <term>1</term>
          <description>
            Specifies that the array contains the names of the properties of the object or class, as well as the methods and member objects. 
            The resulting array is two-dimensional with the second column specifying what type of member is listed in the first column. 
            The possible values for the second column are Property, Event, Method, or Object.
          </description>
        </item>
        <item>
          <term>2</term>
          <description>
            Specifies that the array contains the names of objects that are members of a native X# object specified with oObjectName. The resulting array is one-dimensional.
            This option provides a method to determine the names of child objects in a container such as all Form objects in a form set or controls in a form.
          </description>
        </item>
        <item>
          <term>3</term>
          <description>
            Specifies that the array contains information about one or more objects. You can pass an object reference to either a native X# object or to a COM object.
            <note>A value of 3 for this parameter is not supported in .app or .exe applications.</note>
          </description>
        </item>
      </list>
      The array returned when you specify this parameter consists of four columns as described in the table in the remarks section:
      <list type="table">
        <listheader>
          <term>Column</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>1</term>
          <description>Name of the event or method</description>
        </item>
        <item>
          <term>2</term>
          <description>Property type (for example, PROPERTYPUT, PROPERTYGET, PROPERTYPUTREF, METHOD)</description>
        </item>
        <item>
          <term>3</term>
          <description>
            Function signature (parameters and their types, and the function return type). This information is similar to the Quick Info text provided in IntelliSense expansion of a method.
          </description>
        </item>
        <item>
          <term>4</term>
          <description>Help string</description>
        </item>
      </list>
      If you omit nArrayContentsID, AMembers( ) returns a one column array of properties.<br/><br/>
      The tables below describe the valid values for cFlags.
      <list type="table">
        <listheader>
          <term>Value</term>
          <description>Filter Flags</description>
        </listheader>
        <item>
          <term>P</term>
          <description>Protected properties, methods, or events</description>
        </item>
        <item>
          <term>H</term>
          <description>Hidden properties, methods, or events</description>
        </item>
        <item>
          <term>G</term>
          <description>Public properties, methods, or events</description>
        </item>
        <item>
          <term>N</term>
          <description>Native (Intrinsic) properties, methods, or events</description>
        </item>
        <item>
          <term>U</term>
          <description>User-Defined (Extrinsic) properties, methods, or events</description>
        </item>
        <item>
          <term>C</term>
          <description>Changed properties (but not changed array properties)</description>
        </item>
        <item>
          <term>I</term>
          <description>Inherited properties, methods, or events</description>
        </item>
        <item>
          <term>B</term>
          <description>Base properties, methods, or events (using the AddProperty method)</description>
        </item>
        <item>
          <term>R</term>
          <description>Read-Only Properties</description>
        </item>
      </list>
      The default configuration for the filtering specified by cFlags is logical OR between flags. You can change this by using the special "+" cFlags.
      <list type="table">
        <listheader>
          <term>Value</term>
          <description>Special Flags</description>
        </listheader>
        <item>
          <term>#</term>
          <description>Adds a new column to the output array with the corresponding cFlags value.</description>
        </item>
        <item>
          <term>+</term>
          <description>Performs logical AND between filter flags.</description>
        </item>
      </list>
      AMembers( ) returns the number of objects, properties, and procedures for the object, or 0 if the array cannot be created. If you omit the optional 1, 2, or 3 flag parameters, a one-dimensional array is created containing the properties of oObjectName.
      You can pass COM object references to the AMembers( ) function, but when you do so, you must also pass a value of 3 in the third (flag) parameter, as in the following example.
       <code language="X#">
        oExcel = CreateObject("excel.application")
        = AMembers(gaPropArray, oExcel, 3)
      </code>
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        goForm1 = CreateObject("Form")  &amp;&amp; Creates a Form
        = AMembers(gaPropArray, goForm1, 1)  &amp;&amp; Array containing Form properties
        DISPLAY MEMORY LIKE gaPropArray  &amp;&amp; Display the Form properties
      </code>
    </example>
  </amembers>
  <anetresources>
    <summary>
      Places the names of network shares or printers into an array and then returns the number of resources.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array containing the network share or printer information.
    </param>
    <param name="cNetworkName">
      Specifies the name of the network or domain for which share or printer information is returned.
    </param>
    <param name="nResourceType">
      Specifies the type of network resource for which information is returned.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the information, 
      X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array.<br/>
      If the array exists and ANetResources( ) returns 0 because no network shares or printers are found, the array remains unchanged. 
      If the array doesn't exist and ANetResources( ) returns 0, the array isn't created.<br/>
      The network name should be in the format "\\NetworkName." You do not have to be connected to the network you specify, 
      and specifying a network doesn't connect you to the network. 
      If you specify a domain name, ANetResources( ) returns an array of members or resources from that domain.<br/>
      The names of shares on the network are returned if nResourceType evaluates to 1. 
      The names of printers on the network are returned if nResourceType evaluates to 2. A value of 0 returns the name of any resource.<br/>
      ANetResources( ) returns the number of network shares or printers found (identical to the number of rows in the array). 
      ANetResources( ) returns zero if there are no shares or printers for the network of the type you specify, or the network you specify doesn't exist.<br/>
      Before Windows 2000, share names were limited to twelve characters in length. 
      If you run ANetResources() on a computer that uses an operating system earlier than Windows 2000, 
      ANetResources() will not return any shares that are on computers running Windows 2000 or later that have share names longer than twelve characters.<br/>
      Refer to the WNetOpenEnum and WNetEnumResource Win32 API functions for more details.
    </remarks>
  </anetresources>
  <aprinters>
    <summary>
      Stores information about currently-available printers into an array.<br/>
      The behavior of this function is OS (operating system) - specific.  
      X# may or may not check to see if the printers are actually connected to your computer when it prepares this list, 
      and the list may include all printers installed as printer setups, or only those available on the current network.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array containing information about printers.
    </param>
    <param name="nValue">
      Specifies a value that creates a two-column array or five-column array. Each row in the array contains information about a printer.<br/>
      The table in the remarks section describes the possible values of nValue.
    </param>
    <remarks>
      If the array you include does not exist, X# automatically creates the array. If the array exists but is not large enough to contain all the information, 
      X# increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array. 
      If the array exists but <b>APRINTERS( )</b> returns 0 because no printers are available, the array remains unchanged. 
      If the array does not exist, and <b>APRINTERS( )</b> returns 0, the array is not created.<br/><br/>
      <list type="table">
        <listheader>
          <term>nValue</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>0 or omitted</term>
          <description>
            Return a two-column array containing the following items beginning with the first column:
            <list type="bullet">
              <item>
                <description>Printer name.</description>
              </item>
              <item>
                <description>Name of the port to which the printer is connected.</description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <term>1</term>
          <description>
            Return a five-column array containing the following items beginning with the first column:
            <list type="bullet">
              <item>
                <description>Printer name.</description>
              </item>
              <item>
                <description>Name of the port to which the printer is connected.</description>
              </item>
              <item>
                <description>Name of the printer driver.</description>
              </item>
              <item>
                <description>Printer comment.</description>
              </item>
              <item>
                <description>Printer location.</description>
              </item>
            </list>
          </description>
        </item>
      </list>
    </remarks>
    <returns>
      Numeric. <b>APRINTERS( )</b> returns the number of rows in the array or 0 when no printers are available.
    </returns>
    <example>
       <code language="X#">
        IF APRINTERS(gaPrinters) &gt; 0
        CLEAR  &amp;&amp; clear the current output window
        DISPLAY MEMORY LIKE gaPrinters &amp;&amp; show the contents of the array
        ELSE
        WAIT WINDOW 'No printers found.'
        ENDIF
      </code>
    </example>
  </aprinters>
  <asessions>
    <summary>
      Creates an array of existing data session IDs.
    </summary>
    <param name="ArrayName">
      Specifies the array that contains the data session IDs.
    </param>
    <returns>
      Numeric. Returns the number of data sessions.
    </returns>
    <remarks>
      If the array does not exist, X# automatically creates and populates it. X# automatically resizes the array to accommodate current data sessions.
    </remarks>
  </asessions>
  <asqlhandles>
    <summary>
      Stores numeric references to all active SQL connection statement handles in an array.
    </summary>
    <param name="ArrayName">
      Specifies the name of an array to store statement handle information.
      If the array you specify does not exist, X# creates the array automatically. If the array exists and is not large enough to store the information, 
      X# increases the array size automatically. If the array is larger than necessary, X# truncates the array.
    </param>
    <param name="nStatementHandle">
      Populates the array with statement handles that use the same shared connection, including nStatementHandle.
    </param>
    <returns>
      Numeric. <b>ASQLHandles( )</b> returns the number of statement handles in use. If no statement handles are available, 
      <b>ASQLHandles( )</b> returns 0 and does not modify the array.
    </returns>
    <remarks>
      You can use references to statement handles in other X# SQL functions, such as <b>SQLEXEC( )</b> and <b>SQLDISCONNECT( )</b>. 
      For more information, see SQLEXEC( ) Function and SQLDISCONNECT( ) Function.
      You can create and return new statement handles using the <b>SQLCONNECT( )</b> and <b>SQLSTRINGCONNECT( )</b> functions. 
      For more information, see SQLCONNECT( ) Function and SQLSTRINGCONNECT( ) Function.
    </remarks>
  </asqlhandles>
  <astackinfo>
    <summary>
      Creates an array and populates it with information about the current state of the call stack.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array to store information about the call stack.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The following table describes the information returned by the AStackInfo( ) function:
      <list type="table">
        <listheaders>
          <term>Array Element</term>
          <description>Description</description>
        </listheaders>
        <item>
          <term>1</term>
          <description>Call Stack Level</description>
        </item>
        <item>
          <term>2</term>
          <description>Current program filename</description>
        </item>
        <item>
          <term>3</term>
          <description>Module or Object name</description>
        </item>
        <item>
          <term>4</term>
          <description>Module or Object Source filename</description>
        </item>
        <item>
          <term>5</term>
          <description>Line number in the object source file</description>
        </item>
        <item>
          <term>6</term>
          <description>Source line contents</description>
        </item>
      </list>
      <br/>
      AStackInfo( ) populates an array with information about the entire calling stack. 
      It combines functionality of SYS(16) and PROGRAM( ) functions while adding new support for line numbers at each call stack level. 
      The value returned is the number of program levels or rows of the returned array.<br/>
      AStackInfo( ) only populates the 6th array element if source line contents are available, otherwise it will be left empty.<br/>
      AStackInfo( ) provides, in the 2nd and 4th elements respectively, the name of the current file and, 
      if the file is bound in an APP or other separate file, a full path name to the binding program.<br/>
      The 4th element contains the original source file information. 
      For objects, this is same information returned by SYS(16), even when bound inside of applications.<br/>
      AStackInfo() might not be able to retrieve information about program (.prg) files. 
      In this case, X# displays the 2nd element similar to the SYS(16) function. For more information, see SYS(16) - Executing Program File Name.
    </remarks>
    <example>
       <code language="X#">
        AStackInfo(myarray)
        DISPLAY MEMO LIKE myarray
        myArray
        (1,1)   1                                    &amp;&amp; Stack level = 1
        (1,2)   c:\vfp\myAppl.app                        &amp;&amp; Current program
        (1,3) frmRerport.PrintReport.Click         &amp;&amp; Object
        (1,4) c:\vfp\myclasses\buttons.vct         &amp;&amp; Object source file name
        (1,5) 42                              &amp;&amp; Line number in the source
        (1,6) THISFORM.DoReport()                  &amp;&amp; in the source
        (2,1)   2                                    &amp;&amp; Stack level = 2
        (2,2) c:\vfp\myAppl.app
        (2,3) frmRerport.DoReport
        (2,4) c:\vfp\forms\frmRerport.sct         &amp;&amp; Module source file name
        (2,5) 31
        (2,6) DO RunListReport                     &amp;&amp; in the source
        (3,1)   3                                    &amp;&amp; Stack level = 3
        (3,2) c:\vfp\myAppl.app
        (3,3)
        (3,4) c:\vfp\programs\runlisterport.prg   &amp;&amp; Module source file name
        (3,5) 12
        (3,6) REPORT FORM myreport1.frx            &amp;&amp; in the source
        (4,1)   4                                    &amp;&amp; Stack level = 4
        (4,2) c:\vfp\reports\myreport1.frt
        (4,3) myreport1.DataEnvironment.BeforeOpenTables
        (4,4) c:\vfp\reports\myreport1.frt          &amp;&amp; Module source file name
        (4,5) 31
        (4,6) DO FORM getcusts                     &amp;&amp; in the source
        (5,1)   5                                    &amp;&amp; Stack level = 5
        (5,2) c:\vfp\myAppl.app
        (5,3) getcusts.init
        (5,4) c:\vfp\forms\getcusts.sct            &amp;&amp; Module source file name
        (5,5) 2
        (5,6) AStackInfo(myarray)                  &amp;&amp; in the source
      </code>
    </example>
  </astackinfo>
  <asubscript>
    <summary>
      Returns the row or column subscript of an element from the element's number.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array.
    </param>
    <param name="nElementNumber">
      Specifies the element number.
    </param>
    <param name="nSubscript">
      Determines if the row or column subscript is returned.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If the array is one-dimensional, include the element number in nElementNumber and 1 in nSubscript. 
      ASubscript( ) identically returns nElementNumber.<br/>
      If the array is two-dimensional, include both the element number nElementNumber and a value of 1 or 2 in nSubscript. 
      Specifying 1 in nSubscript returns the row subscript of the element, and specifying 2 returns the column subscript.<br/>
      For more information on how to reference elements in an array, see DIMENSION.<br/>
      You can refer to elements in two-dimensional variable arrays in one of two ways. 
      The first method uses two subscripts to specify the row and column position of the element in the array. The second method uses an element number. 
      Use ASubscript( ) to obtain an element's row or column subscript from the element's number.<br/>
      In the following example, an array with two rows and three columns is created. 
      DISPLAY MEMORY shows the contents of the elements of the array listed in element number order.<br/>
       <code language="X#">
        DIMENSION gaMyArray(2,3)
        DISPLAY MEMORY LIKE gaMyArray
        GAMYARRAY  Pub  A
        ( 1, 1)   L  .F. (element number 1)
        ( 1, 2)   L  .F. (element number 2)
        ( 1, 3)   L  .F. (element number 3)
        ( 2, 1)   L  .F. (element number 4)
        ( 2, 2)   L  .F. (element number 5)
        ( 2, 3)   L  .F. (element number 6)
      </code>
      Each of these commands stores the character string INVOICE to the same array element:
       <code language="X#">
        STORE 'INVOICE' TO gaMyArray(2, 1)
        STORE 'INVOICE' TO gaMyArray(4)
      </code>
      In one-dimensional arrays, an element's number is identical to its single row subscript. 
      It isn't necessary to use ASubscript( ) with one-dimensional arrays.
    </remarks>
  </asubscript>
  <at>
    <summary>
      Searches a character expression for the occurrence of another character expression.
      The search performed by <b>AT( )</b> is case-sensitive. To perform a search that is not case-sensitive, use <b>ATC( )</b>. 
      For more information, see ATC( ) Function.
    </summary>
    <param name="cSearchExpression">
      Specifies the character expression to search for in cExpressionSearched.
    </param>
    <param name="cExpressionSearched">
      Specifies the character expression to search for cSearchExpression.
      Both cSearchExpression and cExpressionSearched can be memo fields of any size.
    </param>
    <param name="nOccurrence">
      Specifies which occurrence, first, second, third, and so on, of cSearchExpression to search for in cExpressionSearched. 
      By default, <b>AT( )</b> searches for the first occurrence of cSearchExpression (nOccurrence = 1).
    </param>
    <returns>
      Numeric. <b>AT( )</b> returns an integer indicating the position of the first character for a character expression or memo field within another 
      character expression or memo field, beginning from the leftmost character. If the expression or field is not found, 
      or if nOccurrence is greater than the number of times cSearchExpression occurs in cExpressionSearched, <b>AT( )</b> returns 0.
    </returns>
    <example>
       <code language="X#">
        STORE 'Now is the time for all good men' TO gcString
        STORE 'is the' TO gcFindString
        CLEAR
        ? AT(gcFindString,gcString)  &amp;&amp; Displays 5
        STORE 'IS' TO gcFindString
        ? AT(gcFindString,gcString)  &amp;&amp; Displays 0, case-sensitive
      </code>
    </example>
  </at>
  <ataginfo>
    <summary>
      Creates an array that contains information about index files for the selected table.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array to create. X# creates the array if it does not already exist.
    </param>
    <param name="cCDXName">
      Specifies the name of the compound index (.cdx) file to return information for.
      Specifying an empty string ("") returns the number of tags in all open .cdx files and all open standalone index (.idx) files for the selected table.
    </param>
    <param name="uArea">
      Specifies the work area number or workarea alias that contains the table to returns information for. <br/>
      Omitting this uses the table in the current work area.
    </param>
    <returns>
      Numeric. <b>ATagInfo( )</b> returns the number of index tags in compound index (.cdx) files 
      or open single-key standalone index (.idx) files for the current table.
    </returns>
    <remarks>
      The following table describes the information stored in the array that <b>ATagInfo( )</b> creates.
      <list type="table">
        <listheader>
          <term>Column</term>
          <description>Description</description>
          <description>Data type</description>
        </listheader>
        <item>
          <term>1</term>
          <description>Index tag name in a .cdx file or index file name for .idx files</description>
          <description>Character</description>
        </item>
        <item>
          <term>2</term>
          <description>Index tag type</description>
          <description>Character</description>
        </item>
        <item>
          <term>3</term>
          <description>Index key expression</description>
          <description>Character</description>
        </item>
        <item>
          <term>4</term>
          <description>Filter expression</description>
          <description>Character</description>
        </item>
        <item>
          <term>5</term>
          <description>Index order as created (Ascending or Descending)</description>
          <description>Character</description>
        </item>
        <item>
          <term>6</term>
          <description>Collate sequence</description>
          <description>Character</description>
        </item>
      </list>
    </remarks>
  </ataginfo>
  <atc>
    <summary>
      Returns the beginning numeric position of the first occurrence of a character expression or memo field within another character expression or memo field, 
      without regard for the case of these two expressions.
    </summary>
    <param name="cSearchExpression">
      Specifies the character expression that ATC( ) searches for in cExpressionSearched.
    </param>
    <param name="cExpressionSearched">
      Specifies the character expression cSearchExpression searches for.
      Both cSearchExpression and cExpressionSearched can be memo fields of any size.
    </param>
    <param name="nOccurrence">
      Specifies which occurrence (first, second, third, and so on) of cSearchExpression is searched for in cExpressionSearched. 
      By default, ATC( ) searches for the first occurrence of cSearchExpression (nOccurrence = 1). 
      Including nOccurrence lets you search for additional occurrences of cSearchExpression in cExpressionSearched.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      ATC( ) searches the second character expression for the occurrence of the first character expression, 
      without concern for the case (upper or lower) of the characters in either expression. Use AT( ) to perform a case-sensitive search.
      ATC( ) returns an integer corresponding to the position where the first character of the character expression is found. 
      If the character expression isn't found, ATC( ) returns 0.
    </remarks>
    <example>
       <code language="X#">
        STORE 'Now is the time for all good men ... ' TO gcString
        STORE 'IS THE' TO gcFindString
        CLEAR
        ? ATC(gcFindString, gcString)  &amp;&amp; Displays 5
        STORE 'is' TO gcFindString
        ? ATC(gcFindString, gcString)  &amp;&amp; Displays 5
        ? ATC('now',gcString)  &amp;&amp; Displays 1
      </code>
    </example>
  </atc>
  <aused>
    <summary>
      Places table aliases and work areas for a data session into a variable array.
    </summary>
    <param name="ArrayName">
      Specifies the name of the array containing the table aliases and work areas for a data session.
    </param>
    <param name="nDataSessionNumber">
      Specifies the data session number for which <b>AUsed( )</b> returns the table aliases and work areas. 
      If you omit nDataSessionNumber, <b>AUsed( )</b> returns information about the current data session. 
      Use <b>SET DATASESSION</b> to specify the current data session.
    </param>
    <param name="cTableName">
      The array will only contain aliases of the table specified with cTableName.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If the array you specify does not exist, X# automatically creates the array. 
      If the array exists and is not large enough to contain all the table aliases and work areas, X# automatically increases the size of the array. 
      If the array is larger than necessary, X# truncates the array. If the array exists, 
      and <b>AUsed( )</b> returns 0 because no tables are open in the data session, the array remains unchanged. If the array does not exist, 
      and <b>AUsed( )</b> returns 0, the array is not created.<br/><br/>
      The current data session is used if you set nDataSessionNumber to the null value (.NULL.).<br/>
      cTableName can be in the following formats, listed in the order in which X# searches for tables.<br/>
      DatabaseName!TableName or DatabaseName!ViewName.<br/>
      Path\DatabaseName!TableName or Path\DatabaseName!ViewName.<br/>
      Database container (DBC) defined table name or view in the current DBC in the data session.<br/>
      Simple or full table name.<br/>
      <br/>
      <b>AUsed( )</b> returns the number of rows in the array, which is identical to the number of tables open in the data session.<br/>
      <br/>
      <b>AUsed( )</b> creates a two-dimensional array and places the aliases of tables open for the data session in the first column of the array. The second column of the array contains the tables' corresponding work area numbers.<br/>
      The table aliases are placed into the array in reverse order that they were opened in. For example, the first array element contains the alias of the last table opened, and the last array element contains the alias of the first table opened. This ordering is useful when using <b>TABLEUPDATE( )</b> on views that contain views. For example:<br/>
       <code language="X#">
        FOR x = 1 TO AUsed(aTableAliases,1)
        IF CURSORGETPROP( "Buffering", aTableAliases(x) ) &gt; 1 &amp;&amp; Buffered
        ? TABLEUPDATE( 0, .T., aTableAliases(x) )
        ENDIF
        NEXT
      </code>
    </remarks>
    <example>
       <code language="X#">
        OPEN DATABASE (HOME(2) + 'Data\testdata') EXCLUSIVE
        USE Customer IN 0
        CLEAR
        ? AUsed(gaInuse)
        DISPLAY MEMORY LIKE gaInuse
        CLOSE DATABASES
      </code>
    </example>
  </aused>
  <bintoc>
    <summary>
      Converts a numeric value to a binary character representation.
    </summary>
    <param name="nExpression">
      Specifies the value to convert. For eFlags settings 1, 2 or 4, this value is an integer. Otherwise, the expression data type is based on the eFlags setting.
    </param>
    <param name="eFlags">
      Specifies the length in characters of the returned character string.
    </param>
    <returns>
      Character. BinToc( ) returns a binary character expression.
    </returns>
    <remarks>
      eFlags determines the value you can specify for nExpression. eFlags can either be numeric or character. 
      The following table lists the permissible values for eFlags and the corresponding range of values for nExpression:<br/>
      <list type="table">
        <listheader>
          <term>eFlags</term>
          <description>nExpression Range</description>
        </listheader>
        <item>
          <term>1</term>
          <description>–128 to 127</description>
        </item>
        <item>
          <term>2</term>
          <description>–32,768 to 32,767</description>
        </item>
        <item>
          <term>4</term>
          <description>
            –2,147,483,648 to 2,147,483,647 <br/>
            This is default setting.
          </description>
        </item>
        <item>
          <term>8</term>
          <description>
            The range of nExpression depends on its type. Only numeric, float, double, and currency data types are supported with this option. 
            See X# Data and Field Types for the ranges of the numeric, float, double, and currency data types.<br/>
            BinToc( ) returns 8 bytes for this setting.
          </description>
        </item>
        <item>
          <term>F</term>
          <description>nExpression is interpreted as a Float Field Type and BinToc( ) returns 4 bytes.</description>
        </item>
        <item>
          <term>B</term>
          <description>nExpression is interpreted as a Double Field Type and BinToc( ) returns 8 bytes.</description>
        </item>
        <item>
          <term>R</term>
          <description>Reverses the resulting binary expression.</description>
        </item>
        <item>
          <term>S</term>
          <description>Prevents the sign bit of number from being toggled (BitXOR).</description>
        </item>
      </list>
      If this parameter is omitted, BinToc( ) returns a character string composed of four characters.<br/>
      <br/>
      The eFlags parameter can either be numeric or character. The 'R' and 'S' settings are additive while the others are mutually exclusive. 
      Character settings can be passed in either upper or lower case (e.g., 'R' or 'r'). The following examples show various uses of the eFlags parameter.
       <code language="X#">
        ? BinToc(1,1)
        ? BinToc(1000,"2")&amp;&amp; same as BinToc(1000,2)
        ? BinToc($12.34,8)
        ? BinToc(1, "4RS")&amp;&amp; same as BinToc(1,"RS")
        ? BinToc(-100, "Fr")
      </code>
      You can use BinToc( ) to reduce the size of indexes for numeric fields containing integer data by passing a numeric eFlags parameter. 
      For example, a numeric field named codenPartCode/code might contain an integer value from 1 to 32,767, which corresponds to a parts classification code. 
      BinToc( ) lets you convert the value in the numeric field to a smaller character representation. For example, 
      the following command creates an index with a two-character index key:
       <code language="X#">INDEX ON BinToc(nPartCode,2) TAG PartCode</code>
      When using BinToc( ) for an 8 byte index creation, you should use 8 and not "B". For 4 byte results, you should use 4 if nExpression is an integer type. 
      Otherwise, you should use 'F' for floating point type.
      BinToc( ) can also be used when working with Win32 API routines where you might need to convert to or from a Win32 struct member. When used for indexing, 
      BinToc( ) needs to properly handle negative numbers for the resulting binary expression. This is done by using a BitXOR operation on the high bit. 
      This also means that the most significant byte is first. For Win32 API routines on an Intel platform, 
      the architecture follows the little-endian rule where the least significant byte is stored first (memory location with lowest address). 
      The 'R' and 'S' settings allow you to use BinToc( ) to work more efficiently with routines that use structs.
    </remarks>
  </bintoc>
  <bitand>
    <summary>
      Performs a bitwise AND operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result. 
      There is a numeric and a binary version of the syntax.
    </summary>
    <param name="BinaryExpression1">
      Specifies Varbinary or Blob values to perform the bitwise AND operation.
    </param>
    <param name="BinaryExpression2">
      Specifies Varbinary or Blob values to perform the bitwise AND operation.
    </param>
    <returns>
      <b>Numeric</b> or <b>Varbinary</b>. <b>BitAnd( )</b> returns the result of the bitwise AND operation performed on the specified expressions.
      For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value 
      up to the length of the longest value. The appropriate operation is then performed between those values.
    </returns>
    <remarks>
      <note>You can specify a maximum of 26 values. The specified values must have the same type. If the specified expressions are not integers, 
      they are converted to integers before performing the operation.</note><br/>
      <b>BitAnd( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If the bits in eExpressionN and eExpressionN+1 are both 1, 
      the corresponding result bit is set to 1; otherwise, the corresponding result bit is set to 0.<br/>
      The following table shows the result of a bitwise AND operation on corresponding eExpressionN and eExpressionN+1 bits:
      <list type="table">
        <listheader>
          <term>eExpressionN bit</term>
          <description>eExpressionN+1 bit</description>
          <description>Resulting bit</description>
        </listheader>
        <item>
          <term>0</term>
          <description>0</description>
          <description>0</description>
        </item>
        <item>
          <term>0</term>
          <description>1</description>
          <description>0</description>
        </item>
        <item>
          <term>1</term>
          <description>1</description>
          <description>1</description>
        </item>
        <item>
          <term>1</term>
          <description>0</description>
          <description>0</description>
        </item>
      </list>
    </remarks>
    <example>
       <code language="X#">
        x = 3  &amp;&amp; 0011 binary
        y = 6  &amp;&amp; 0110 binary
        ? BitAnd(x,y) &amp;&amp; Returns 2, 0010 binary
      </code>
    </example>
  </bitand>
  <bitclear>
    <summary>
      Clears the specified bit in a <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> value by setting it to 0 and returns the resulting value. 
      There is a numeric and a binary version of the syntax.
      If the specified expression is not an integer, it is converted to an integer before performing the operation.
    </summary>
    <param name="nNumericExpression1">
      Specifies the <b>Numeric</b> value to clear the bit in. If the expression is not an integer, it is converted to an integer before setting the bit.
    </param>
    <param name="nNumericExpression2">
      Specifies the bit position in nExpression1 to clear. nExpression2 can range from 0 to 31 with 0 located as the bit to the farthest right.
    </param>
    <param name="BinaryExpression">
      Specifies a <b>Varbinary</b> or <b>Blob</b> expression.
    </param>
    <param name="nStartBit">
      Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.<br/>
      If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. 
      If you specify nStartBit only, the operation applies to nStartBit only.
    </param>
    <param name="nBitCount">
      Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.<br/>
      If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. 
      If you specify nStartBit only, the operation applies to nStartBit only.
    </param>
    <returns>
      <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BitClear( )</b> returns the specified expression without specified bit.
    </returns>
    <example>
       <code language="X#">
        x = 7  &amp;&amp; 0111 binary
        y = 1  &amp;&amp; 2nd bit position (0 = 1st bit position)
        ? BitClear(x,y) &amp;&amp; Returns 5, 0101 binary
      </code>
    </example>
  </bitclear>
  <bitlshift>
    <summary>
      Moves bits in a numeric value to the left by the specified number of positions and returns the resulting value.
      If the specified expressions are not integers, they are converted to integers before performing the operation.
    </summary>
    <param name="nExpression1">
      Specifies the numeric value in which to move bits to the left.
    </param>
    <param name="nExpression2">
      Specifies the number of bit positions to move to the left.
    </param>
    <returns>
      Numeric. <b>BitLShift( )</b> returns the specified expression with bits moved by the specified number of positions.
    </returns>
    <remarks>
      <b>BitLShift( )</b> does not support <b>Varbinary</b> values.
    </remarks>
    <example>
       <code language="X#">
        x = 5  &amp;&amp; 0101 binary
        y = 1  &amp;&amp; Shift bits 1 position left
        ? BitLShift(x,y) &amp;&amp; Returns 10, 1010 binary
      </code>
    </example>
  </bitlshift>
  <bitnot>
    <summary>
      Performs a bitwise NOT operation on a value of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the bitwise complement on the specified value. 
      There is a numeric and a binary version of the syntax.
      If the specified expression is not an integer, it is converted to an integer before performing the operation.
    </summary>
    <param name="nNumericExpression">
      Specifies a <b>Numeric</b> value to perform the bitwise NOT operation.
    </param>
    <param name="BinaryExpression">
      Specifies a <b>Varbinary</b> or <b>Blob</b> value to perform the bitwise NOT operation.
    </param>
    <param name="nStartBit">
      Specifies nStartBit as the starting zero-based number of the first bit to perform the operation 
      and nBitCount as the number of bits to perform the operation.<br/>
      If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. 
      If you specify nStartBit only, the operation applies to nStartBit only.
    </param>
    <param name="nBitCount">
      Specifies nStartBit as the starting zero-based number of the first bit to perform the operation and nBitCount as the number of bits to perform the operation.<br/>
      If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. If you specify nStartBit only, 
      the operation applies to nStartBit only.
    </param>
    <returns>
      <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BitNot( )</b> returns the bitwise complement of the specified expression. In other words, the return value represents the specified expression with each 0 bit changed to 1 and each 1 bit changed to 0.
    </returns>
    <example>
       <code language="X#">
        x = 5  &amp;&amp; 0101 binary
        ? BitNot(x) &amp;&amp; Returns -6
      </code>
    </example>
  </bitnot>
  <bitor>
    <summary>
      Perform a bitwise inclusive OR operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result. 
      There is a numeric and a binary version of the syntax.
    </summary>
    <param name="BinaryExpression1">
      Specifies Varbinary or Blob values to perform the bitwise AND operation.
    </param>
    <param name="BinaryExpression2">
      Specifies Varbinary or Blob values to perform the bitwise AND operation.
    </param>
    <returns>
      <b>Numeric</b> or <b>Varbinary</b>. <b>BitOr( )</b> returns the result of a bitwise inclusive OR operation on the specified expressions.<br/>
      For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value 
      up to the length of the longest value. The appropriate operation is then performed between those values.
    </returns>
    <remarks>
      <b>BitOr( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If either of the bits in eExpressionN and eExpressionN+1 is 1, 
      the corresponding result bit is set to 1; otherwise, the corresponding result bit is set to 0.<br/>
      The following table shows the result of an inclusive OR operation on corresponding eExpressionN and nExpressionN+1 bits:
      <list type="table">
        <listheader>
          <term>eExpressionN bit</term>
          <description>eExpressionN+1 bit</description>
          <description>Resulting bit</description>
        </listheader>
        <item>
          <term>0</term>
          <description>0</description>
          <description>0</description>
        </item>
        <item>
          <term>0</term>
          <description>1</description>
          <description>1</description>
        </item>
        <item>
          <term>1</term>
          <description>0</description>
          <description>1</description>
        </item>
        <item>
          <term>1</term>
          <description>1</description>
          <description>1</description>
        </item>
      </list>
    </remarks>
    <example>
       <code language="X#">
        x = 5  &amp;&amp; 0101 binary
        y = 6  &amp;&amp; 0110 binary
        ? BitOr(x,y) &amp;&amp; Returns 7, 0111 binary
      </code>
    </example>
  </bitor>
  <bitrshift>
    <summary>
      Moves bits in a numeric value to the right by the specified number of positions and returns the resulting value.
      If the specified expressions are not integers, they are converted to integers before performing the operation.
    </summary>
    <param name="nExpression1">
      Specifies the numeric value in which to move bits to the right.
    </param>
    <param name="nExpression2">
      Specifies the number of bit positions to move to the right.
    </param>
    <returns>
      Numeric. <b>BitRShift( )</b> returns the specified expression with bits moved by the specified number of positions.
    </returns>
    <remarks>
      <b>BitRShift( ) </b> does not support <b>Varbinary</b> values.
    </remarks>
    <example>
       <code language="X#">
        x = 5  &amp;&amp; 0101 binary
        y = 1  &amp;&amp; Shift bits 1 position right
        ? BitRShift(x,y) &amp;&amp; Returns 2, 0010 binary
      </code>
    </example>
  </bitrshift>
  <bitset>
    <summary>
      Sets a bit to 1 in a value of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the resulting value. 
      There is a numeric and a binary version of the syntax.<br/>
      If the specified expression is not an integer, it is converted to an integer before setting the bit.
    </summary>
    <param name="nNumericExpression1">
      Specifies a <b>Numeric</b> value to set the bit.
    </param>
    <param name="nNumericExpression2">
      Specifies the position of the bit in nExpression1 to set to 1. nExpression2 can range from 0 to 31 with 0 as the bit farthest to the right.
    </param>
    <param name="BinaryExpression">
      Specifies a <b>Varbinary</b> or <b>Blob</b> expression.
    </param>
    <param name="nStartBit">
      Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.<br/>
      If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. 
      If you specify nStartBit only, the operation applies to nStartBit only.
    </param>
    <param name="nBitCount">
      Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.<br/>
      If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. 
      If you specify nStartBit only, the operation applies to nStartBit only.
    </param>
    <returns>
      <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BitSet( )</b> returns the specified expression with the specified bit set to 1.
    </returns>
    <example>
       <code language="X#">
        x = 5  &amp;&amp; 0101 binary
        y = 1  &amp;&amp; 2nd bit position (0 = 1st bit position)
        ? BitSet(x,y) &amp;&amp; Returns 7, 0111 binary
      </code>
    </example>
  </bitset>
  <bittest>
    <summary>
      Determines whether a specific bit in a <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> value is set to 1. 
      There is a numeric and a binary version of the syntax.
      If the specified expression is not an integer, it is converted to an integer before performing the operation.
    </summary>
    <param name="nNumericExpression1">
      Specifies the <b>Numeric</b> value to check for the specified bit.
    </param>
    <param name="nNumericExpression2">
      Specifies the bit position in nExpression1 to check. nExpression2 can range from 0 to 31 with 0 as the bit farthest to the right.
    </param>
    <param name="BinaryExpression">
      Specifies a <b>Varbinary</b> or <b>Blob</b> expression to check for the specified bit.
    </param>
    <param name="nBitNumber">
      Specifies a zero-based bit in qExpression.
      If nBitNumber is out of range of qExpression, X# generates an error.
    </param>
    <returns>
      Logical. <b>BitTest( ) </b>returns True (.T.) if the specified bit is set to 1; otherwise, it returns False (.F.).
    </returns>
    <example>
       <code language="X#">
        CLEAR
        ? '2 even? '
        ?? IsEven(2)  &amp;&amp; Even, .T. returned
        ? '3 even? '
        ?? IsEven(3)  &amp;&amp; Not even, .F. returned
        ? '0 even? '
        ?? IsEven(0)  &amp;&amp; Even, .T. returned
        ? '-13 even? '
        ?? IsEven(-13)  &amp;&amp; Not even, .F. returned
        Function IsEven
        PARAMETER nInteger
        RETURN NOT BitTest(nInteger, 0)
      </code>
    </example>
  </bittest>
  <bitxor>
    <summary>
      Perform a bitwise exclusive OR operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result. 
      There is a numeric and a binary version of the syntax.
    </summary>
    <param name="BinaryExpression1">
      Specifies Varbinary or Blob values to perform the bitwise AND operation.
    </param>
    <param name="BinaryExpression2">
      Specifies Varbinary or Blob values to perform the bitwise AND operation.
    </param>
    <returns>
      <b>Numeric</b> or <b>Varbinary</b>. <b>BitXOR( )</b> returns the result of the bitwise exclusive OR operation performed on the specified expressions.<br/>
      For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value 
      up to the length of the longest value. The appropriate operation is then performed between those values.
    </returns>
    <remarks>
      <b>BitXOR( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If the bits in eExpressionN and eExpressionN+1 are the same, 
      the corresponding result bit is set to 0; otherwise, the corresponding result bit is set to 1.<br/>
      The following table shows the result of an exclusive OR operation on corresponding eExpressionN and eExpressionN+1 bits:
      <list type="table">
        <listheader>
          <term>eExpressionN bit</term>
          <description>eExpressionN+1 bit</description>
          <description>Result bit</description>
        </listheader>
        <item>
          <term>0</term>
          <description>0</description>
          <description>0</description>
        </item>
        <item>
          <term>0</term>
          <description>1</description>
          <description>1</description>
        </item>
        <item>
          <term>1</term>
          <description>0</description>
          <description>1</description>
        </item>
        <item>
          <term>1</term>
          <description>1</description>
          <description>0</description>
        </item>
      </list>
    </remarks>
    <example>
       <code language="X#">
        Var1 = 5  &amp;&amp; 0101 binary value
        Var2 = 6  &amp;&amp; 0110 binary value
        ? BitXOR(Var1,Var2) &amp;&amp; returns 3 (0011 binary value)
      </code>
    </example>
  </bitxor>
  <candidate>
    <summary>
      Returns true (.T.) if an index tag is a candidate index tag; otherwise, returns false (.F.).
    </summary>
    <param name="nIndexNumber">
      Specifies the number of the index tag for which Candidate( ) returns the candidate status.
    </param>
    <param name="uArea">
      Specifies the work area number or workarea alias of the index tag specified with nIndexNumber. <br/>
      If you omit this, Candidate( ) checks the index tag in the currently selected work area to see if it is a candidate index tag.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Candidate( ) returns the candidate status in the following order as nIndexNumber increases 
      from 1 to the total number of structural compound and independent compound index tags:<br/>
      Candidate status for each tag in the structural compound index (if one is present) is returned first. 
      The candidate status is returned for the tags in the order in which the tags are created in the structural index.<br/>
      Candidate status for each tag in any open independent compound indexes is returned last. 
      The candidate status is returned for the tags in the order in which the tags are created in the independent compound indexes.<br/>
      If you omit nIndexNumber, Candidate( ) checks the master controlling index tag to see if it is a candidate index tag. 
      If there is no master controlling index tag, Candidate( ) returns false (.F.).<br/><br/>
      A candidate index tag is an index tag that can become the primary index tag because it does not contain null or duplicate values.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer     &amp;&amp; Open customer table
        FOR nCount = 1 TO TAGCOUNT( )
        IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
        ? TAG(nCount)  &amp;&amp; Display tag name
        ? Candidate(nCount)  &amp;&amp; Display candidate status
        ELSE
        EXIT  &amp;&amp; Exit the loop when no more tags are found
        ENDIF
        ENDFOR
      </code>
    </example>
  </candidate>
  <capslock>
    <summary>
      Returns the current mode of the CAPS LOCK key or sets the CAPS LOCK key mode on or off.
    </summary>
    <param name="lExpression">
      Include to turn the CAPS LOCK key on or off. Capslock(.T.) turns CAPS LOCK on and Capslock(.F.) turns CAPS LOCK off. 
      A logical value is returned corresponding to the CAPS LOCK setting before Capslock(.T.) or Capslock(.F.) is issued.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Issuing Capslock( ) with no argument returns true (.T.) if CAPS LOCK is on, or false (.F.) if CAPS LOCK is off.
    </remarks>
    <example>
       <code language="X#">
        glOldLock = Capslock( )     &amp;&amp; Save original setting
        Capslock(.T.)     &amp;&amp; Turn CAPS LOCK on
        *** Perform any number of statements ***
        Capslock(glOldLock)  &amp;&amp; Return to original setting
        *** or, toggle CapsLock to the opposite value and back ***
        Capslock(!Capslock( ))
        WAIT WINDOW
        Capslock(!Capslock( ))
        WAIT WINDOW
        Capslock(glOldLock)  &amp;&amp; Return to original setting
      </code>
    </example>
  </capslock>
  <cdx>
    <summary>
      Returns the names of the open compound index (.cdx) file that has the specified index position number.
    </summary>
    <param name="nIndexNumber">
      The tables in Remarks apply to a table with a structural compound index and one or more compound indexes
    </param>
    <param name="uArea">
      Specifies the work area number or alias of a table whose open compound index file names you want CDX( ) to return.<br/>
      If you omit this, names of compound index files are returned for the table in the currently selected work area.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>nIndexNumber</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>1</term>
          <description>Returns the name of the structural index file (which is always the same as the name of the table).</description>
        </item>
        <item>
          <term>2</term>
          <description>Returns the first compound index file name specified in the INDEX clause of USE or in SET INDEX.</description>
        </item>
        <item>
          <term>3</term>
          <description>
            Returns the second compound index file name, if any, and so on.
          </description>
        </item>
        <item>
          <term>Greater than the number of open .cdx files</term>
          <description>
            Returns the empty string.
          </description>
        </item>
      </list>
      The following apply to a table with no structural compound index and one or more compound indexes:
      <list type="table">
        <listheader>
          <term>nIndexNumber</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>1</term>
          <description></description>
        </item>
        <item>
          <term>2</term>
          <description>Returns the first compound index file name specified in the INDEX clause of USE or in SET INDEX.</description>
        </item>
        <item>
          <term>Greater than the number of open .cdx files</term>
          <description>
            Returns the empty string.
          </description>
        </item>
      </list>
      The CDX( ) function is identical to the MDX( ) function.<br/>
      A .cdx (compound) index consists of one physical file containing many index tags. Each index tag is an index order reference for the associated table.<br/>
      There are two types of .cdx files: standard compound index (.cdx) and structural .cdx.
      A standard compound index (.cdx) may have a different name from its associated table and can reside in a different directory from its associated table. 
      A table can have multiple compound index files. You open a compound index with the INDEX clause of USE or with SET INDEX.<br/>
      A structural .cdx must have the same name as its associated table and reside in the same directory. A table can have only one structural index file. 
      Structural .cdx files are automatically opened and updated when the associated table is opened with USE.<br/>
      CDX( ) ignores any .idx (Microsoft FoxBASE+ and FoxPro 1.0 compatible index) files specified in USE or SET INDEX.<br/>
      Use TAG( ) to return individual tag names contained in a .cdx, and NDX( ) to return the name of open .idx files.<br/>
      When SET FULLPATH is ON, CDX( ) returns the path and name of the .cdx. When SET FULLPATH is OFF, CDX( ) returns the drive and name of the .cdx.
    </remarks>
    <example>
      <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer     &amp;&amp; Open customer table
        CLEAR
        FOR nCount = 1 TO TAGCOUNT( )
        IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
        ? CDX(nCount)     &amp;&amp; Display structural index names
        ELSE
        EXIT  &amp;&amp; Exit the loop when no more tags are found
        ENDIF
        ENDFOR
      </code>
    </example>
  </cdx>
  <ceiling>
    <summary>
      Returns the next highest integer that is greater than or equal to the specified numeric expression.
    </summary>
    <param name="nExpression">
      Specifies the number whose next highest integer <b>Ceiling( )</b> returns.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      <b>Ceiling</b> rounds a number with a fractional portion to the next highest integer.
    </remarks>
    <example>
       <code language="X#">
        STORE 10.1 TO num1
        STORE -10.9 TO num2
        ? Ceiling(num1)  &amp;&amp; Displays 11
        ? Ceiling(num2)  &amp;&amp; Displays -10
        ? Ceiling(10.0)  &amp;&amp; Displays 10
        ? Ceiling(-10.0) &amp;&amp; Displays -10
      </code>
    </example>
  </ceiling>
  <compobj>
    <summary>
      Compares the properties of two objects and returns True (.T.) if their properties and property values are identical.
    </summary>
    <param name="oExpression1">
      Specifies the objects to compare. oExpression1 and oExpression2 can be any expressions that evaluate to objects, 
      such as object references, object variables, or object array elements.
    </param>
    <param name="oExpression2">
      Specifies the objects to compare. oExpression1 and oExpression2 can be any expressions that evaluate to objects, 
      such as object references, object variables, or object array elements.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      CompObj( ) returns False (.F.) if an object has a property that the other object doesn't have, 
      or if the objects have identical properties but the values of one or more properties differ.
    </remarks>
    <example>
       <code language="X#">
        lstMyList1 = CREATEOBJ('ListBox')  &amp;&amp; Creates a ListBox
        lstMyList2 = CREATEOBJ('ListBox')  &amp;&amp; Creates a second ListBox
        cmbMyCombo = CREATEOBJ('ComboBox')  &amp;&amp; Creates a ComboBox
        lstMyList1.Name = 'list1'
        lstMyList2.Name = 'list2'
        CLEAR
        ? lstMyList1.Name  &amp;&amp; Displays List1 Name property
        ? lstMyList2.Name  &amp;&amp; Displays List2 Name property
        ? CompObj(lstMyList1, cmbMyCombo)     &amp;&amp; Displays .F.
        ? CompObj(lstMyList1, lstMyList2)     &amp;&amp; Displays .F., different Names
        lstMyList2.Name = lstMyList1.Name
        ? CompObj(lstMyList1, lstMyList2)     &amp;&amp; Displays .T., same properties
      </code>
    </example>
  </compobj>
  <cpconvert>
    <summary>
      Converts character or memo fields or character expressions to another code page.
    </summary>
    <param name="nCurrentCodePage">
      Specifies the code page that cExpression is being converted from.
    </param>
    <param name="nNewCodePage">
      Specifies the code page to which cExpression is converted.
    </param>
    <param name="cExpression">
      Specifies the character expression that's converted.
    </param>
    <remarks>
      Note that CPConvert( ) isn't required for normal cross-platform functioning of the product. 
      It is used strictly to access the underlying translation facilities of X#.
      For example, if the variable codegcCharExpr/code contains a character that looks like on the Macintosh (in code page 10000) 
      then CPConvert( ) will return a character that looks like  in Microsoft Windows (code page 1252):
       <code language="X#">CPConvert(10000, 1252, gcCharExpr)</code>
      For additional information on code pages and X#'s international support, see Code Pages Supported by X# and Developing International Applications.
    </remarks>
  </cpconvert>
  <cpcurrent>
    <summary>
      Returns the code page setting (if any) in your X# configuration file, or returns the current operating system code page.
    </summary>
    <remarks>
      CPCurrent([1 | 2])Remarks
      CPCurrent( ) returns one of the following:
      In X#, the current operating system code page if the CODEPAGE configuration item isn't included in your configuration file. 
      In previous versions of FoxPro, 0 is returned if the CODEPAGE configuration item isn't included in your configuration file.
      The code page number specified in the CODEPAGE configuration item. 
      For example, CPCurrent( ) returns 852 if the following line is included in your configuration file:
       <code language="X#">CODEPAGE = 852</code>
      The current operating system code page if you have included the following line in your configuration file:
       <code language="X#">CODEPAGE = AUTO</code>
      In X#, CPCurrent(1) returns the current operating system code page, regardless of your configuration CODEPAGE setting.
      CPCurrent(2) always returns the underlying operating system code page, regardless of your configuration CODEPAGE setting. 
      For example, if you're running Windows, CPCurrent(2) returns the MS-DOS code page.
      For additional information on code pages and X#'s international support, see Code Pages Supported by X# and Developing International Applications.
    </remarks>
  </cpcurrent>
  <cpdbf>
    <summary>
      Returns the code page with which an open table has been marked.
    </summary>
    <param name="uArea">
      Specifies the work area number or alias .
      Include this to specify a table open in a work area other than the current work area. 
      CpDbf( ) returns 0 if a table isn't open in the work area you specify. If a table doesn't have the alias you specify with cTableAlias, 
      X# generates an error message.
    </param>
    <remarks>
      DISPLAY STRUCTURE also displays the code page with which an open table has been marked.
      For additional information on code pages and X#'s international support, see Code Pages Supported by X# and Developing International Applications.
    </remarks>
  </cpdbf>
  <createobject>
    <summary>
      Creates an object from a class definition or an Automation-enabled application.
    </summary>
    <param name="cClassName">
      Specifies the class or OLE object from which the new object is created. X# searches for the class or OLE object in the following order:<br/>
      X# base classes<br/>
      Classes in the current program<br/>
      Classes in .vcx class libraries opened with SET CLASSLIB<br/>
      Classes in procedure files opened with SET PROCEDURE<br/>
      Classes in the X# program execution chain<br/>
      The OLE registry if SET OLEOBJECT is ON<br/>
      OLE objects are created using the following syntax for ClassName:<br/>
       <code language="X#">ApplicationName.Class</code>
      For example, to create a Microsoft Excel worksheet (which supports Automation), you can use the following syntax:<br/>
       <code language="X#">x = CreateObject('Excel.Sheet')</code>
      When this code is run, Microsoft Excel is started (if not already running), and a new worksheet is created.<br/>
      A class library can have an alias. To specify an object in a class library with an alias, 
      include the class library alias followed by a period and the object name.
      Note that ClassName cannot be the X# OLE Container control base class.
    </param>
    <returns>
      Object
    </returns>
    <remarks>
      eParameter1, eParameter2, ...<br/>
      These optional parameters are used to pass values to the Init event procedure for the class.<br/>
      The Init event is executed when you issue CreateObject( ) and allows you to initialize the object.<br/>
      Use CreateObject( ) to create an object from a class definition or an application that supports Automation, 
      and assign a reference to the object to a system variable or array element.<br/>
      Before you can create an object from a user-defined class, the user-defined class must first be created with DEFINE CLASS, 
      or it must be available in a .vcx visual class library opened with SET CLASSLIB.<br/>
      Use = or STORE to assign a reference to the object to a system variable or array element. 
      If an object assigned to a system variable or array element is released, the system variable or array element contains the null value. 
      Use RELEASE to remove the system variable or array element from memory.<br/>
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        * Verify current class library setting
        cCurClassLib=SET("CLASSLIB")
        IF LEN(ALLTRIM(cCurClassLib))=0
        cCurClassLib="None"
        ENDIF
        WAIT WINDOW "Current class library is: " + cCurClassLib + CHR(13);
        + "Press any key to continue..."
        frmMyForm = CreateObject("FormGrandChild")
        * Create an array
        FOR nCount = 1 TO AClass(gaNewarray, frmMyForm)
        ? gaNewarray(nCount)  &amp;&amp; Display the names of the classes
        ENDFOR
        RELEASE frmMyForm
        * Create FormChild from FORM baseclass
        DEFINE CLASS FormChild AS FORM
        ENDDEFINE
        * Create FormGrandChild from user-defined FormChild class
        DEFINE CLASS FormGrandChild AS FormChild
        ENDDEFINE
      </code>
    </example>
  </createobject>
  <createobjectex>
    <summary>
      Creates an instance of a registered COM object (such as a X# Automation server) on a remote computer.
    </summary>
    <param name="cComputerName">
      Specifies the remote computer on which the COM object is instantiated.<br/>
      If cComputerName is the empty string, the COM object is instantiated on the local computer or a redirected machine as specified in the registry.<br/>
      cComputerName supports Universal Naming Convention (UNC) names such as "\\myserver" and "myserver," and Domain System Names (DNS) names.
    </param>
    <param name="cIID">
      Specifies the Interface ID GUID of cCLSID | cPROGID when you create an early bound instance of the class. 
      If you pass an empty string as cIID X# attempts to access the default interface (IID) of cCLSID | cPROGID.
    </param>
    <returns>
      Object
    </returns>
    <remarks>
      CreateObjectEx( ) returns an object reference to the COM object if it is successfully instantiated. 
      CreateObjectEx( ) cannot be used to instantiate X# classes such as forms – use CreateObject( ) to instantiate X# classes. 
      Note that you can only abbreviate CreateObjectEx( ) to a minimum of 13 characters, distinguishing it from the CreateObject( ) function.<br/>
      When you call certain COM classes with CreateObject( ) they return "No such interface supported" because they do not support an IDispatch interface. 
      Using the cIID parameter you can now access these classes in your applications.<br/><br/>
      If you pass an empty string ("") as cIID X# attempts to to get the default interface (IID) of the specified CLSID or PROGID.<br/>
      Because it supports early binding through cIID, CreateObjectEx( ) can help improve performance by avoiding much of the overhead of IDispatch calls.<br/>
      CreateObjectEx( ) supports creation of new early-bound objects. 
      However, it is also possible that your X# component is passed an object that you want to call via early-binding. 
      You can use the GETINTERFACE( ) support on existing COM objects.<br/><br/>
      For additional information about using X# to create Automation servers, see Sharing Information and Adding OLE.<br/>
    </remarks>
    <example>
       <code language="X#">
        x = CreateObjectEx("excel.application","",;
        "{000208D5-0000-0000-C000-000000000046}")
      </code>
      The following is a valid function call for an excel application object. It will return the excel.application default interface.
       <code language="X#">      x = CreateObjectEx("excel.application","","")</code>
    </example>
  </createobjectex>
  <createoffline>
    <summary>
      Takes an existing view offline.
    </summary>
    <param name="ViewName">

      Specifies the name of the existing view to take offline. The database containing the existing view must be open before you can take the existing view offline.

    </param>
    <param name="cPath">

      Specifies the directory in which the offline view is placed and the name of the offline view.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      CREATEOFFLINE( ) returns a logical true (.T.) if the existing view is successfully taken offline; otherwise false (.F.) is returned.
      An offline view is opened with USE. When an offline view is open, you can append records or make changes to records in the offline view. However, you cannot use the CREATE TRIGGER, INSERT, PACK or ZAP commands in an offline view. After making changes to the offline view, you can update the data on the server with your changes by opening the offline view with USE and including the ONLINE clause.
      You cannot refresh the contents of an offline view with data from the server until the offline view has been opened with USE and the ONLINE clause.
      Use DROPOFFLINE( ) to take the offline view back online.
    </remarks>
  </createoffline>
  <ctobin>
    <summary>
      Converts a binary character representation to a numeric value.
    </summary>
    <param name="cExpression">

      Specifies the binary character representation to convert.

    </param>
    <param name="cFlags">

      If the binary character representation specified with cExpression was generated using an 8 byte data type (currency or double, for example), include cFlags to control the type of value returned by CTOBIN( ).

    </param>
    <returns>
      Numeric. <b>CTOBIN( )</b> returns a numeric value from a binary character expression.
    </returns>
    <remarks>
      cFlags:
      <list type="table">
        <listheader>
          <term>cFlags</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>1</term>
          <description>cExpression is an expression that is 1 byte long.</description>
        </item>
        <item>
          <term>2</term>
          <description>cExpression is an expression that is 2 bytes long.</description>
        </item>
        <item>
          <term>4</term>
          <description>cExpression is an expression that is 4 bytes long.</description>
        </item>
        <item>
          <term>8</term>
          <description>cExpression is an expression that is 8 bytes long.</description>
        </item>
        <item>
          <term>B</term>
          <description>
            cExpression is a double data type, and must be 8 bytes long.<br/>
            CTOBIN( ) returns a double data type value. This is the default for an expression that is 8 bytes long.
          </description>
        </item>
        <item>
          <term>N</term>
          <description>
            cExpression is a numeric data type, and must be 4 or 8 bytes long.<br/>
            CTOBIN( ) returns a numeric type value.
          </description>
        </item>
        <item>
          <term>Y</term>
          <description>
            cExpression is a currency data type, and must be 8 bytes long.<br/>
            CTOBIN( ) returns a currency type value.
          </description>
        </item>
        <item>
          <term>R</term>
          <description>Reverses the binary expression.</description>
        </item>
        <item>
          <term>S</term>
          <description>Prevents the sign bit of number from being toggled (BitXOR).</description>
        </item>
      </list>

      The cFlags parameter is a character expression. The 'R' and 'S' settings are additive while the others are mutually exclusive. Character settings can be passed in either upper or lower case (e.g., 'R' or 'r'). Specifying a value of '1', '2' or '4' is not required, but is available as a convenience to provide feedback for the length of cExpression.<br/>
      The following examples show various uses of the cFlags parameter.
       <code language="X#">
        ? CTOBIN("A")&amp;&amp; same as CTOBIN("A","1")
        ? CTOBIN(BinToc($12.34,"8"),"Y")
        ? CTOBIN(BinToc(12.34,"8"),"B")
        ? CTOBIN(BinToc(PI(),"BR"),"NRS")
      </code>
      You can use CTOBIN( ) to convert a binary character representation created with BinToc( ) to its integer value. CTOBIN( ) can also be used when working with Win32 API routines where you might need to convert to or from a Win32 struct member. The 'R' and 'S' settings allow you to use CTOBIN ( ) to work more efficiently with these scenarios.
    </remarks>
  </ctobin>
  <ctot>
    <summary>
      Returns a DateTime value from a character expression.
    </summary>
    <param name="cCharacterExpression">

      Specifies the character expression from which a DateTime value is returned.
    </param>
    <returns>
      DateTime data type. CTOT( ) returns a DateTime value from a character expression.
    </returns>
    <remarks>
      <note>CTOT() can create ambiguous DateTime values and generates a compilation error when SET STRICTDATE is set to 2. To create nonambiguous Date values, use the DATETIME( ) function instead.</note>
      X# supports the native SQL Datatypes Datetime and Smalldatetime, which are returned in 24 hour format in SQL XML.
      <note>The CTOT() function does not address the 19 different ways that T-SQL Convert() function returns datetime and smalldatetime values.</note>
      To convert date formats from Access, SQL Server, Visual Studio, and XML, you must call the appropriate SET DATE setting to interpret DateTime strings properly. However, if an uppercase T is in the XML date string, X# overrides the current date setting by internally calling SET DATE YMD and restores the current date setting when exiting CTOT( ).
      <note>CTOT( ) resolves these dates to the limits of precision of the X# DateTime data type. Therefore, precision can be lost when using CTOT( ) with certain formats. The X# DateTime data type does not support milliseconds or time zones.</note>
      CTOT( ) respects the setting of the SET CENTURY command. For more information, see SET CENTURY Command.<br/><br/>
      The following examples show how CTOT( ) handles DateTime values from different sources. In all examples, CTOT( ) converts the DateTime values correctly without needing to call SET DATE YMD.
      Access 2000 XML date format
       <code language="X#">
        * 2000-10-24T13:30:00 (24-hour format is exported from Access,
        * whether original was in 12- or 24-hour format)
        ? CTOT("2000-10-24T13:30:00")
      </code>
      SQL Server 2000 XML date format
       <code language="X#">
        ? CTOT("2000-10-24T20:47:58.170")   &amp;&amp; datetime (24-hour format)
        ? CTOT("2000-10-24T21:11:00")         &amp;&amp; Small DT (24-hour format)
        ? CTOT("2000-10-03T02:02:02")
      </code>
      Visual Studio XML
       <code language="X#">? CTOT("2002-10-05T04:04:04.0000000-07:00")</code>
      Simple Object Access Protocol (SOAP)
       <code language="X#">? CTOT("2001-09-14T07:00:00Z")</code>
    </remarks>
  </ctot>
  <cursorgetprop>
    <summary>
      Retrieves the current property settings for a X# table or a cursor.
      <note name="tip">
        To set a specific property for a X# table or a cursor, use <b>CursorGetProp( )</b>.
        For additional information about each of the properties and their settings, see CursorGetProp( ) Function.
      </note>
    </summary>
    <param name="cProperty">
      Specifies the property setting to retrieve. See the table in the remarks section for possible properties.
    </param>
    <param name="uArea">
      Specifies the work area number or the alias of the table or cursor from which the property setting is returned. 
      If you specify 0 for uArea, <b>CursorGetProp( )</b> returns the environment setting.
    </param>
    <returns>
      Character, Numeric, or Logical data type
    </returns>
    <remarks>
      The current property settings are returned for the table or cursor open in the currently selected work area if <b>CursorSetProp( )</b>
      is issued without the optional uArea argument. If you use CursorGetProp( ) without a table selected, a cursor open,
      or an alias specified, you get Error 52 (No table is open in current work area.) unless a work area is specified as in this example,
      CursorSetProp("Refresh",-2,0).<br/><br/>
      The following table includes a list of properties whose settings can be returned, the data type of the return value,
      and a description of the return value.
      <list type="table">
        <listheader>
          <term>cProperty</term>
          <description>Type</description>
          <description>Description</description>
        </listheader>
        <item>
          <term>ADOBookmark</term>
          <description>Variant</description>
          <description>Contains a value that corresponds to an ADO Bookmark for the current record in an ADO-based cursor.</description>
        </item>
        <item>
          <term>ADOCodePage</term>
          <description>N</description>
          <description>Returns the code page bound to an ADO-based cursor as specified by the ADOCodePage Property. Read-only.</description>
        </item>
        <item>
          <term>ADORecordset</term>
          <description>O</description>
          <description>Contains an object reference to the ActiveX Data Object (ADO) Recordset associated with the cursor. 
          Not valid for cursors that are not based on ADO Recordsets. Read-only.</description>
        </item>
        <item>
          <term>AllowSimultaneousFetch</term>
          <description>L</description>
          <description>
            Applies when using remote views, a shared connection, and to cursors created using ODBC.<br/>
            AllowSimultaneousFetch contains True (.T.) when similarly configured cursors sharing the connection 
            are permitted to fetch rows simultaneously.<br/>
            Otherwise, AllowSimultaneousFetch contains False (.F.) when fetching rows simultaneously is not permitted.
          </description>
        </item>
        <item>
          <term>AutoIncError</term>
          <description>L</description>
          <description>
            Contains True (.T.) when attempts to insert or update a value in a field that uses automatically 
            incrementing field values generate an error message.<br/>
            Contains False (.F.) when attempts to insert or update a value in a field that uses automatically
            incrementing field values does not generate an error message and the specified value to be inserted or updated is disregarded.<br/>
            Applies to cursors and sessions.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>BatchUpdateCount</term>
          <description>N</description>
          <description>
            Contains the number of update statements sent to the remote data source for buffered tables. The default value is 1. Adjusting this value can greatly increase update performance.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>Buffering</term>
          <description>N</description>
          <description>
            1 – Row and table buffering is off. (Default)<br/>
            2 – Pessimistic row buffering is on.<br/>
            3 – Optimistic row buffering is on.<br/>
            4 – Pessimistic table buffering is on.<br/>
            5 – Optimistic table buffering is on.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>CompareMemo</term>
          <description>L</description>
          <description>
            Contains True (.T.) if WHERE clause for updates includes memo fields of type Memo, General, or Picture. (Default).<br/>
            Otherwise, contains False (.F.).<br/>
            For views only.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>ConnectHandle</term>
          <description>N</description>
          <description>
            The connection handle. This property is valid only when the data source contains a remote table. 
            The connection handle obtained for a view might close when the view closes.<br/>
            Read-only.
          </description>
        </item>
        <item>
          <term>ConnectName</term>
          <description>C</description>
          <description>
            The connection name used when the cursor is created. This property is valid only when the data source contains a remote table.<br/>
            Read-only.
          </description>
        </item>
        <item>
          <term>Database</term>
          <description>C</description>
          <description>
            The name of the database that contains the table or view. If a table is a free table, Database contains an empty string.<br/>
            Read-only.
          </description>
        </item>
        <item>
          <term>FetchAsNeeded</term>
          <description>L</description>
          <description>
            If True (.T.), data is fetched only when needed, such as when record pointer moves to a row that has not been fetched.<br/>
            If False (.F.), additional data is fetched during idle time. (Default)
            <note>FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).</note>
            Read/write.
          </description>
        </item>
        <item>
          <term>FetchIsComplete</term>
          <description>L</description>
          <description>
            If True (.T.), the fetch process is complete for an ODBC or ADO-based cursor.<br/>
            If False (.F.), the fetch process has not been completed.<br/>
            This option is not supported for tables and local views or on the environment level (work area 0).
          </description>
        </item>
        <item>
          <term>FetchMemo*</term>
          <description>L</description>
          <description>
            Contains True (.T.) if memo fields are fetched with the view results. Otherwise, contains False (.F.). (Default).<br/>
            Use the ISMEMOFETCHED( ) Function to determine if the memo field has been fetched.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>FetchSize*</term>
          <description>N</description>
          <description>
            Contains the number of rows fetched at a time from the remote tables. 
            The default is 100 rows. Setting FetchSize to –1 retrieves the complete result set, limited by the MaxRecords setting.
            <note>Progressive fetching holds the connection until all rows are retrieved. 
            Use caution coding with FetchSize if ShareConnection is True (.T.).</note>
            Read/write.
          </description>
        </item>
        <item>
          <term>KeyFieldList</term>
          <description>C</description>
          <description>
            A comma delimited list of primary fields for the cursor.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>MapBinary</term>
          <description>L</description>
          <description>
            Contains True (.T.) if Varbinary mapping is turned on. Otherwise, contains (.F.).<br/>
            Read/write for nWorkArea set to 0 only. Read-only for SQL Pass-Through cursors. Invalid for table cursors (nWorkArea equal to or greater than 1).
          </description>
        </item>
        <item>
          <term>MapVarchar</term>
          <description>L</description>
          <description>
            Contains True (.T.) if Varchar mapping is turned on. Otherwise, contains False (.F.).<br/>
            Read/write for nWorkArea set to 0 only. Read-only for SQL Pass-Through cursors. Invalid for table cursors (nWorkArea equal to or greater than 1).
          </description>
        </item>
        <item>
          <term>MaxRecords*</term>
          <description>N</description>
          <description>
            The maximum number of rows fetched when result sets are returned. The default value is – 1 (all rows are returned). A value of 0 specifies that the view is executed but no results are fetched.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>ParameterList</term>
          <description>C</description>
          <description>
            A semi-colon delimited list of view parameters and parameter types. For views only.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>Prepared</term>
          <description>L</description>
          <description>
            Contains True (.T.) if SQL statements are prepared for subsequent REQUERY( ) function calls. Otherwise, contains False (.F.). (Default).<br/>
            REQUERY( ) is used to retrieve data again for a SQL view. See SQLPREPARE( ) for additional information about preparing SQL statements. For views only.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>RecordsFetched</term>
          <description>N</description>
          <description>
            Contains a numeric value that indicates the number of records fetched from the data source for an ODBC or ADO-based cursor.<br/>
            This numeric value may not reflect the current record count for the cursor if records were locally deleted or appended.<br/>
            This option is not supported for tables and local views or on the environment level (work area 0).<br/>
            <note>Any filter conditions are ignored in the record count.</note>
            Read-only.
          </description>
        </item>
        <item>
          <term>Refresh</term>
          <description>N</description>
          <description>
            Contains a numeric value that indicates the refresh setting for an individual cursor in the current data session or an initial refresh value for newly opened cursors in the current data session.
          </description>
        </item>
        <item>
          <term>SendUpdates</term>
          <description>L</description>
          <description>
            Contains True (.T.) if a SQL update query is sent to update tables when an update is made using the view; otherwise, contains false (.F.) (default).<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>SourceName</term>
          <description>N</description>
          <description>
            1 – The data source is a local SQL view.<br/>
            101 (1 + 100) - Cursor is created by the CursorFill method.<br/>
            201 (1 + 200) - Cursor is attached to a CursorAdapter object using the CursorAttach method.<br/>
            2 – The data source is a remote SQL view.<br/>
            102 (2 + 100) - Cursor is created by CursorFill.<br/>
            202 (2 + 200) - Cursor is attached to a CursorAdapter object using CursorAttach.<br/>
            3 – The data source is a table.<br/>
            103 (3 + 100) - Cursor is created by CursorFill.<br/>
            203 (3 + 200) - Cursor is attached to a CursorAdapter object using CursorAttach.<br/>
            4 - The cursor is based on ADO Recordset and attached to a CursorAdapter object.<br/>
            104 (4 + 100) - Cursor is created by CursorFill.<br/>
            204 (4 + 200) - Cursor is attached to a CursorAdapter object using CursorAttach.<br/>
            Read-only.
          </description>
        </item>
        <item>
          <term>SQL</term>
          <description>C</description>
          <description>
            The SQL statement executed when the cursor is created.<br/>
            Read-only.
          </description>
        </item>
        <item>
          <term>Tables</term>
          <description>C</description>
          <description>
            A comma delimited list of the names of tables.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>UpdatableFieldList</term>
          <description>C</description>
          <description>
            A comma delimited list of fields in the view. This list can include fields from local and remote tables.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>UpdateNameList</term>
          <description>C</description>
          <description>
            A comma delimited list of remote field names and the local field names assigned to the cursor. Use this option to specify valid Visual FoxPro names for fields in the cursor that have invalid Visual FoxPro field names.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>UpdateType</term>
          <description>N</description>
          <description>
            1 – Specifies that old data is updated with the new data. (Default).<br/>
            2 – Specifies that updates occur by deleting the old data and inserting the new data.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>UseMemoSize*</term>
          <description>N</description>
          <description>
            The minimum size, in bytes, for result columns to return in memo fields. For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field. UseMemoSize may vary from 1 to 255; the default value is 255.<br/>
            Read/write.
          </description>
        </item>
        <item>
          <term>WhereType</term>
          <description>N</description>
          <description>
            The WHERE clause for updates to tables. WhereType can specify the following values:<br/>
            1 or DB_KEY (from FOXPRO.H). The WHERE clause used to update tables consists of only the primary fields specified with the KeyFieldList property.<br/>
            2 or DB_KEYANDUPDATABLE (from FOXPRO.H). The WHERE clause used to update tables consists of the primary fields specified with the KeyFieldList property and any updatable fields.<br/>
            3 or DB_KEYANDMODIFIED (from FOXPRO.H) (default). The WHERE clause used to update tables consists of the primary fields specified with the KeyFieldList property and any other fields that are modified.<br/>
            4 or DB_KEYANDTIMESTAMP (from FOXPRO.H). The WHERE clause used to update tables consists of the primary fields specified with the KeyFieldList property and a comparison of the time stamps.<br/>
            Read/write.
          </description>
        </item>
      </list>

      * The value returned by this property is significant only for remote views; if you get this property for local views, the <b>CURSORGETPROP( )</b> function returns the default value.
    </remarks>
    <example>
      When a cursor is opened, the default value for the AutoIncError property is read from the session default value, which is the current default data session setting. The following example shows how you can retrieve the default AutoIncError value for each session by specifying 0 (default session) as the last parameter:
       <code language="X#">CURSORGETPROP("AutoIncError", 0) </code>
      The default session is used when opening a new private data session or cursor. The following example shows how you can retrieve the cursor or table AutoIncError setting for each table by using the nWorkArea or cTableAlias parameter as the last parameter:
       <code language="X#">CURSORGETPROP("AutoIncError", nWorkArea | cTableAlias)</code>
      The following example opens a "Customer" table in the "Testdata" database and uses <b>CURSORGETPROP( )</b> to display the buffering mode for the table and the name of the database in which the table is contained:
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer     &amp;&amp; Open customer table
        ? CURSORGETPROP("Buffering") &amp;&amp; Displays buffering mode
        ? CURSORGETPROP("Database")  &amp;&amp; Displays database name
      </code>
    </example>
  </cursorgetprop>
  <cursorsetprop>
    <summary>
      Specifies property settings for a X# table or a cursor.
    </summary>
    <param name="cProperty">

      Specifies the table or cursor property to set. Buffering is the only property you can specify for a X# table.

    </param>
    <param name="eExpression">

      Specifies the value for the property you specify with cProperty. If you omit eExpression, the property is set to its default value.
      The following table lists the properties you can specify for cProperty and a description of the values eExpression can assume.
      eExpression values
      AllowSimultaneousFetch
      Applies when using remote views, a shared connection, and to cursors created using ODBC.
      .T. - Permit similarly configured cursors sharing the connection to fetch rows simultaneously.
      .F. - Do not permit similarly configured cursors sharing the connection to fetch rows simultaneously.
      AutoIncError
      .T. - Generate an error message when attempting to insert or update values in a field that uses automatically incrementing field values.
      .F. - Does not generate an error message but does not use the value specified when attempting to insert or update the value in a field that uses automatically incrementing field values, which uses the appropriate incremented value.
      Applies to cursors and sessions.
      BatchUpdateCount*
      Specifies the number of update statements to send to the remote data source for buffered tables. The default value is 1. Adjusting this value can greatly increase update performance when using automatic updating.
      Buffering
      1 – Sets row and table buffering off. Record locking and data writing are identical to earlier FoxPro versions. (Default)
      2 – Sets pessimistic row buffering on.
      3 – Sets optimistic row buffering on.
      4 – Sets pessimistic table buffering on.
      5 – Sets optimistic table buffering on. <b>SET MULTILOCKS</b> must be <b>ON</b> for all Buffering modes except 1 (off).
      CompareMemo
      .T. - Include memo fields of type Memo, General, or Picture in the <b>WHERE</b> clause for updates.
      .F. – Do not include memo fields in the WHERE clause for updates.
      Applies when automatic updating is used.
      FetchAsNeeded
      .T. – Fetch records only when needed, such as when record pointer moves to a row that has not been fetched.
      .F. – Fetch additional data during idle time.
      FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).
      FetchMemo*
      .T. – Fetch memo fields with the view results.
      .F. – Do not fetch memo fields with the view results.
      FetchSize*
      Specifies the number of rows progressively fetched from the remote table result set. The default value is 100 rows. Setting FetchSize to –1 retrieves the complete result set, limited by the MaxRecords setting.
      Progressive fetching holds the connection until all rows are retrieved. Use caution coding with FetchSize if ShareConnection is True (.T.).
      KeyFieldList
      Specifies a comma-delimited list of primary fields for the cursor. No default. You must include a list of field names for updates to work when using automatic updating.
      MapBinary
      .T. - At the session level, SQL Pass-Through maps SQL_BINARY, SQL_VARBINARY, and SQL_LONGVARBINARY ODBC types to <b>Varbinary</b> or <b>Blob</b> data type.
      For remote views, the <b>CREATE SQL VIEW</b> command maps the SQL_LONGVARBINARY ODBC data source type to <b>Blob</b> type, and it maps SQL_BINARY and SQL_VARBINARY ODBC data source types to <b>Varbinary</b> type when the precision of the corresponding column in the data source is less than or equal to 254 bytes. When precision is greater than 254 bytes, these types map to <b>Blob</b> type.
      .F. - SQL Pass-Through maps SQL_BINARY and SQL_VARBINARY ODBC types to <b>Character</b> type. (Default)
      For remote views, the <b>CREATE SQL VIEW</b> command maps SQL_BINARY and SQL_VARBINARY ODBC data source types to <b>Memo</b> type.
      <b>MapBinary</b> is read/write for nWorkArea set to 0, read-only for SQL Pass-Through cursors, and invalid for table cursors (nWorkArea equal to or greater than 1).
      MapVarchar
      .T. - At the session level, SQL Pass-Through maps SQL_WVARCHAR and SQL_VARCHAR ODBC types to <b>Varchar</b> type.
      For remote views, <b>CREATE SQL VIEW</b> command maps SQL_WVARCHAR and SQL_VARCHAR ODBC data source types to <b>Varchar</b> type.
      .F. - SQL Pass-Through maps SQL_WVARCHAR and SQL_VARCHAR ODBC types to <b>Character</b> type. (Default)
      For remote views, <b>CREATE SQL VIEW</b> command maps SQL_WVARCHAR and SQL_VARCHAR ODBC data source types to <b>Character</b> type.
      <b>MapVarchar</b> is read/write for nWorkArea set to 0, read-only for SQL Pass-Through cursors, and invalid for table cursors (nWorkArea equal to or greater than 1).
      MaxRecords*
      Specifies the maximum number of rows fetched when returning result sets. The default value is – 1, and all rows are returned. A value of 0 specifies that the view is executed but no results are fetched.
      ParameterList
      Specifies a semi-colon delimited list of view parameters and parameter types. For views only.
      Prepared
      .T. - Prepare SQL statements for subsequent <b>REQUERY( )</b> function calls.
      .F. - Do not prepare SQL statements for subsequent <b>REQUERY( )</b> calls. (Default).
      <b>REQUERY( )</b> is used to retrieve data again for a SQL view. For additional information about preparing SQL statements, see SQLPREPARE( ) Function.
      Refresh
      Specifies a numeric refresh value for an individual cursor in the current data session or an initial refresh value for newly opened cursors in the current data session.
      Use the SET DATASESSION Command to select a specific data session, and use the cTableAlias or nWorkArea parameter to specify a specific cursor. Use nWorkArea = 0 to change the initial refresh value for all newly opened cursors. Any cursors that are already open will not be affected by the new refresh setting.
      SET REFRESH Command allows you to specify a global refresh value. By default, the CURSORSETPROP( ) Refresh setting is -2, which indicates that the current global SET REFRESH value is used. The global SET REFRESH value is specified with its second parameter, nSeconds2.
      You can set the CURSORSETPROP( ) Refresh setting to the same values as the nSeconds2 parameter in SET REFRESH.
      <b>Note</b>   The  CURSORSETPROP( ) Refresh setting will be ignored if the nSeconds2 parameter is currently set to zero in the SET REFRESH command.
      SendUpdates
      .T. – Specifies that a SQL update query is sent to update tables when an update is made using the view.
      .F. – Specifies that a SQL update query is not sent to update tables.
      Tables
      Specifies a comma-delimited list of the names of remote tables. No default. You must include a list of table names for updates to work when using automatic updating.
      UpdatableFieldList
      Specifies a comma-delimited list of fields in the view. This list can include fields from local and remote tables. You must include a list of fields for updates to work when using automatic updating.
      UpdateNameList
      Specifies a comma-delimited list of remote field names and the local field names assigned to the cursor. Use this option to specify valid X# names for fields in the cursor that have invalid X# field names.
      UpdateType
      1 – Update old data with new data. (Default)
      2 – Update by deleting old data and inserting new data.
      UseMemoSize*
      Specifies the minimum size in bytes for result columns to return in memo fields. For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field. UseMemoSize can vary from 1 to 255 bytes. The default value is 255 bytes.
      WhereType
      The <b>WHERE</b> clause for updates to remote tables. WhereType can assume the following values:
      1 or <b>DB_KEY</b> (from FOXPRO.H). The WHERE clause used to update remote tables consists of only the primary fields specified with the KeyFieldList property.
      2 or <b>DB_KEYANDUPDATABLE</b> (from FOXPRO.H). The WHERE clause used to update remote tables consists of the primary fields specified with the KeyFieldList property and any updatable fields.
      3 or <b>DB_KEYANDMODIFIED</b> (from FOXPRO.H). The WHERE clause used to update remote tables consists of the primary fields specified with the KeyFieldList property and any other fields that are modified. (Default)
      4 or <b>DB_KEYANDTIMESTAMP</b> (from FOXPRO.H). The <b>WHERE</b> clause used to update remote tables consists of the primary fields specified with the KeyFieldList property and a comparison of the time stamps.
      * This property is primarily used for remote views; setting it has no effect on local views. However, you can preset this property for local views that will be upsized.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table or cursor for which the property is set.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor for which the property is set. If you specify 0 for nWorkArea, <b>CURSORSETPROP( )</b> sets the environment setting used for all subsequent tables or cursors.
      Buffering is not applied to tables that are opened implicitly, for example, using SQL INSERT/UPDATE/DELETE commands.
    </param>
    <returns>
      Logical data type. <b>CURSORSETPROP( )</b> returns True (.T.) if X# successfully sets the property you specify. X# generates an error if the property you specify cannot be set.
    </returns>
    <remarks>
      The setting of the Buffering property for <b>CURSORSETPROP( )</b> determines how X# performs record locking and update buffering. For additional information about record locking and update buffering, see How to: Buffer Data.
      The setting of the WhereType property for <b>CURSORSETPROP( )</b> determines how updates are performed on remote tables. For additional information about remote table updates, see Developing Databases.
      You can use <b>CURSORSETPROP( )</b> to override the FetchSize property in the <b>SQLSETPROP( )</b> function for a cursor. This property is inherited from the cursor's connection handle by default.
      Use <b>CURSORGETPROP( )</b> to return the current property settings for a X# table or a cursor created for a table.
      If <b>CURSORSETPROP( )</b> is issued without the optional cTableAlias or nWorkArea arguments, the property setting is specified for the open table or cursor in the currently selected work area.
    </remarks>
    <example>
      When a cursor is opened, the default value for the AutoIncError property is read from the session default value, which is the current default data session setting. The following example shows how you can set the default AutoIncError value for each session by specifying 0 (default session) as the last parameter:
       <code language="X#">CURSORSETPROP("AutoIncError", .T., 0) </code>
      The default session is used when opening a new private data session or cursor. The following example shows how you can set the cursor or table AutoIncError setting for each table by using the cTableAlias or nWorkArea parameter as the last parameter:
       <code language="X#">CURSORSETPROP("AutoIncError", .F. , cTableAlias | nWorkArea )</code>
      The following example demonstrates how you can enable optimistic table buffering with <b>CURSORSETPROP( )</b>. <b>MULTILOCKS</b> is set to <b>ON</b>, a requirement for table buffering. The "Customer" table in the "testdata" database is opened, and <b>CURSORSETPROP( )</b> is used to set the buffering mode to optimistic table buffering (5). A message box is displayed showing the result of the operation.
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        SET MULTILOCKS ON
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE Customer     &amp;&amp; Open Customer table.
        * Set buffering mode and store logical result
        lSuccess=CURSORSETPROP("Buffering", 5, "Customer")
        IF lSuccess = .T.
        =MESSAGEBOX("Operation successful!",0,"Operation Status")
        ELSE
        =MESSAGEBOX("Operation NOT successful!",0,"Operation Status")
        ENDIF
      </code>
    </example>
  </cursorsetprop>
  <cursortoxml>
    <summary>
      Converts a X# cursor to XML.
    </summary>
    <param name="uArea">

      Specifies the work area number or alias of the table from which to create the XML string.
      If you specify 0 or no value, X# uses the current work area.

    </param>
    <param name="cOutput">

      Specifies the path and file name or memory variable name to which results are sent.
      If nFlags is set to 0 (default) for memory variable output, XML is returned to the memory variable. If the memory variable does not exist, it is created.
      If nFlags is set to 512 for file output, and the file does not exist, it is created. If the file already exists, it is overwritten. The setting for <b>SET SAFETY</b> is observed.

    </param>
    <param name="nOutputFormat">

      Specifies the output format of the XML string. The following table lists the values for nOutputFormat.
      nOuputFormat
      1 – ELEMENTS
      (Default) Element-centric XML
      2 – ATTRIBUTES
      Attribute-centric XML
      3 – RAW
      Generic, attribute-centric XML

    </param>
    <param name="nFlags">

      Specifies the formatting of the XML that is produced and its destination. The following table lists the values for nFlags.
      0
      0000
      (Default) Produce XML in UTF-8 format.
      This setting creates a memory variable if one does not exist when specified by cOutput and returns XML to the memory variable.
      The XML declaration does not contain an Encoding= attribute; that is, no encoding attribute is set to UTF-8.
      1
      0001
      Produce unformatted XML as a continuous string.
      2
      0010
      Enclose empty elements with open and closing elements, for example, &lt;cc04&gt;&lt;cc04/&gt;.
      0100
      Preserve white space in fields.
      1000
      Wrap Memo fields in CDATA sections.
      16
      10000
      Output encoding. Output is set to the cursor code page.
      To ensure accurate character translation, the X# default code page must match the code page of the cursor. You can accomplish this by setting character and memo fields in the cursor to <b>NOCPTRAN</b> (character binary/memo binary).
      When setting this value with tables using any of the code pages, the encoding attribute in the XML is set to an empty string (""). To change to the correct encoding attribute, use the STRTRAN( ) function.
      For example, for code page 936, provide the following to the resulting XML string:
       <code language="X#">strxml=STRTRAN(strxml, 'encoding=""', 'encoding="gb2312"'</code>
      32
      100000
      512
      1000000000
      Output to the file specified by cOutput.
      If a file does not exist, it is created. If the file already exists, it is overwritten. The setting for <b>SET SAFETY</b> is observed.
      4096
      1000000000000
      Disables base64 encoding.
      <b>CURSORTOXML( )</b> exports Memo (Binary) fields as xsd:base64binary unless you use nFlags set to 4096. In X#, base64 encoding is meant for encoding only binary data.
      32768
      none
      Indicates that a code page should be used.
      The following table describes how the encoding attribute is written when output encoding defaults to the cursor or table code page.
      Encoding flags are set by combining bits 4 and 5 (0010000).
      +0
      (Default) Windows-1252.
      +16
      Set output encoding attribute to the cursor code page.
      +32
      Set output encoding attribute to UTF-8 with no character translation.
      +48
      11
      Set output encoding attribute to UTF-8 and translate character data to UTF-8.
      The following table lists common Windows-compatible code pages.
      437
      MS-DOS, US
      ibm437
      850
      MS-DOS, International
      ibm850
      865
      MS-DOS, Nordic
      Empty string ("")
      866
      MS-DOS, Russian
      cp866
      932
      Windows, Japanese
      shift-jis
      Simplified Chinese
      949
      Windows, Korean
      iso-2022-kr
      or:
      ks_c_5601-1987
      950
      Windows, Traditional Chinese (Taiwan)
      big5
      1250
      Windows, East European
      Windows-1250
      Note case.
      1251
      Windows, Russian
      Windows-1251
      Windows, U.S., West European
      1253
      Windows, Greek
      Windows-1253
      1254
      Windows, Turkish
      Windows-1254
      1255
      Windows, Hebrew
      Windows-1255
      1256
      Windows, Arabic
      Windows-1256
      X# uses Windows-1252 as the default encoding. You can specify that the encoding attribute be set to match the code page, such as Big5 (code page 950), when using double-byte character sets (DBCS) for DBCS languages for which X# supports code pages.
      When using Windows-1252 and DBCS, no additional character translation is required to display correctly in Internet Explorer.
      However, to make XML more compliant for Web browsers that can interpret UTF-8, you can optionally set the encoding attribute to UTF-8 instead of Windows-1252. The result set undergoes translation to UTF-8 characters only when you set nFlags to 48 (specify the encoding attribute as UTF-8 and translate character data to UTF-8 format). This is required only when the data actually contains double-byte characters. You do not have to use character translation, <b>STRCONV ( )</b>, for example, if you are outputting only Latin (single byte) characters.

    </param>
    <param name="nRecords">

      Specifies the number of records to output to XML and has a default value is 0.
      If nRecords is 0, all records are output. If nRecords is greater than the number of records remaining in the table, all remaining records are output.

    </param>
    <param name="cSchemaName">

      Specifies the name and location to contain schema information for the data in cOutput, for example "MySchema.xsd". If no extension is provided, the schema file is created with an .xsd extension.
      The following table lists the values for cSchemaName.

      Specifies the name and path of the external file for the schema (scoped to the root element of the XML).
      If cSchemaName contains a file name and cSchemaLocation is not provided or is blank, the contents of cSchemaName xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute in the XML.
      In the following example, X# generates a generic XML file named MyXMLFile.xml from the Labels.dbf file in the "Labels" alias and the schema file named MySchema in the same folder.
       <code language="X#">CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, "mySchema.xsd")</code>
      If cSchemaName includes a URI, the schema is written to the current directory and must be uploaded to the server to be accessed by the browser or parser. External schemas always are written to the same location as the XML file.
      "1"
      Specifies an inline schema is produced. For example, the following code produces an inline schema:
       <code language="X#">CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, "1")</code>
      ""
      Specifies that no schema is produced.

    </param>
    <param name="cSchemaLocation">

      Specifies an optional location where the application reading the XML data should look for the schema file.
      Use this parameter only when you are deploying your schema to a location other than the location of the XML data.
      The contents of cSchemaLocation xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute of the XML data produced. The cschemaLocation parameter can be an HTTP address or other URI. You need to copy the schema file to the location you have specified in cSchemaLocation.
      The following example produces XML data:
       <code language="X#">
        CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, ;
        "mySchema.xsd", "http://www.microsoft.com/mySchema.xsd")
      </code>
      containing the following attribute:
       <code language="X#">   xsi:noNamespaceSchemaLocation=" http://www.microsoft.com/mySchema.xsd"</code>
      Specifying cSchemaLocation when cSchemaName is blank causes the same attributes to be written to the XML data. This makes it possible for you to point to an existing schema without recreating the schema each time <b>CURSORTOXML( )</b> is called.

    </param>
    <param name="cNamespace">

      Specifies the namespace of the XML or schema to be produced and has an empty string ("") as the default value.
      Specifying a value for cNameSpace sets the targetNamespace attribute to the same value and adds the elementFormDefault="qualified" attribute to the schema.
      If you do not specify a cNamespace value, and the schema is external, no namespace declaration is written to the schema. If you do not specify a cNamespace value and the schema is inline, the targetNamespace in the schema is set to an empty string ("").
    </param>
    <returns>
      Numeric data type. <b>CURSORTOXML( )</b> returns the number of bytes written to the file or a memory variable.
    </returns>
    <remarks>
      You can use <b>CURSORTOXML( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not supported because the <b>_VFP</b> system variable is not supported in the OLE DB Provider.
      To use the X# OLE DB Provider with <b>CURSORTOXML( )</b>, you must install MSXML 3.0 on the computer with the OLE DB Provider.

      <b>CURSORTOXML( )</b> output adheres to the cursor index order, <b>SET FIELDS TO</b>, and current filter settings. However, it does not preserve the cursor location. After the calling <b>CURSORTOXML( )</b>, if all records are output, the cursor record pointer reports <b>EOF</b>. If not all records are output, it points to the last record output to XML.
      The resulting XML from <b>CURSORTOXML( )</b> contains the same scale as the exported table if the table contains <b>Double</b> data type values. For example, if a <b>Double</b> column is created with a scale of 6 using the following codem the resulting XML contains six digits to the right of the decimal point:
       <code language="X#">CREATE TABLE test (col1 b(6))</code>
      When you use the <b>CURSORTOXML( )</b> function to export a table or cursor to XML, the root node is always called "VFPData", regardless of the output format.
      For <b>Date</b> types only, you can export "EMPTY" <b>Date</b> and <b>DateTime</b> types using <b>CURSORTOXML( )</b>. However, the XML schema validation might fail because "EMPTY" is not valid for these types in an XML schema definition (XSD) schema. This is an issue only if a schema is required, and the resulting XML is validated against an XML parser that can interpret XSD schemas. To work around this issue, you might need to change the data to a nonempty representation by calling the appropriate <b>SELECT</b> statement and use <b>CURSORTOXML( )</b> on the created cursor. For example, you can change the empty <b>Date</b> or <b>DateTime</b> values to .<b>NULL.</b>:
       <code language="X#">SELECT orderid, EVL(shippeddate,.NULL.) as ShippedDate FROM orders</code>
      You can also change the empty <b>Date</b> or <b>DateTime</b> to an appropriate representation for "empty":
       <code language="X#">
        SELECT orderid, IIF(EMPTY(shippeddate),{^1899-12-30 00:00:00},tc11);
      </code>
      When using flag 32768, the flags 16 and 32 settings can affect which code page is applied depending on the type of data you are writing to XML. The following tables show the possible combinations of settings and the code page each combination applies.
      For XML documents written with the 32768 flag set, the following code pages are applied.
      Flag 16
      Flag 32
      Flag 32768 is Set
      Not set
      Not set
      XML documents: Window-1252.
      Unicode data: code page 1252.
      Character data: default code page, unless a field is marked as <b>NOCPTRANS</b>.
      True (.T)
      Not set
      XML documents: Plus-<b>CodePage</b> property of the cursor. If XMLField <b>CodePage</b> property is greater than zero (0) and it doesn’t match the cursor’s code page, an error is reported.
      Unicode data: the <b>Code page</b> property of the cursor object.
      Character data: none. Raw data from the X# tables (.dbf) are used instead.
      Not set
      Set
      XML documents: UTF-8 code page.
      Unicode data: UTF-8 code page.
      Character data: Default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
      Set
      Set
      XML documents: UTF-8 code page.
      Unicode data: UTF-8 code page.
      Character data: default code page unless a field is marked as <b>NOCPTRANS</b>, in which case the data are translated to UTF-8 using the <b>SYS(3005)</b> setting.
      For XML documents written without setting the 32768 flag, the following code pages are applied.
      Flag 16
      Flag 32
      Without the 32768 flag
      Not set
      Not set
      XML documents: Window-1252.
      Unicode data: code page 1252.
      Character data: default code page unless a field is marked as <b>NOCPTRANS</b>.
      True (.T)
      Not set
      XML documents: <b>CodePage</b> property of the cursor.
      Character data: none. Raw data from the X# tables (.dbf) are used instead.
      Unicode data: code page property of the cursor object.
      Not set
      Set
      XML documents: UTF-8 code page.
      Unicode data: UTF-8 code page.
      Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
      Set
      Set
      XML documents: UTF-8 code page.
      Unicode data: UTF-8 code page.
      Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case, they are translated to UTF-8 using code page for the current <b>SYS(3005)</b> setting.
    </remarks>
  </cursortoxml>
  <curval>
    <summary>
      Returns field values directly from disk for a table or a remote data source.
    </summary>
    <param name="cExpression">

      Specifies an expression whose value CURVAL( ) returns from a table or a remote data source. cExpression is typically a field or an expression consisting of a set of fields from the table or remote data source.

    </param>
    <param name="uArea">

      Specifies the alias or workarea number of the table from which the field values are returned from disk for a table or a remote data source.

    </param>
    <returns>
      Character, Currency, Date, DateTime, Double, Float, Logical, Numeric, or Memo
    </returns>
    <remarks>
      The field values returned by CURVAL( ) and OLDVAL( ) can be compared to determine if another user on a network changed the field values while the fields were being edited. CURVAL( ) and OLDVAL( ) can only return different values when optimistic row or table buffering is enabled. Optimistic row or table buffering is enabled with CURSORSETPROP( ).
      If you are working with a view in a multiuser environment, the values returned by CURVAL() might not be up to date unless you call the REFRESH() function first. Data returned by a view is buffered, and the CURVAL() function reads values from the buffer. However, if other users have changed data in the underlying tables for the view, the buffered data is not updated until the REFRESH() function is called.
      CURVAL( ) returns field values for the current record, and the return value data type is determined by the expression you specify with cExpression.
      The value is returned for the table or cursor open in the currently selected work area if CURVAL( ) is issued without the optional cTableAlias or nWorkArea arguments.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        CREATE TABLE mytable FREE (cDigit C(10))
        * Store original value
        INSERT INTO mytable (cDigit) VALUES ("One")
        SET MULTILOCKS ON        &amp;&amp; Allow optimistic table buffering
        = CURSORSETPROP("Buffering",5)   &amp;&amp; Optimistic table buffering on
        REPLACE cDigit WITH "Two"    &amp;&amp; New value
        ? "Current value: " + CURVAL("cDigit", "mytable")
        ? "Old value: " + OLDVAL("cDigit", "mytable")
        = TABLEUPDATE(.T.)       &amp;&amp; Commit changes made to table
        ? "Table changes committed"
        ? "New current value: " + CURVAL("cDigit", "mytable")
        ? "New old value: " + OLDVAL("cDigit", "mytable")
      </code>
    </example>
  </curval>
  <dbalias>
    <summary>
      Returns database alias of currently set database.
    </summary>
    <returns>
      Character.
    </returns>
    <remarks>
      <b>DBALIAS( )</b> returns the empty string if there is no current database.
    </remarks>
    <example>

      <code language="X#">
        OPEN DATABASE HOME(2)+"northwind\northwind" SHARED
        OPEN DATABASE HOME(2)+"tastrade\data\tastrade" SHARED
        SET DATABASE TO NORTHWIND
        ? DBALIAS()
        SET DATABASE TO TASTRADE
        ? DBALIAS()
        ? JUSTSTEM(DBC())
      </code>
    </example>
  </dbalias>
  <dbc>
    <summary>
      Returns the name and path of the current database.
    </summary>
    <returns>
      Character
    </returns>
    <remarks>

      <b>DBC( )</b> returns the empty string if there is no current database.
      Use SET DATABASE to specify the current database.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')  &amp;&amp; Opens the DBC.
        CLEAR
        ? DBC( )  &amp;&amp; Displays the path and name of the database
      </code>
    </example>
  </dbc>
  <dbgetprop>
    <summary>
      Retrieves the value of a property for the current database or for fields, named connections, tables, or views in the current database.
      You must open the database before you can retrieve its properties or those of its connections, tables, views, or fields. However, you do not need to open a table or view before retrieving its properties.
    </summary>
    <param name="cName">

      Specifies the name of the current open database or the field, named connection, table, or view in the current open database for which <b>DBGETPROP( )</b> returns information.
      To return information about a field in a table or a view, preface the name of the field with the name of the table or view containing the field. For example, to return information about the codecustid/code field in the codecustomer/code table, specify the following for cName:
       <code language="X#">customer.custid</code>

    </param>
    <param name="cType">

      Specifies whether cName is the current database, or a field, named connection, table, or view in the current database. The following table lists the values for cType.
      CONNECTION
      cName is a named connection in the current database.
      DATABASE
      cName is the current database.
      FIELD
      cName is a field in the current database.
      TABLE
      cName is a table in the current database.
      VIEW
      cName is a view in the current database.

    </param>
    <param name="cProperty">

      Specifies the name of the property for which <b>DBGETPROP( )</b> returns information.
      The following tables list the values you can specify for cProperty, the return value types, and descriptions of each property. Each description includes the read and write privileges for each property. If a property is read-only, its value cannot be changed with <b>DBSETPROP( )</b>.
      <b>Connection properties</b>

      Asynchronous
      L
      The connection mode. (Default) False (.F.) specifies a synchronous connection. True (.T.) specifies an asynchronous connection.
      Read/write.
      BatchMode
      The batch-processing mode. (Default) True (.T.) specifies the connection that operates in batch mode.
      Comment
      The text of the connection comment.
      ConnectString
      The login connection string.
      ConnectTimeout
      N
      The connection timeout interval in seconds. The default is 0 (wait indefinitely).
      Database
      The name of the server database specified with the DATABASE clause in the CREATE CONNECTION command or in the Connection Designer.
      DataSource
      The name of the data source as defined in the Odbc.ini file.
      DisconnectRollback
      Specifies if a pending transaction is committed or rolled back when SQLDISCONNECT( ) is called for the last connection handle.
      The default is false (.F.), indicating that a pending transaction is committed when SQLDISCONNECT( ) is called for the last connection handle.
      Specify true (.T.) to roll back a pending transaction when SQLDISCONNECT( ) is called for the last connection handle.
      Connections with automatic transaction processing are not affected by this setting.
      DispLogin
      Contains a numeric value that determines when the ODBC Login dialog box is displayed. DispLogin may assume the following values:
      1 or DB_PROMPTCOMPLETE (from Foxpro.h). 1 is the default.
      2 or DB_PROMPTALWAYS (from Foxpro.h).
      3 or DB_PROMPTNEVER (from Foxpro.h).
      If 1 or DB_PROMPTCOMPLETE is specified, X# displays the ODBC Login dialog box only if any required information is missing.
      If 2 or DB_PROMPTALWAYS is specified, the ODBC Login dialog box is always displayed, allowing you to change settings before connecting.
      If 3 or DB_PROMPTNEVER is specified, the ODBC Login dialog box is not displayed and X# generates an error if the required login information is not available.
      DispWarnings
      Contains a logical value that determines if non-trappable warnings from the remote table, ODBC, or X# are displayed. (Default) True (.T.) specifies that non-trappable errors are displayed.
      IdleTimeout
      The idle timeout interval in minutes. Timeout is checked no more than once per minute, therefore it is possible that active connections might deactivate one or two minutes later after the specified time interval has elapsed. The default value is 0 (wait indefinitely).
      PacketSize
      The size of the network packet used by the connection. Adjusting this value can improve performance. The default value is 4096 bytes (4K).
      PassWord
      The connection password.
      QueryTimeout
      The query timeout interval in seconds. The default value is 0 (wait indefinitely).
      Transactions
      Contains a numeric value that determines how the connection manages transactions on the remote table. Transactions may assume the following values:
      1 or DB_TRANSAUTO (from Foxpro.h). 1 is the default. Transaction processing for the remote table is handled automatically.
      2 or DB_TRANSMANUAL (from Foxpro.h). Transaction processing is handled manually through SQLCOMMIT( ) and SQLROLLBACK( ).
      UserId
      The user identification.
      WaitTime
      The amount of time in milliseconds that elapses before X# checks whether the SQL statement has completed executing. The default is 100 milliseconds.
      <b>Database properties</b>
      The text of the database comment.
      DBCEventFileName
      Relative path and filename of external program file containing DBC Events code.
      DBCEvents
      Enabled state of DBC Events. Set to True (.T.) to enable.
      Version
      The database version number.
      Read-only.
      <b>Field properties for tables</b>
      Caption
      The field caption. If an equal sign (=) precedes the value of this property, X# evaluates the value as an expression. Otherwise, it is treated as a string literal.
      The text of the field comment.
      DefaultValue
      The field default value.
      DisplayClass
      Name of the class used for field mapping.
      DisplayClassLibrary
      Path to the class library specified with the <b>DisplayClass</b> property.
      Format
      The field display format. See the Format Property for a list of format settings.
      InputMask
      The field input format. See the InputMask Property for a list of input mask settings.
      RuleExpression
      The field rule expression.
      RuleText
      The field rule error text.
      <b>Field properties for views</b>
      DataType
      The data type for a field in a view. Initially set to the data type for the field in the data source.
      To specify a different data type for a field with <b>DBSETPROP( )</b>, use the syntax for creating fields in CREATE TABLE – SQL.
      For example, to change the data type of an integer field named iCost in a table named Mytable to numeric type with width 4 and 2 decimal places, use
      DBSETPROP('mytable.icost', 'field', ; 'DataType', 'N(4,2)')
      You can also include the NOCPTRANS clause to prevent translation of character and memo fields to a different code page.
      Read/write for remote views.
      KeyField
      Contains True (.T.) if the field is specified in an index key expression; otherwise, contains False (.F.).
      Updatable
      Contains True (.T.) if the field can be updated; otherwise, contains False (.F.).
      UpdateName
      The name of the field used when data in the field is updated to the remote table. By default, the remote table field name.
      <b>Table properties</b>
      The text of the table comment.
      DeleteTrigger
      The Delete trigger expression.
      InsertTrigger
      The Insert trigger expression.
      The relative path with respect to the DBC to the table including the name of the file.
      PrimaryKey
      The tag name of the primary key.
      The row rule expression.
      The row rule error text.
      UpdateTrigger
      The Update trigger expression.
      <b>View properties</b>
      AllowSimultaneousFetch
      Applies when using remote views, a shared connection, and to cursors created using ODBC.
      AllowSimultaneousFetch contains True (.T.) when similarly configured cursors sharing the connection are permitted to fetch rows simultaneously.
      Otherwise, AllowSimultaneousFetch contains False (.F.) when fetching rows simultaneously is not permitted.
      This property is available in X# 8.0 and later. Views created in X# 8.0 and later are not compatible with earlier versions. Calling the <b>VALIDATE DATABASE</b> command in a version prior to X# 8.0 on a database container with remote views created or modified in X# 8.0 and later generate an error. Calling the codeVALIDATE DATABASE RECOVER/code in a version prior to X# 8.0 removes the <b>AllowSimultaneousFetch</b> property from any such views.
      BatchUpdateCount
      The number of update statements sent to the back end for views. 1 is the default. Adjusting this value can greatly increase update performance.
      The text of the view comment.
      CompareMemo
      Contains true (.T.) (default) if memo fields (of type Memo, General, or Picture, or, for remote views, type Timestamp) are included in the WHERE clause for updates; otherwise, contains false (.F.).
      ConnectName
      The named connection used when the view is opened.
      FetchAsNeeded
      If True (.T.), data is fetched only when needed, such as when record pointer moves to a row that has not been fetched.
      If False (.F.), additional data is fetched during idle time. (Default)
      FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).
      FetchMemo
      Contains true (.T.) (default) if memo and general fields are fetched with the view results; otherwise, contains false (.F.).
      Use the ISMEMOFETCHED( ) Function to determine if the memo field has been fetched.
      Contains the number of records fetched at a time from the remote tables. The default is 100 records. Setting FetchSize to –1 retrieves the complete result set, limited by the MaxRecords setting.
      Progressive fetching holds the connection until all rows are retrieved. Use caution coding with FetchSize if ShareConnection is True (.T.).
      The maximum number of records fetched when result sets are returned. The default is – 1 (all rows are returned). A value of 0 specifies that the view is executed but no results are fetched.
      Offline
      Contains true (.T.) if the view is an offline view.
      ParameterList
      The WHERE clause parameters. The format for the parameters is ''ParameterName1, 'Type1'; ParameterName2, 'Type2'; ...'' where Type is a one of the following characters specifying the parameter type:
      C – Character  D – Date  T – DateTime  N – Numeric  F – Floating  B – Double  I – Integer  Y – Currency  L - Logical
      For example, ''MyParam1, 'C' '' specifies a single character type parameter named MyParam1.
      For more information about creating parameterized views, see How to: Create Parameterized Views.
      Prepared
      Contains True (.T.) if SQL statements are prepared for subsequent <b>REQUERY( )</b> function calls. <b>REQUERY( )</b> is used to retrieve data again for a SQL view. See SQLPREPARE( ) for additional information about preparing SQL statements. The default is false (.F.).
      The rule text expression displayed when an error occurs when data is edited in a Browse or Edit window.
      SendUpdates
      Contains true (.T.) if a SQL update query is sent to update remote tables; otherwise, contains false (.F.) (default).
      Contains true (.T.) if the view can share its connection handle with other connections; otherwise, contains false (.F.).
      SourceType
      The view source. SourceType may assume the following values: 1 - The view uses local tables.
      2 - The view uses remote tables.
      The SQL statement executed when the view is opened.
      Tables
      A comma-delimited list of the names of the tables.
      UpdateType
      The update type. Valid values are: 1 or DB_UPDATE (from Foxpro.h). The old data is updated with the new data (default).
      2 or DB_DELETEINSERT (from Foxpro.h). The old data is deleted and the new data is inserted.
      UseMemoSize
      The minimum size (in bytes) for which result columns are returned in memo fields. For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field. UseMemoSize may vary from 1 to 255; the default value is 255.
      WhereType
      The WHERE clause for updates to remote tables. WhereType may assume the following values: 1 or DB_KEY (from Foxpro.h). The WHERE clause used to update remote tables consists of only the primary fields specified with the <b>KeyFieldList</b> property.
      2 or DB_KEYANDUPDATABLE (from Foxpro.h). The WHERE clause used to update remote tables consists of the primary fields specified with the <b>KeyFieldList</b> property and any updatable fields.
      3 or DB_KEYANDMODIFIED (from Foxpro.h) (default). The WHERE clause used to update remote tables consists of the primary fields specified with the <b>KeyFieldList</b> property and any other fields that are modified.
      4 or DB_KEYANDTIMESTAMP (from Foxpro.h). The WHERE clause used to update remote tables consists of the primary fields specified with the <b>KeyFieldList</b> property and a comparison of the time stamps.
      For more information about the <b>WhereType</b> property, see Managing Updates by Using Views.
    </param>
    <returns>
      Character, Numeric, or Logical data type. <b>DBGETPROP( )</b> returns the value for the specified property.
    </returns>
    <remarks>
      For more information about setting property values, see DBSETPROP( ) Function.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        * Displays the primary key field
        cResults = DBGETPROP("customer", "Table", "PrimaryKey")
        =MESSAGEBOX(cResults)   &amp;&amp; Displays    'cust_id'
        * Displays comments for the field 'cust_id'
        cResults = DBGETPROP("customer.cust_id", "Field", "Comment")
        IF LEN(ALLTRIM(cResults)) = 0
        =MESSAGEBOX("No Comment for this field." + CHR(13) + ;
        CHR (13) + "Use DBSETPROP( ) to add comments.")
        ELSE
        =MESSAGEBOX("Cust_id field comments: " + cRESULTS)
        ENDIF
      </code>
    </example>
  </dbgetprop>
  <dbsetprop>
    <summary>
      Sets a property for the current database or for fields, named connections, tables, or views in the current database.
    </summary>
    <param name="cName">

      Specifies the name of the current open database or the field, named connection, table, or view in the current open database for which <b>DBGETPROP( )</b> returns information.
      To set a property for a field in a table or a view, preface the name of the field with the name of the table or view containing the field. For example, to set a property for the codecustid/code field in the codecustomer/code table, specify the following for cName:
       <code language="X#">customer.custid</code>

    </param>
    <param name="cType">

      Specifies whether cName is the current database or for a field, named connection, table, or view in the current database.
      The following table lists the values you can specify for cType:
      CONNECTION
      cName is a named connection in the current database.
      DATABASE
      cName is the current database.
      FIELD
      cName is a field in the current database.
      TABLE
      cName is a table in the current database.
      VIEW
      cName is a view in the current database.

    </param>
    <param name="cProperty">

      Specifies the name of the property to set. If a property is read-only, its value cannot be changed with <b>DBSETPROP( )</b>. If you attempt to set a property that is read-only, X# generates an error message.
      For more information on properties you can specify with cProperty, including their data types, see DBGETPROP( ).

    </param>
    <param name="ePropertyValue">

      Specifies the value to which cProperty is set. ePropertyValue must be the same data type as the property's data type.
      X# does not verify that the value you specify is valid for the property. Thus, it is possible to set a property to an invalid value with <b>DBSETPROP( )</b>. For example, <b>DBSETPROP( )</b> can be used to set a field rule expression to an expression that is not valid for the field, and X# will not generate an error. To avoid an error when setting the Tables property of a view, precede ePropertyValue with the database designation in the following syntax:
       <code language="X#">         &lt;databaseName&gt;!ePropertyValue</code>
    </param>
    <returns>
      Logical data type. <b>DBSETPROP( )</b> returns True (.T.) if X# successfully sets the property you specify. X# generates an error if the property you specify cannot be set.
    </returns>
    <remarks>
      For more information about retrieving current property values, see DBGETPROP( ) Function.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer     &amp;&amp; Open customer table
        = DBSETPROP("customer.cust_id", "Field", "Comment", ;
        "Property has been set by DBSETPROP.")  &amp;&amp; New field comments
        cRESULTS = DBGETPROP("customer.cust_id", "Field", "Comment")
        WAIT WINDOW "Cust_id field comments: "+ cRESULTS  &amp;&amp; Display comments
      </code>
    </example>
  </dbsetprop>
  <dbused>
    <summary>
      Returns true (.T.) if the specified database is open.
    </summary>
    <param name="cDatabaseName">

      Specifies the name of the database for which <b>DBUSED( )</b> returns a logical value indicating whether or not the database is open.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>DBUSED( ) </b>returns true (.T.) if the specified database is open; otherwise, it returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        CLEAR
        ? 'Testdata database open? '
        ?? DBUSED('testdata')     &amp;&amp; Displays .T.
        ? 'Test database open? '
        ?? DBUSED('test')     &amp;&amp; Displays .F.
      </code>
    </example>
  </dbused>
  <ddeaborttrans>
    <summary>
      Ends an asynchronous dynamic data exchange (DDE) transaction.
    </summary>
    <param name="nTransactionNumber">

      Specifies the transaction number returned by <b>DDEExecute( )</b>, <b>DDEPoke( )</b>, or <b>DDERequest( )</b> when the transaction is sent to the server application.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      An asynchronous transaction allows X# program execution to continue without waiting for the server application to respond to a data request.

      <b>DDEExecute( )</b>, <b>DDEPoke( )</b>, and <b>DDERequest( )</b> wait for the period specified by <b>DDESetOption( )</b> for a server application to respond, unless you specify a user-defined function to execute when the server application responds. Specifying a user-defined function to execute in these functions creates an asynchronous transaction.
      If <b>DDEAbortTrans( )</b> is called before the server has processed the request, the user-defined function will not be called for the transaction.

      <b>DDEAbortTrans( )</b> returns true (.T.) if the asynchronous transaction is successfully ended and returns false (.F.) if the asynchronous transaction cannot be ended. Use <b>DDELastError( )</b> to determine why the transaction could not be ended.
    </remarks>
  </ddeaborttrans>
  <ddeadvise>
    <summary>
      Creates a notify link or an automatic link used in a dynamic data exchange (DDE).
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number.

    </param>
    <param name="cItemName">

      Specifies the item name. For example, Microsoft Excel uses row and column notation to refer to cells in a worksheet. The item name R1C1 designates the cell in the first row and first column of the worksheet.

    </param>
    <param name="cUDFName">

      Specifies the user-defined function that is executed when a notify link or an automatic link is established and the item cItemName is modified. When the user-defined function is executed, it is passed the following six parameters in the order given below:
      Channel Number
      The channel number of the server application.
      Action
      ADVISE or TERMINATE.
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (automatic link) or the empty string (notify link).
      Format
      The data format; for example, CF_TEXT.
      Advise Status
      The link type (0 = manual, 1 = notify, 2 = automatic).
      The user-defined function should have six parameters in its LPARAMETER or PARAMETER statement to accept the values passed from the server application. If a notify link is established, the user-defined function is executed and the empty string is passed in the Data parameter. You can issue <b>DDERequest( )</b> later to retrieve the data. If an automatic link is established, the user-defined function is executed and the data is passed in the Data parameter.
      The Action parameter contains ADVISE when the link is being updated by the server. The user-defined function is called, and the Action parameter contains TERMINATE when the link is closed by the client or server.
      Any value returned by the user-defined function is ignored.

    </param>
    <param name="nLinkType">

      Specifies the link type in the following way:
      0
      Manual
      1
      Notify
      2
      Automatic
      You can turn off notification from the server application by specifying 0 for nLinkType. If the item changes, the user-defined function is not executed.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>DDEAdvise( )</b> is used to create a notify link or an automatic link to an item name in a server application. When a notify link is created with <b>DDEAdvise( )</b>, the server application notifies X# that the item name has been modified. If an automatic link is created, the server application notifies X# that the item name has been modified and passes the new data to X#.
      Before you can create a link, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      You can also use <b>DDEAdvise( )</b> to turn off notification from the server.
      DDEAdvise( ) returns a true value (.T.) if it executes successfully; otherwise, it returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        PUBLIC mchannum
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        = DDEAdvise(mchannum, 'R1C1', 'newdata', 1)     &amp;&amp; Notify link
        = DDEAdvise(mchannum, 'R1C2', 'newdata', 2)     &amp;&amp; Automatic link
        WAIT WINDOW 'Enter data in first two cells in Excel.'
        ENDIF
        PROCEDURE newdata
        PARAMETERS channel, action, item, data, format, advise
        IF action = 'ADVISE'
        DO CASE
        CASE item = 'R1C1'   &amp;&amp; Notify link
        newvalue = DDERequest(channel, item)
        ? 'R1C1 notify link: ' + newvalue
        CASE item = 'R1C2'   &amp;&amp; Automatic link
        newvalue = data
        ? 'R1C2 automatic link: ' + newvalue
        ENDCASE
        ELSE
        IF action != "TERMINATE"
        = DDETerminate(mchannum)
        ENDIF
        ENDIF
      </code>
    </example>
  </ddeadvise>
  <ddeenabled>
    <summary>
      Enables or disables dynamic data exchange (DDE) processing or returns the status of DDE processing.
    </summary>
    <param name="lExpression1">

      Specify true (.T.) or false (.F.) to globally enable or disable DDE processing. <b>DDEEnabled( )</b> returns true (.T.) if DDE processing is successfully enabled or disabled; otherwise false (.F.) is returned.

    </param>
    <param name="nChannelNumber">

      Specifies the channel number for the channel whose DDE processing status <b>DDEEnabled( )</b> returns. <b>DDEEnabled( )</b> returns true (.T.) if DDE processing is enabled for the specified channel and returns false (.F.) if DDE processing is disabled.

    </param>
    <param name="lExpression2">

      To enable DDE processing for a specific channel, include the channel number (nChannelNumber) and specify true (.T.) for lExpression2. To disable DDE processing for a specific channel, include the channel number (nChannelNumber) and specify false (.F.) for lExpression2.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Using <b>DDEEnabled( )</b>, you can globally enable or disable processing. You can also enable or disable DDE processing for specific channels.

      <b>DDEEnabled( )</b> can be used to protect critical code or disable links for short periods. When DDE processing is disabled, client requests are queued until DDE processing is enabled.
      If <b>DDEEnabled( )</b> is issued without any of its optional arguments, the global DDE processing status is returned. <b>DDEEnabled( </b>) returns true (.T.) if DDE processing has been globally enabled and false (.F.) if DDE processing has been globally disabled.
    </remarks>
  </ddeenabled>
  <ddeexecute>
    <summary>
      Sends a command to another application, using dynamic data exchange (DDE).
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number.

    </param>
    <param name="cCommand">

      Specifies the command you want to send to the other application. The format of the command is determined by the application you are sending it to. Consult the application's documentation for the correct syntax.

    </param>
    <param name="cUDFName">

      Allows asynchronous command execution requests. If you omit cUDFName, a client application waits for the period specified with <b>DDESetOption( )</b>. If you specify a user-defined function with cUDFName, client program execution continues immediately after the command execution request is made.
      When the server application finishes executing the command, the user-defined function you specify with cUDFName is executed. The user-defined function is passed six parameters in the order shown in the following table.
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful execution).XACTFAIL (failed command execution).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by DDEExecute( ).
      Use <b>DDEAbortTrans( )</b> to cancel an uncompleted transaction. If the transaction fails, you can use <b>DDELastError( )</b> to determine why it failed.
      When you include cUDFName, <b>DDEExecute( )</b> does not return a logical value. Instead, a transaction number is returned; if an error occurs, –1 is returned.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      The command sent with <b>DDEExecute( )</b> must be understood by the application. Before you can execute the command, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      For example, Microsoft Excel has an extensive set of macro commands, including DDE commands that let you request data from X# from within Microsoft Excel. If you establish a channel to Microsoft Excel, you can then use <b>DDEExecute( )</b> to send macro commands to Excel from within X#.
      If the receiving application successfully executes the command, <b>DDEExecute( )</b> returns true (.T.). If the receiving application cannot successfully execute the command or if the channel number you include is not valid, <b>DDEExecute( )</b> returns false (.F.). If the optional asynchronous user-defined function cUDFName is included, a transaction number is returned. If an error occurs, DDEExecute( ) returns –1.
    </remarks>
    <example>
       <code language="X#">
        gnChanNum = DDEInitiate('Excel', 'Sheet1')
        IF gnChanNum != -1
        glExecute = DDEExecute(gnChanNum, '[App.Maximize]')
        IF glExecute != .F.
        WAIT WINDOW 'EXCEL window has been zoomed out.'
        ENDIF
        = DDETerminate(gnChanNum)   &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </ddeexecute>
  <ddeinitiate>
    <summary>
      Establishes a dynamic data exchange (DDE) channel between X# and another Microsoft Windows-based application.
    </summary>
    <param name="cServiceName">

      Specifies the service name of the server application, which, in most cases, is the name of the executable file without its extension. The default service name for X# is X#. If you are establishing a channel to Microsoft Excel, cServiceName is Excel.

    </param>
    <param name="cTopicName">

      Specifies the topic name. The topic is application-specific and must be understood by the application. For example, one topic supplied by most DDE servers is the System topic. See the application documentation for the service and topic names supported by the application.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>DDEInitiate( ) </b>establishes a DDE channel between X# and a DDE server application. Once a channel is established, X# can request data from the server by referring to the channel in subsequent DDE functions. X# acts as the client, requesting data from the server application through the channel.
      If the channel is successfully established, <b>DDEInitiate( )</b> returns the channel number. Channel numbers are non-negative, and the number of channels you can establish is limited only by your system resources.

      <b>DDEInitiate( )</b> returns –1 if the channel cannot be established. If the server application is not open, X# asks if you would like to open it. If you choose Yes, X# attempts to open the application. (You can use <b>DDELastError( )</b> to determine why a channel cannot be established.)
      To avoid being asked whether you want to open the application, set the <b>DDESetOption( )</b> SAFETY option. You can also use RUN with the /N option to start the application.
      A channel can be closed with <b>DDETerminate( )</b>.
    </remarks>
    <example>
       <code language="X#">
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        * Process client actions
        = DDETerminate(mchannum)  &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </ddeinitiate>
  <ddelasterror>
    <summary>
      Returns an error number for the last dynamic data exchange (DDE) function.
    </summary>
    <returns>
      DDELastError( )Return Value
      Numeric
    </returns>
    <remarks>
      You can use <b>DDELastError( )</b> to help determine the cause of an error when a DDE function does not execute successfully.

      <b>DDELastError( )</b> returns 0 if the last DDE function executed successfully. It returns a nonzero value if the last DDE function was unsuccessful. The following table lists the error numbers and their descriptions.
      1
      Service busy
      2
      Topic busy
      3
      Channel busy
      4
      No such service
      5
      No such topic
      6
      Bad channel
      7
      Insufficient memory
      8
      Acknowledge timeout
      9
      Request timeout
      10
      No DDEInitiate( )
      11
      Client attempted server transaction
      12
      Execute timeout
      13
      Bad parameter
      14
      Low memory
      15
      Memory error
      16
      Connect failure
      17
      Request failure
      18
      Poke timeout
      19
      Could not display message
      20
      Multiple synchronous transactions
      21
      Server died
      22
      Internal DDE error
      23
      Advise timeout
      24
      Invalid transaction identifier
      25
      Unknown
    </remarks>
  </ddelasterror>
  <ddepoke>
    <summary>
      Sends data between client and server applications in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number of the application data is sent to. If the channel number is a server channel, <b>DDEPoke( )</b> sends the data in response to a request or a previously established notify or automatic link.

    </param>
    <param name="cItemName">

      Specifies the item name to which data is sent. The item name is application-specific and must be understood by the application. For example, Microsoft Excel supports R1C1 as a valid item name that refers to the first cell in a worksheet.

    </param>
    <param name="cDataSent">

      Specifies the data sent to the item name specified with cItemName.

    </param>
    <param name="cDataFormat">

      Specifies the format used to send the data. The default format is CF_TEXT. In this format, fields are delimited with tabs and records are delimited with a carriage return and a linefeed.

    </param>
    <param name="cUDFName">

      Allows asynchronous data transfer. If cUDFName is omitted, a client waits for the period specified with <b>DDESetOption( )</b>. If you specify the name of a user-defined function with cUDFName, client program execution continues immediately after the request is made.
      When the data is available from the server application, the user-defined function specified with cUDFName is executed. The user-defined function is passed six parameters in this order:
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful transaction).XACTFAIL (failed transaction).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by <b>DDEPoke( )</b>.
      Use DDEAbortTrans( ) to cancel an uncompleted transaction. If the transaction fails, you can use DDELastError( ) to determine why it failed.
      When you include cUDFName, DDEPoke( ) returns a transaction number if successful or –1 if an error occurs.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>DDEPoke( )</b> sends data as a character string to the item name in the application specified by the channel number.
      If the data is successfully sent, <b>DDEPoke( )</b> returns true (.T.). If the data cannot be sent, <b>DDEPoke( )</b> returns false (.F.). If the asynchronous user-defined function cUDFName is included, <b>DDEPoke( )</b> returns a transaction number; if an error occurs, <b>DDEPoke( )</b> returns –1.
    </remarks>
  </ddepoke>
  <dderequest>
    <summary>
      Requests data from a server application in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number of the server application.

    </param>
    <param name="cItemName">

      Specifies the item name. The item name is application-specific and must be understood by the application. For example, Microsoft Excel uses row and column notation to refer to cells in a worksheet. The item name R1C1 designates the cell in the first row and first column of the worksheet.

    </param>
    <param name="cDataFormat">

      Specifies a format for the data requested. The default format is CF_TEXT. In this format, fields are delimited with tabs and records are delimited with a carriage return and a line feed.

    </param>
    <param name="cUDFName">

      Allows an asynchronous data transfer. If you omit cUDFName, X# waits for the data from the server for the period specified with <b>DDESetOption( )</b>. If you specify the name of a user-defined function with cUDFName, X# continues program execution immediately after the request is made.
      When the data is available from the server application, the user-defined function specified with cUDFName is executed. The user-defined function is passed six parameters in this order:
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful transaction).XACTFAIL (failed transaction).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by <b>DDERequest( )</b>.
      Use <b>DDEAbortTrans( )</b> to cancel an uncompleted transaction. If the transaction fails, you can use <b>DDELastError( )</b> to determine why it failed.
      When you include cUDFName, <b>DDERequest( )</b> returns a transaction number equal to or greater than 0 if successful, or –1 if an error occurs.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Before you can request data using <b>DDERequest( )</b>, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      If the request for data is successful, <b>DDERequest( )</b> returns the data as a character string. If the request fails, <b>DDERequest( )</b> returns an empty string and <b>DDELastError( )</b> returns a nonzero value. If you include the asynchronous user-defined function cUDFName, DDERequest( ) returns a transaction number if successful, or –1 if an error occurs.
    </remarks>
    <example>
       <code language="X#">
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        mrequest = DDERequest(mchannum, 'R1C1')
        IF !EMPTY(mrequest) AND DDELastError( ) = 0      &amp;&amp; Successful
        WAIT WINDOW 'R1C1 contents: ' + mrequest
        ENDIF
        = DDETerminate(mchannum)            &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </dderequest>
  <ddesetoption>
    <summary>
      Changes or returns dynamic data exchange (DDE) settings.
    </summary>
    <param name="cOption">

      Specifies the setting options.
      TIMEOUT
      nTimeoutValue (number of milliseconds)
      2000
      The number of milliseconds DDE functions wait for the server application to respond; the current TIMEOUT value is returned if you omit nTimeoutValue.
      SAFETY
      lExpression(true (.T.) or false (.F.))
      Specifies whether a dialog is displayed when you use <b>DDEInitiate( )</b> to establish a channel to a server application and the application does not respond; the current SAFETY setting is returned if you omit lExpression.

    </param>
    <param name="nTimeoutValue">

      Specifies the timeout value.

    </param>
    <param name="lExpression">

      Enables or disables dialog display.
    </param>
    <returns>
      Logical or Numeric
    </returns>
    <remarks>
      Use <b>DDESetOption( )</b> to change or return DDE settings. Two options, TIMEOUT and SAFETY, are available.
    </remarks>
  </ddesetoption>
  <ddesetservice>
    <summary>
      Creates, releases, or modifies DDE service names and settings.
    </summary>
    <param name="cServiceName">

      Specifies the service name to create, release, modify, or return information about.

    </param>
    <param name="cOption">

      Specifies to create, release, or modify a service name or to return information about a service name. The following table lists the options you can specify with cOption, the default values for the options and a description of each option.
      DEFINE
      –
      Creates a new service name.
      RELEASE
      Releases an existing service name.
      ADVISE
      .F.
      Enables or disables client notification of changes to item names.
      EXECUTE
      Enables or disables command execution.
      POKE
      Enables or disables client pokes to the service.
      REQUEST
      .T.
      Enables or disables requests to the service name.
      FORMATS
      CF_TEXT
      Specifies supported data formats.
      DEFINE
      Creates a new service name. For example, the following command creates the service name codemyservice/code:
       <code language="X#">glNewService = DDESetService('myservice', 'DEFINE')</code>
      RELEASE
      Releases an existing service name to free up system resources. When a service name is released, all of the service's topic names are also released.
      The following command releases the service name created in the previous example:
       <code language="X#">glRelease = DDESetService('myservice', 'RELEASE')</code>
      To release the default X# service, issue this command:
       <code language="X#">glRelFox = DDESetService('FoxPro', 'RELEASE')</code>
      ADVISE
      Specifies whether a client is notified when data changes in an item name or specifies to return the current advise status for a service name. Refer to <b>DDEAdvise( )</b> for additional information about advising clients.
      To enable client notification, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client notification.
      To return the current client notification status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if client notification is enabled for the service name; it returns false if client notification is disabled.
      EXECUTE
      Allows you to enable or disable command execution requests to a service name or to determine the current execute status for a service name.
      To enable client requests to execute a command, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client requests to execute a command. .F. is the default value.
      To return the current command execution status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if client command execution requests are enabled for the service name; otherwise, it returns false.
      The following commands enable command execution and disable data requests from client applications for the service name codemyservice/code. The current command execution status for codemyservice/code is then displayed:
       <code language="X#">
        glExecute = DDESetService('myservice', 'EXECUTE', .T.)
        glRequest = DDESetService('myservice', 'REQUEST', .F.)
        ? DDESetService('myservice', 'EXECUTE')
      </code>
      POKE
      Allows you to enable or disable poke requests to the service name. You can also determine the current poke status for a service name. Refer to <b>DDEPoke( )</b> for additional information about poking data to a server or a client.
      To enable client poke requests, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client poke requests. .F. is the default value.
      To return the current poke status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if poke requests are enabled for a service name; it returns false if poke requests are disabled.
      REQUEST
      Use REQUEST to enable or disable client requests to a service name or to return the current request status for the service name.
      To enable client requests to the service name, specify true (.T.) for lExpression. Specifying false (.F.) disables client requests to the service name. True (.T.) is the default value.
      To return the current request status for a service name, omit lExpression. <b>DDESetService( )</b> returns true if client requests are enabled for the service name; it returns false if client requests are disabled.
      The following commands disable requests from client applications to the service name codemyservice/code and display the current request status for codemyservice/code:
       <code language="X#">
        glRequest = DDESetService('myservice', 'REQUEST', .F.)
        ? DDESetService('myservice', 'REQUEST')
      </code>
      FORMATS [ cDataFormat]
      Specifies the data formats supported by the service name. Server requests for formats not specified with cDataFormat are rejected. When specifying data formats, include a list of the supported formats separated by commas. For example:
       <code language="X#">=DDESetService('myservice', 'FORMATS', 'CF_TEXT, CF_SYLK')</code>
      If you omit cDataFormat, only the CF_TEXT format is supported.
    </param>
    <param name="lExpression">

      Specifies the state of the REQUEST, EXECUTE, POKE, or ADVISE options. Specify true (.T.) for lExpression to enable the option or false (.F.) to disable it.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      X# can act as a dynamic data exchange (DDE) server to send data to client Microsoft Windows-based applications. <b>DDESetService( )</b> is used to create, release, or modify service names and settings in X#. Each service name can have a set of topic names created with <b>DDESetTopic( )</b>. Client applications request data from DDE topic names.

      <b>DDESetService( )</b> returns true (.T.) if the service name is successfully created, released, or modified. If the service name cannot be created, released, or modified, <b>DDESetService( )</b> returns false (.F.).

      <b>DDESetService( )</b> can also be used to return information about a service name. X# has the default service name FoxPro. The X# service name has one topic name called System. The following table lists all the item names supported by the System topic.
      Topics
      A list of available topic names
      Formats
      A list of supported formats
      Status
      Busy or Ready
      SysItems
      A list of item names
      You can use DDESetTopic( ) to modify the FoxPro service name or to release it. For information about manipulating X# service names, see the DDESetTopic( ) options.
    </remarks>
  </ddesetservice>
  <ddesettopic>
    <summary>
      Creates or releases a topic name from a service name in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="cServiceName">

      Specifies the service name. Additional service names can be created with DDESetService( ).

    </param>
    <param name="cTopicName">

      Specifies the topic name to create or release. If you include cUDFName, <b>DDESetTopic( )</b> creates the topic name cTopicName. If you omit cUDFName, the topic name cTopicName is released. If cTopicName is an empty string, the user-defined function specified with cUDFName is executed for any topic name that is not explicitly declared.

    </param>
    <param name="cUDFName">

      Specifies the name of the user-defined function executed when a client application makes a request to the topic name. If you omit cUDFName, the topic name cTopicName is released from the service name.
      When the user-defined function is executed, it is passed the following six parameters in the order given below:
      Channel Number
      The client channel number.
      Action
      ADVISE, EXECUTE, INITIATE, POKE, REQUEST, or TERMINATE.
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      Data from the client.
      Format
      The data format; for example, CF_TEXT.
      Advise Status
      The link type (0 = manual, 2 = notify or automatic).
      The values of the Item, Data, and Advise Status parameters depend on the Action parameter. The following table lists the Action parameter values and the values contained in the Item, Data, and Advise Status parameters. A dash (–) indicates that the parameter value is the empty string.
      Topic name
      Item name
      New data
      New command
      Link type
      If the user-defined function successfully handles the client request, the user-defined function should return true (.T.). If the request cannot be handled or an error occurs, the user-defined function should return false (.F.). If false is returned when the Action parameter value is INITIATE, the client topic name request is rejected. If false is returned when the value is POKE, REQUEST, or EXECUTE, the request is ignored. If false is returned when the value is ADVISE, the client request for a notify or automatic link is rejected.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      After a topic name is created, any client requests to the topic name cause X# to execute the user-defined function specified with cUDFName. The user-defined function is passed a set of parameters whose values are determined by the client request. The user-defined function return value is passed to the client with DDEPoke( ). The return value is a logical value indicating whether the topic name can provide the service requested by the client.

      <b>DDESetTopic( )</b> returns true (.T.) if it successfully creates or releases the topic name. It returns false (.F.) if the topic name cannot be created or released. Use DDELastError( ) to determine why a topic name cannot be created or released.
    </remarks>
    <example>
      The following example creates a basic sample server called codemyserver/code that supports X# command execution from a client application. The client application makes requests to codemyserver/code through the DO topic, and macro substitution is used to execute the client's command.
       <code language="X#">
        *** Set X# up as a DDE server ***
        = DDESetService('myserver', 'DEFINE')
        = DDESetService('myserver', 'EXECUTE', .T.)
        = DDESetTopic('myserver', 'DO', 'DOTOPIC')
        WAIT WINDOW 'Server portion service setup ... ' NOWAIT
        *** Use X# as a DDE client ***
        gnChannel = DDEInitiate('myserver','DO')
        =DDEExecute(gnChannel, 'WAIT WINDOW "Command Executed ... "')
        =DDETerminate(gnChannel)
        PROCEDURE dotopic
        PARAMETERS gnChannel, gcAction, gcItem, gData, gcFormat, gnAdvise
        glResult = .F.
        *** It's necessary to return .T. from an   ***
        *** INITIATE action or no connection is made ***
        IF gcAction = 'INITIATE'
        glResult = .T.
        ENDIF
        IF gcAction = 'EXECUTE'
        &amp;gData
        glResult = .T.
        ENDIF
        IF gcAction = 'TERMINATE'
        WAIT WINDOW 'Goodbye ... ' NOWAIT
        glResult = .T.
        ENDIF
        RETURN glResult
      </code>
      After running this example program, you have set up X# service, which other applications can access. If you have Microsoft Excel, you can run the following Excel macro:
       <code language="X#">
        gnMyChan = INITIATE("myserver","DO")
        =EXECUTE(MyChan,"WAIT WINDOW 'Hi, this is EXCEL speaking'")
        =RETURN( )
      </code>
    </example>
  </ddesettopic>
  <ddeterminate>
    <summary>
      Closes a dynamic data exchange (DDE) channel established with <b>DDEInitiate( )</b>.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number to close.

    </param>
    <param name="cServiceName">

      Specifies the service name to close.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      If the channel is successfully closed, <b>DDETerminate( )</b> returns true (.T.). If the channel cannot be closed, <b>DDETerminate( )</b> returns false (.F.).
      Be sure to close channels as soon as they are no longer needed to conserve system resources.
      All channels are automatically closed if you exit X# by choosing Exit from the File menu or by issuing QUIT in the Command window or from within a program.
    </remarks>
  </ddeterminate>
  <defaultext>
    <summary>
      Returns a file name with a new extension if one does not already exist.
    </summary>
    <param name="cFileName">

      Specifies the filename (with or without a path or extension) to be returned.

    </param>
    <param name="cDefault">

      Specifies the default extension without a period.
    </param>
    <returns>
      Character
    </returns>
  </defaultext>
  <descending>
    <summary>
      Returns a logical value that indicates whether an index tag was created with the DESCENDING keyword or whether the DESCENDING keyword was included in USE, SET INDEX, or SET ORDER.
    </summary>
    <param name="uIndex">

      Specifies the name or index number of a compound index file with CDXFileName. The compound index file you specify can be the structural compound index file automatically opened with the table or an independent compound index file.
      Specifies which index tag or index file DESCENDING( ) tests. nIndexNumber is typically an integer that starts at 1 and is increased by 1 to return additional values for each index tag.
      If nIndexNumber is 1, a value for the master single-entry .idx index file or master index tag (if one is present) is returned.
      As nIndexNumber increases, values for each tag in the structural compound index (if one is present) are returned. The values are returned for the tags in the order in which the tags were created in the structural compound index.
      After values for all the tags in the structural compound index are returned, values for each tag in any open independent compound indexes are then returned. The values are returned from the tags in the order in which the tags are created in the independent compound indexes.
      The empty string is returned if nIndexNumber is greater than the total number of open, single-entry .idx files and structural compound and independent compound index tags.

    </param>
    <param name="uArea">
      Returns values for index files or tags open in a work area other than the current work area. This specifies the work area number or table alias.
      If no table has the alias you specify, X# generates an error message.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      You can order records in a table in descending order in two ways:
      You can include the DESCENDING keyword in the INDEX command to create a descending order index tag in a compound .cdx.
      You can include the DESCENDING keyword in USE, SET INDEX or SET ORDER to specify a descending order for the master index tag or the master single-entry index (.idx) file.
      DESCENDING( ) can determine if an index tag was created in descending order. DESCENDING( ) returns true (.T.) if the index tag you specify was created with the DESCENDING keyword.
      DESCENDING( ) can also determine if the master index tag or master index file is in descending order. DESCENDING( ) returns true (.T.) if the DESCENDING keyword was included in USE, SET INDEX, or SET ORDER for the master index tag or a single-entry index (.idx) file you specify.
      If you don't include any of the optional arguments, DESCENDING( ) returns a value for the master index tag or master index file. If you don't include any of the optional arguments and a master index tag or .idx file isn't in effect (for example, you've issued SET ORDER TO to place the table in physical record order), DESCENDING( ) returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE Customer     &amp;&amp; Open customer table
        CLEAR
        FOR nCount = 1 TO TAGCOUNT( )
        IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
        ? TAG(nCount) + ' Descending? ' &amp;&amp; Display tag name
        ?? DESCENDING(nCount)  &amp;&amp; Display descending status
        ELSE
        EXIT  &amp;&amp; Exit the loop when no more tags are found
        ENDIF
        ENDFOR
      </code>
    </example>
  </descending>
  <difference>
    <summary>
      Returns an integer, 0 through 4, which represents the relative phonetic difference between two character expressions.
    </summary>
    <returns>
      Numeric
    </returns>
    <remarks>
      DIFFERENCE( ) is useful for searching tables when the exact spelling of an entry isn't known.
      The more alike the two expressions are spelled, the higher the number DIFFERENCE( ) returns. If the character expressions are spelled very similarly, DIFFERENCE( ) returns 4. For two character expressions with little in common phonetically, DIFFERENCE( ) returns 0.
    </remarks>
    <example>
       <code language="X#">
        STORE 'Smith' TO gcName1
        STORE 'Smythe'  TO gcName2
        STORE 'Smittie' TO gcName3
        STORE '' TO gcName4
        CLEAR
        ? DIFFERENCE(gcName1, gcName2)  &amp;&amp; Displays 4
        ? DIFFERENCE(gcName1, gcName3)  &amp;&amp; Displays 4
        ? DIFFERENCE(gcName1, gcName4)  &amp;&amp; Displays 1
      </code>
    </example>
  </difference>
  <displaypath>
    <summary>
      Truncates long path expressions to a specified length for display.
    </summary>
    <param name="cFileName">

      Specifies the name of the file at the end of the target path. If you specify a string containing only spaces as cFileName, X# returns the current directory. If you specify an empty string as cFileName, DISPLAYPATH( ) returns an empty string. You can obtain the path of the current directory by using the CURDIR( ).
      This function does not check the validity of cFileName and will report the truncated path expression even if no such file exists.

    </param>
    <param name="nMaxLength">

      Specifies the maximum length of the truncated result. nMaxLength must be greater than or equal to 10 and less than or equal to 260
      Character data type. DisplayPath( ) returns a string and displays the path in lower case.
    </param>
    <remarks>
      DisplayPath( ) returns a string suitable only for display purposes, so you cannot use the result to reference a file. The length of the resulting string is equal to or less than nMaxLength. However, the result does not break directory names. If inclusion of a directory name would exceed nMaxLength, the result is an ellipsis (...). If the filename exceeds nMaxLength, the result is the filename plus extension.
    </remarks>
  </displaypath>
  <dmy>
    <summary>
      Returns a character expression in day-month-year format (for example, 31 May 1998) from a Date or DateTime expression. The month name isn't abbreviated.
    </summary>
    <param name="dExpression">

      Specifies the Date expression from which <b>DMY( )</b> returns a character string in day-month-year format.

    </param>
    <param name="tExpression">

      Specifies the DateTime expression from which <b>DMY( )</b> returns a character string in day-month-year format.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      If SET CENTURY is OFF, <b>DMY( )</b> returns a character string in a dd-Month-yy format (for example, 16 February 98). If SET CENTURY is ON, the format is dd-Month-yyyy (for example, 16 February 1998).
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        SET CENTURY OFF
        ? DMY(DATE( ))
        SET CENTURY ON
        ? DMY(DATE( ))
      </code>
    </example>
  </dmy>
  <drivetype>
    <summary>
      Returns the type of the specified drive.
    </summary>
    <param name="cDrive">

      The drive designator. The colon in drive names (for example, "C:") is optional.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The following table explains the number DRIVETYPE( ) returns and the corresponding drive type description.
      1
      No type
      2
      Floppy disk
      3
      Hard disk
      4
      Removable drive or network drive
      5
      CD-ROM
      6
      RAM disk1
      1 Because there are many different types of RAM disks, you might get inconsistent return results.
    </remarks>
  </drivetype>
  <dropoffline>
    <summary>
      Discards all changes made to an offline view and takes the offline view back online.
    </summary>
    <param name="cViewName">

      Specifies the name of the offline view to take back online.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      DROPOFFLINE( ) returns a logical true (.T.) if the offline view is successfully taken back online; otherwise it returns false (.F.).
    </remarks>
  </dropoffline>
  <evl>
    <summary>
      Returns a non-empty value from two expressions.
      You can use the <b>EVL( )</b> function to return an appropriate substitute value instead of an empty value, such as False (.F.) or 0, from two expressions. You can also use this functionality to remove empty values from calculations or operations where empty values are not supported or relevant.
      The X# <b>Logical</b> value, False (.F.), and the <b>Numeric</b> value of 0 also evaluate to empty.
    </summary>
    <returns>
      Character, Date, DateTime, Numeric, Currency, Logical, Object. <b>EVL( )</b> returns eExpression1 if it does not evaluate to an empty value; otherwise, it returns eExpresssion2.
    </returns>
    <example>
      The following examples create the memory variables, codeglEmptyDate/code, which contains an empty <b>Date</b> value, and codeglEmptyNum/code, which contains an empty <b>Numeric</b> value, 0.
      When performing <b>EVL( )</b> with codeglEmptyDate/code, <b>EVL( )</b> returns an empty string ("") when evaluating codeglEmptyDate/code and an empty string, and code"None"/code when evaluating codeglEmptyDate/code and code"None"/code.
       <code language="X#">
        STORE {  /  /  } TO glEmptyDate
        ? EVL(glEmptyDate,"")
        ? EVL(glEmptyDate, "None")
      </code>
      When performing EVL( ) with glEmptyNum, EVL( ) returns an empty string when evaluating glEmptyNum and an empty string, and "Empty" when evaluating glEmptyNum and "Empty".
       <code language="X#">
        STORE 0 TO glEmptyNum
        ? EVL(glEmptyNum,"")
        ? EVL(glEmptyNum, "Empty")
      </code>
    </example>
  </evl>
  <execscript>
    <summary>
      Enables you to run multiple lines of code from variables, tables, and other text at runtime.
    </summary>
    <param name="cExpression">
      Represents the text, a variable, type string, or memo to be executed as code.
    </param>
    <param name="eParameter1">
      Optional. Specify parameters passed to a script that has a parameter statement in first line.
    </param>
    <param name="eParameter1">
      Optional. Specify parameters passed to a script that has a parameter statement in first line.
    </param>

    <returns>
      The return value is the value returned by the script in cExpression. If the script returns no value, X# returns .T.
    </returns>
    <remarks>
      ExecScript( ), unlike macro expansion, provides the same effect as selecting several lines of code in the command window then pressing the Enter key.
    </remarks>
    <example>
       <code language="X#">?EXECSCRIPT("oForm=CreateObject('Form')"+CHR(13)+"?oForm.AutoCenter")</code>
    </example>
  </execscript>
  <field>
    <summary>
      Returns the name of a field, referenced by number, in a table.
    </summary>
    <param name="nFieldNumber">

      Specifies the field number. If nFieldNumber is 1, the name of the first field in the table is returned; if nFieldNumber is 2, the name of the second field is returned, and so on. The empty string is returned if nFieldNumber is greater than the number of fields. Field names are returned in upper case.

    </param>
    <param name="cFieldName">

      Specifies the name of a field. This is used primarily to retrieve the actual field caption as stored in a database container (DBC) when used with the nFlags parameter.
      If the field caption is an expression (=), the expression is evaluated. Otherwise, the actual string literal is returned. If the expression cannot be evaluated at run time, an error is raised, and the actual field name is returned.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table for which <b>FIELD( )</b> returns field names.
      <b>FIELD( )</b> returns the empty string if a table is not open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which <b>FIELD( )</b> returns field names.
      X# generates an error message if you specify a table alias that does not exist.

    </param>
    <param name="nFlags">

      Specifies whether the actual field name or field caption is returned.
      nFlags
      0
      Return actual field name.
      <b>FIELD( )</b> preserves the case of the returned field name, as long as the table is stored in a DBC.
      1
      Return field caption. If the field caption is an expression, return its evaluated value.
    </param>
    <returns>
      Character data type. If you omit the optional arguments, <b>FIELD( )</b> returns the names of the fields in the table open in the currently selected work area.
    </returns>
    <remarks>
      You can use the <b>SELECT( )</b> function to determine the current work area for nWorkArea. You can use the <b>ALIAS( )</b> function to determine the alias of the table in the current work area for cTableAlias. For more information, see SELECT( ) Function and ALIAS( ) Function.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        CLEAR
        FOR gnCount = 1 TO FCOUNT( )  &amp;&amp; Loop for number of fields
        ? FIELD(gnCount)  &amp;&amp; Display each field
        NEXT
        ?
        ? 'Number of fields: ' + ALLTRIM(STR(gnCount -1))
      </code>
    </example>
  </field>
  <filetostr>
    <summary>
      Returns the contents of a file as a character string.
    </summary>
    <param name="cFileName">

      Specifies the name of the file whose contents are returned as a character string. If the file is in a directory other than the current default directory, include a path with the file name.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Note that the size of the character string FILETOSTR( ) returns can be very large. The amount of available memory or disk space determines if you can store the character string to a memory variable, array element, or memo field. Also, character fields in X# are limited to 254 characters. See X# System Capacities for more information about limitations on character type data.
    </remarks>
    <example>
       <code language="X#">
        CD HOME()
        cRedist=FILETOSTR("REDIST.TXT")
        ?OCCURS(".MSM",cRedist)
      </code>
    </example>
  </filetostr>
  <filter>
    <summary>
      Returns the table filter expression specified in SET FILTER.
    </summary>
    <param name="nWorkArea">

      Specifies the work area of the table for which FILTER( ) returns the filter expression.
      FILTER( ) returns the empty string if a table isn't open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which FILTER( ) returns the filter expression.
      X# generates an error message if you specify a table alias that doesn't exist.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      If you omit the optional arguments, FILTER( ) returns the filter expression for the table open in the currently selected work area. For more information about creating a filter, see SET FILTER.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        SET TALK ON
        SET FILTER TO SUBSTR(cust_id,1) = 'B'
        CLEAR
        ? FILTER( )  &amp;&amp; Display filter expression
        STORE FILTER('customer') TO gcOldFilter    &amp;&amp; Save filter expression
        SET FILTER TO country = 'USA'
        ? FILTER( )  &amp;&amp; Display filter expression
        SET FILTER TO &amp;gcOldFilter    &amp;&amp; Restore filter expression
        ? FILTER( )  &amp;&amp; Display filter expression
        LIST FIELDS cust_id, contact  &amp;&amp; Demonstrate filter condition
      </code>
    </example>
  </filter>
  <fldlist>
    <summary>
      Included for compatibility with dBASE.
       
    </summary>
  </fldlist>
  <fontmetric>
    <summary>
      Returns font attributes for the current installed operating system fonts.
    </summary>
    <param name="nAttribute">

      Determines the font attribute FONTMETRIC( ) returns. If you omit cFontName, nFontSize, and cFontStyle, FONTMETRIC( ) returns the attribute for the current font in the active output window.
      The following table lists values for nAttribute and the corresponding font attributes returned.
      NAttribute
      1
      Character height in pixels
      2
      Character ascent (units above baseline) in pixels
      3
      Character descent (units below baseline) in pixels
      4
      Leading (space between lines) in pixels
      5
      Extra leading in pixels
      6
      Average character width in pixels
      7
      Maximum character width in pixels
      8
      Font weight.
      9
      Italic (0 = no, nonzero = yes)
      10
      Underlined (0 = no, nonzero = yes)
      11
      Strikeout (0 = no, nonzero = yes)
      12
      First character defined in font
      13
      Last character defined in font
      14
      Default character (substituted for characters not in font)
      15
      Word-break character
      16
      Pitch and family
      17
      Character set
      18
      Overhang (extra added width)
      19
      Horizontal aspect for font device
      20
      Vertical aspect for font device
      For more information about the numeric values returned by FONTMETRIC( ), see the TEXTMETRIC function in the Microsoft Windows Programmer's Reference.

    </param>
    <param name="cFontName">

      Specifies the name of an installed font.

    </param>
    <param name="nFontSize">

      Specifies the point size of the font specified with cFontName.

    </param>
    <param name="cFontStyle">

      Specifies a font style code for the font specified with cFontName. If you omit cFontStyle, FONTMETRIC( ) returns the attribute for the Normal font style.
      cFontStyle can be a character or a combination of characters listed in the following font style table. For example, the combination BI specifies the Bold Italic font style.
      Outline
      Q
      Opaque
      Shadow
      –
      Strikeout
      Transparent
      U
      Underline
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      FONTMETRIC( ) returns font attributes for the current font for the active output window. WFONT( ) can be used to determine the current window font.
    </remarks>
  </fontmetric>
  <for>
    <summary>
      Returns the index filter expression, in uppercase, of an open single-entry index (.idx) file or an index tag.
    </summary>
    <param name="nIndexNumber">

      Specifies the index file or tag for which the filter expression is returned. <b>FOR( )</b> returns filter expressions in the following order as nIndexNumber increases from 1 to the total number of open single-entry files and structural compound and independent compound index tags:
      Filter expressions from single-entry index files (if any are open) are returned first. The order the single-entry index files are included in USE or SET INDEX determines the order in which the filter expressions are returned.
      Filter expressions for each tag in the structural compound index (if one is present) are returned next. The filter expressions are returned from the tags in the order the tags are created in the structural index.
      Filter expressions for each tag in any open independent compound indexes are returned last. The filter expressions are returned from the tags in the order in which the tags are created in the independent compound indexes.
      The empty string is returned if an index or index tag is created without a FOR clause or if nIndexNumber is greater than the total number of open single-entry files and structural compound and independent compound index tags.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table for which <b>FOR( )</b> returns the index filter expressions.
      <b>FOR( )</b> returns the empty string if a table isn't open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which <b>FOR( )</b> returns the index filter expressions.
      X# generates an error message if you specify a table alias that doesn't exist.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      If you don't include any of the optional arguments, <b>FOR( )</b> returns the index filter expression for the master index file or index tag. If a master index file or index tag isn't in effect (for example, you've issued <b>SET ORDER TO</b> to place the table in physical record order), <b>FOR( )</b> returns the empty string.
      You can create filtered indexes in X#. If you include the optional FOR lExpression clause in INDEX, the index file acts as a filter on the table. Only records that match the filter expression lExpression are available for display and access. Index keys are created in the index file for just those records matching the filter expression.

      <b>USE</b> and <b>SET INDEX</b> both support an index file name list that makes it possible for you to open multiple index files for a table. Any combination of single-entry index file names, structural compound, or independent compound index file names can be included in the index file name list. <b>FOR( )</b> is similar to SYS(2021) and is provided for compatibility with dBASE IV.
    </remarks>
  </for>
  <fullpath>
    <summary>
      Returns the path to a specified file or the path relative to another file.
    </summary>
    <param name="cFileName1">

      Specifies the file for which X# searches.
      Be sure to include the file name extension.
      If the file is located in the X# path, the path is returned with the file name. You can specify the X# path using the SET PATH command.
      If the file cannot be located in the X# path, FULLPATH( ) returns the current directory the path and file name as if the file was located in the current default directory.

    </param>
    <param name="nMSDOSPath">

      Specifies to search the MS-DOS path instead of the X# path. nMSDOSPath can have any numeric value.
      If the file cannot be located in the MS-DOS path, FULLPATH( ) returns the path and the file name as if the file was located in the current default directory.

    </param>
    <param name="cFileName2">

      Specifies a second file name to search for.
      Be sure to include the file name extension.
      FULLPATH( ) returns the path for the first file relative to the second file.
    </param>
    <returns>
      Character. FULLPATH( ) returns a file path.
    </returns>
    <remarks>
      Use the <b>FILE( )</b> function to verify that the file actually exists; otherwise, if the file does not exist, the function returns the file name with the current directory.
    </remarks>
  </fullpath>
  <fv>
    <summary>
      Returns the future value of a financial investment.
    </summary>
    <param name="nPayment">

      Specifies the constant periodic payment (which can be negative or positive).

    </param>
    <param name="nInterestRate">

      Specifies the periodic interest rate. If the interest rate is annual but the payments are made monthly, divide the annual interest rate by 12.

    </param>
    <param name="nPeriods">

      Specifies the number of periods over which payments are made. FV( ) assumes that the periodic payments are made at the end of each period.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      FV( ) computes the future value of a series of constant periodic payments earning fixed compound interest. The future value is the total of all payments and the interest.
    </remarks>
    <example>
       <code language="X#">
        STORE 500 TO gnPayment  &amp;&amp; Monthly payment
        STORE .075/12 TO gnInterest     &amp;&amp; 7.5% annual interest rate
        STORE 48 TO gnPeriods  &amp;&amp; Four years (48 months)
        CLEAR
        ? FV(gnPayment, gnInterest, gnPeriods)    &amp;&amp; Displays 27887.93
      </code>
    </example>
  </fv>
  <getautoincvalue>
    <summary>
      Returns the last value generated for an autoincremented field within a data session.
    </summary>
    <param name="nDataSessionNumber">

      Specifies the data session number of the data session for which the autoincremented field value is returned.
      The autoincremented field value is returned for the current data session if you omit the nDataSessionNumber and 0 parameters.
      Use SET DATASESSION to activate a specific data session.

    </param>
    <param name="0">

      Specifies that the last autoincremented field value returned is derived from the current scope (function, method, procedure). Use this to prevent events outside of that current code block, such as ON KEY LABEL, from executing code that could alter the value unexpectedly.
    </param>
    <returns>
      Numeric data type. The value returned by GETAUTOINCVALUE( ) is the last autoincrement value generated, even if a field was not successfully updated with the autoincrement value. .NULL. is returned if an autoincrement value hasn't yet been generated for a data session. For example, .NULL. is returned if a data session is opened and no updates have occurred.
    </returns>
    <remarks>
      The autoincremented field value is updated for table operations such as APPEND Command, INSERT Command, APPEND FROM Command, and BLANK Command when the AUTOINC option is included. See Autoincrementing Field Values in Tables for more information about autoincrementing fields.
    </remarks>
  </getautoincvalue>
  <getbar>
    <summary>
      Returns the number of an item on a menu defined with DEFINE POPUP or the X# system menu.
    </summary>
    <param name="MenuItemName">

      Specifies the menu item.

    </param>
    <param name="nMenuPosition">

      Specifies a position on the menu. nMenuPosition can range from 1 through the number of items within the menu. 1 corresponds to the first item on the menu, 2 to the second item, and so on.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      Use GETBAR( ) to determine which item occupies a specific position on a menu. This function is useful when items on a menu are added, removed, or rearranged. Use DEFINE BAR to add an item to a menu or RELEASE BAR to remove an item. The position of items in a menu can be changed if MOVER is included when the menu is created with DEFINE POPUP.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ON KEY LABEL CTRL+Z DO showorder
        WAIT WINDOW "Press CTRL+Z to refresh." NOWAIT
        DEFINE POPUP popDemo MOVER FROM 2,2
        DEFINE BAR 1 OF popDemo PROMPT 'One'
        DEFINE BAR 2 OF popDemo PROMPT 'Two'
        DEFINE BAR 3 OF popDemo PROMPT 'Three'
        DEFINE BAR 4 OF popDemo PROMPT 'Four'
        DO showorder
        ACTIVATE POPUP popDemo
        PROCEDURE showorder
        CLEAR
        @ 3,12 SAY  '1 ' + PRMBAR('popDemo', GETBAR('popDemo',1))
        @ 4,12 SAY  '2 ' + PRMBAR('popDemo', GETBAR('popDemo',2))
        @ 5,12 SAY  '3 ' + PRMBAR('popDemo', GETBAR('popDemo',3))
        @ 6,12 SAY  '4 ' + PRMBAR('popDemo', GETBAR('popDemo',4))
        RETURN
      </code>
    </example>
  </getbar>
  <getcolor>
    <summary>
      Displays the Windows Color dialog box and returns the color number of the chosen color.
    </summary>
    <param name="nDefaultColorNumber">

      Specifies the color that is initially selected when the Color dialog box is displayed. If nDefaultColorNumber doesn't correspond to a color in the Color dialog box, the first color in the Color dialog box is selected. If you omit nDefaultColorNumber, black is selected.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      GETCOLOR( ) returns – 1 if you exit the Color dialog box by pressing ESC, choosing the Cancel button, or choosing Close from the Control menu.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? GETCOLOR(255)
      </code>
    </example>
  </getcolor>
  <getcp>
    <summary>
      Prompts for a code page by displaying the Code Page dialog box, and then returns the number of the code page chosen.
    </summary>
    <param name="nCodePage">

      Specifies the number of the code page that is initially selected when the Code Page dialog box is displayed. If nCodePage is 0 or if you omit nCodePage, a code page isn't selected when the Code Page dialog box is displayed.

    </param>
    <param name="cText">

      Specifies the text displayed in the Code Page dialog box. If you omit cText, X# displays the following text: "Please select a code page for cross-platform data sharing."

    </param>
    <param name="cDialogTitle">

      Specifies the title that appears in the Code Page dialog box title bar. If you omit cDialogTitle, the title "Code Page" is displayed.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      GETCP( ) returns 0 if you exit the Code Page dialog box by pressing ESC, choosing the Cancel button, or choosing Close from the Control menu.
      The code pages listed in the Code Page dialog box are determined by FOXPRO.INT, the X# International code page support file.
      You can include GETCP( ) in commands such as MODIFY COMMAND, APPEND FROM, and COPY TO that support the AS nCodePage clause. The Code Page dialog box is displayed, making it possible for you to specify the code page of the file opened, appended, or created. Because no code page 0 exists, you must trap for 0 in case the user chooses ESC, the Cancel button, or Close from the Control menu.
    </remarks>
    <example>
       <code language="X#">? GETCP(1252, "Select a Code Page", "Code Page Selection")</code>
    </example>
  </getcp>
  <getcursoradapter>
    <summary>
      Returns an object reference to a <b>CursorAdapter</b> object at run time by referencing the cursor name.
    </summary>
    <param name="cAlias">

      Specifies the alias of the cursor. If you do not supply an alias, X# uses the alias for the cursor in the current work area.
    </param>
    <returns>
      An object reference to a <b>CursorAdapter</b> object.
    </returns>
    <remarks>
      Applies To: CursorAdapter Class
    </remarks>
  </getcursoradapter>
  <getdir>
    <summary>
      Displays the Select Directory dialog box from which you can choose a directory.
    </summary>
    <param name="cDirectory">

      Specifies the directory that is initially displayed in the dialog box. When cDirectory is not specified, the dialog box opens with the X# default directory displayed.

    </param>
    <param name="cText">

      Specifies the text for the directory list in the dialog box.

    </param>
    <param name="cCaption">

      Specifies the caption to display in the dialog title bar. The Windows default is "Select Directory".

    </param>
    <param name="nFlags">

      Specify the options for the dialog box. nFlags can include zero or an additive combination of the values. The following table includes some of more common flags. For more information, see SHBrowseForFolder in MSDN.
      1
      BIF_RETURNONLYFSDIRS
      Return only file system directories (physical locations). If a user selects folders that are not part of the file system, the OK button is grayed.
      2
      BIF_DONTGOBELOWDOMAIN
      Do not include network folders below the domain level in the tree view control (For example, My Computer and My Networks).
      8
      BIF_RETURNFSANCESTORS
      Return only file system ancestors. If a user selects anything other than a file system ancestor, the OK button is grayed.
      16
      BIF_EDITBOX
      The browse dialog includes an edit control in which the user can type the name of an item. Available on Windows 98 and above, or with Internet Explorer 4.0 or higher (assuming shell integration option selected). Requires version 4.71 of shell32.dll.
      BIF_VALIDATE
      Validates the editbox contents. If the editbox is used, it is necessary to validate the user-specified content. If the user types an invalid name into the edit box, the Cancel button becomes the only selection available. This flag is ignored if BIF_EDITBOX is not specified.
      64
      BIF_NEWDIALOGSTYLE
      Use the new user-interface. Setting this flag provides the user with a larger, resizable dialog box. Additional functionality includes: drag and drop capability within the dialog box, reordering, context menus, new folders, delete, and other context menu commands. Support in Windows 2000 and above. Requires version 5.00 of shell32.dll.
      16384
      BIF_BROWSEINCLUDEFILES
      The browse dialog will display files as well as folders. Available on Windows 98 and above, or with Internet Explorer 4.0 or higher (assuming shell integration option selected). Requires version 4.71 of shell32.dll.

    </param>
    <param name="lRootOnly">

      Specifies that only cDirectory and its subfolders display. This parameter prevents navigation above the root folder. If you do not specify cDirectory, the default directory (SET DEFAULT value) is used.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      GETDIR( ) returns as a character string the name of the directory you choose.
      If you do not choose a directory (you click Cancel, press ESC, or choose Close from the window menu), GETDIR( ) returns the empty string.
      Beginning with X# 7, GETDIR( ) supports two different dialog boxes. If you provide fewer than three parameters, GETDIR( ) returns the dialog box from earlier versions. If you provide more than two parameters, X# uses the <b>SHBrowseForFolder </b>routine from the Win32 API to provide the dialog.
    </remarks>
  </getdir>
  <getfile>
    <summary>
      Displays the Open dialog box.
    </summary>
    <param name="cFileExtensions">

      Specifies the file name extensions for the files to display in the Open dialog box when the All Files type is not chosen. When passing a value as a literal, enclose it with quotation marks (""). Do not include a period (.) in front of file name extensions.
      The cFileExtensions parameter cannot exceed 254 characters in length.
      cFileExtensions can take a variety of forms:
      If cFileExtensions contains a single extension, for example, "prg", the Open dialog box displays only those file names with that extension.
      If cFileExtensions is the empty string, the Open dialog box displays all files in the current directory.
      cFileExtensions can contain wildcard characters such as * and ?. The Open dialog box displays all file names with extensions that meet the wildcard criteria. For example, if cFileExtensions is "?X?", the Open dialog box displays all file names with the extension .fxp, .exe, and .txt.
      cFileExtensions can contain a file description followed by a file extension or a list of file extensions separated with commas. The file description appears in the Open dialog box in the Files of Type list. Separate the file description from the file extension or list of file extensions with a colon (:). Separate multiple file descriptions and their file extensions with a semicolon (;).
      For example, if cFileExtensions is "Text:TXT", the Open dialog box displays the file description "Text" in the Files of Type list and displays all files with a .txt extension.
      If cFileExtensions is "Tables:DBF; Files:TXT,BAK" the file descriptions "Tables" and "Files" appear in the Files of Type list. When "Tables" is chosen from the Files of Type list, all files with a .dbf extension are displayed. When "Files" is chosen from the Files of Type list, all files with .txt and .bak extensions are displayed.
      If cFileExtensions contains just a semicolon (";"), the Open dialog box displays all files without extensions.

    </param>
    <param name="cText">

      Specifies text to display for the File Name label in the Open dialog box.

    </param>
    <param name="cOpenButtonCaption">

      Specifies a caption for the OK button in the Open dialog box.

    </param>
    <param name="nButtonType">

      Specifies the number and type of buttons that appear in the Open dialog box. The following table lists the values for nButtonType.
      0 (or omitted)
      OK, Cancel
      1
      OK, New, Cancel
      2
      OK, None, Cancel
      GETFILE( ) returns the string "Untitled" with the path specified in the Open dialog box when nButtonType is set to 1 and the user clicks New, or when nButtonType is set to 2 and the user clicks None.

    </param>
    <param name="cTitleBarCaption">

      Specifies the caption for the title bar of the Open dialog box.
    </param>
    <returns>
      Character. GETFILE( ) returns the name of the file chosen in the Open dialog box or the empty string if the user closes the Open dialog box by pressing ESC, clicking Cancel or the Close button on the Open dialog box.
    </returns>
    <example>
       <code language="X#">
        CLOSE DATABASES
        SELECT 0
        gcTable=GETFILE('DBF', 'Browse or Create a .DBF:',
        'Browse', 1, 'Browse or Create')
        DO CASE
        CASE 'Untitled' $ gcTable
        CREATE (gcTable)
        CASE EMPTY(gcTable)
        RETURN
        OTHERWISE
        USE (gcTable)
        BROWSE
        ENDCASE
      </code>
    </example>
  </getfile>
  <getfldstate>
    <summary>
      Returns a numeric value indicating if a field in a table or cursor has been modified or had a record appended, or if the deleted status of the current record has been changed.
    </summary>
    <param name="cTableAlias">

      Specifies the alias of the table or cursor for which the field modification or record deletion status is returned.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor for which the field modification or record deletion status is returned.
      If you do not specify an alias or work area, GETFLDSTATE( ) returns a value for a field in the currently selected table or cursor.
    </param>
    <returns>
      Numeric, Character, or .NULL.
    </returns>
    <remarks>
      The following table lists the character return values and the corresponding modification or deletion status.
      1
      Field has not been modified or deletion status has not changed.
      2
      Field has been modified or deletion status has changed.
      3
      Field in an appended record has not been modified or deletion status has not changed for the appended record.
      4
      Field in an appended record has been modified or deletion status has changed for the appended record.
      .NULL.
      At EOF( )
      Row or table buffering must first be enabled with CURSORSETPROP( ) for GETFLDSTATE( ) to operate on local tables.
      The modification or deletion status is returned for the table or cursor open in the currently selected work area if GETFLDSTATE( ) is issued without the optional cTableAlias or nWorkArea arguments.
      Any change in a field will cause GETFLDSTATE() to return a value showing that the field has been modified, whether the change is explicit or implicit. An example of an explicit modification would be including the field in a REPLACE or INSERT INTO command. An implicit modification occurs in a field that has a default value when any command is issued that adds a new record.
      The following example demonstrates how you can use GETFLDSTATE( ) to determine if the contents of a field have changed. MULTILOCKS is set to ON, a requirement for table buffering. The codecustomer/code table in the codetestdata/code database is opened, and CURSORSETPROP( ) is then used to set the buffering mode to optimistic table buffering (5).
      GETFLDSTATE( ) is issued to display a value (1) corresponding to the unmodified state of the codecust_id/code field before it is modified. The codecust_id/code field is modified with REPLACE, and GETFLDSTATE( ) is issued again to display a value (2) corresponding to the modified state of the codecust_id/code field. TABLEREVERT( ) is used to return the table to its original state, and GETFLDSTATE( ) is issued again to display a value (1) corresponding to the original state of the codecust_id/code field.
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        SET MULTILOCKS ON         &amp;&amp; Allow table buffering
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE Customer             &amp;&amp; Open customer table
        =CURSORSETPROP("Buffering",5,"customer")  &amp;&amp; Enable table buffering
        * Get field state on original cust_id field and display state
        nState=<b>GETFLDSTATE(</b>"cust_id"<b>)</b>
        DO DisplayState WITH nState, "Original"
        * Change field contents and display state
        REPLACE cust_id    WITH "***"
        nState=<b>GETFLDSTATE(</b>"cust_id"<b>)</b>
        DO DisplayState WITH nState, "After Replace"
        * Discard table changes and display state
        = TABLEREVERT(.T.)        &amp;&amp; Discard all table changes
        nState=<b>GETFLDSTATE(</b>"cust_id"<b>)</b>
        DO DisplayState WITH nState, "After Revert"
        PROCEDURE DisplayState
        PARAMETER nState,cOperation
        DO CASE
        CASE nState=1
        =MESSAGEBOX("Field has not been modified",0,cOperation)
        OTHERWISE
        =MESSAGEBOX("Field has been modified",0,cOperation)
        ENDCASE
      </code>
      The following example shows the difference in behavior between fields with and without default values.
       <code language="X#">
        SET MULTILOCKS ON
        CREATE DATABASE example
        CREATE TABLE customer (cust_id C(6),state C(2) DEFAULT "FL")
        CLOSE TABLES
        USE customer
        =CURSORSETPROP("Buffering",5,"customer")
        APPEND BLANK
        ?GETFLDSTATE("cust_id")     &amp;&amp; Returns 3, field in an appended record has
        &amp;&amp; not been modified.
        ?GETFLDSTATE("state")    &amp;&amp; Returns 4, field in an appended record has
        &amp;&amp; been modified.
      </code>
    </remarks>
  </getfldstate>
  <getfont>
    <summary>
      Displays the Font dialog box and returns information about the font you choose.
    </summary>
    <param name="cFontName">

      Specifies the name of the font initially selected in the Font dialog box. If the font you specify is not installed, the default font is selected initially.

    </param>
    <param name="nFontSize">

      Specifies the font size selected initially in the Font dialog box. If the font size you specify is not supported, the default font size is selected initially. If you omit nFontSize or if nFontSize is less than or equal to zero, the font size selected defaults to 10 point.
      The dialog box permits you to select sizes between code4/code and code127/code, inclusive. You can specify other values for nFontSize when calling the <b>GETFONT</b> function; no error occurs.  If you do so, however, the user must select a size within the designated range of values before clicking <b>OK</b> in the dialog box.  Otherwise, the dialog box displays an alert and does not accept the value.

    </param>
    <param name="cFontStyle">

      Specifies the font style selected initially in the Font dialog box or to display only those fonts available on the selected printer. If the font style you specify is not supported, the default font style is selected initially.
      The following table lists the values available for cFontStyle.
      B
      Select Bold font style initially.
      Select Italic font style initially.
      BI
      Select Bold Italic font style initially.
      P
      Display only those fonts available on the current default printer.

    </param>
    <param name="nFontCharSet">

      Specifies a value for the language script. The values you can specify differ depending on your version of Windows.
      Omitting this value disables the script drop-down list in the dialog box.
      The following table describes some example values for nFontCharSet.
      nFontCharSet
      0
      Western
      1
      Default
      2
      Symbol
      128
      Japanese
      161
      Greek
      162
      Turkish
      163
      Vietnamese
      177
      Hebrew
      178
      Arabic
      186
      Baltic
      204
      Cyrillic
      238
      Central European
      If you specify 1 for nFontCharSet, the dialog box that <b>GETFONT( )</b> opened displays the default language script on the operating system. <b>GETFONT( )</b> never returns 1 because it returns the value for the language script selected in the <b>GETFONT( )</b> dialog box.
      For more information, see FontCharSet Property.
    </param>
    <returns>
      Character. <b>GETFONT( )</b> returns one of the following, depending on certain conditions:
      A character string containing three types of font information with commas separating the items returned: font name, size and style.  This behavior occurs when you choose one in the Font dialog box and you have not included the fourth optional argument when calling the <b>GETFONT( )</b> function.
      A character string containing four types of font information with commas separating the items returned: font name, size, style and language script.  This behavior occurs if you include a value for the nFontCharSet parameter.
      In versions of X# previous to X# 9.0, if you included a value of code0/code as the fourth argument to <b>GETFONT()</b>, you received the same return information as if you did not include the fourth argument at all.  The script drop-down list was not enabled, and the return value contained only three types of font information. In X# 9.0, a value of code0/code explicitly indicates the numeric value corresponding to Western script.  The script drop-down list might also initially display Western if you specify code1/code for this value, but only if Western is the default script for your regional settings.
      An empty string if you exit the Font dialog box by clicking <b>Cancel</b>, <b>Close</b> on the Control menu, or pressing the <b>ESC</b> key.
    </returns>
    <remarks>
      You can abbreviate some X# commands and functions to four characters when conflicts with other commands and functions do not exist. In the case of <b>GETFONT( )</b> and <b>GETFILE( )</b>, which both begin with the same four letters, precedence is given to <b>GETFILE( )</b>; therefore, issuing codeGETF( )/code displays the <b>Open</b> dialog box.
    </remarks>
    <example>
       <code language="X#">
        * Invoke the dialog with script drop-down list disabled:
        ? GETFONT("Arial",12,"B") &amp;&amp; press OK in the dialog box
        * return value is the string:
        * "Arial,12,B"
        * Enable the script drop-down list, Western script selected:
        ? GETFONT("Arial",12,"B",0) &amp;&amp; press OK after selections
        * sample return value is the string:
        * "Verdana,16,N,161"
        * Return from the dialog box without making a selection:
        ? GETFONT("Arial",12,"B") &amp;&amp; press Cancel in the dialog box
        * return value is an empty string
        ? GETFONT("Arial",12,"B",0) &amp;&amp; press Cancel in the dialog box
        * return value is still an empty string
      </code>
    </example>
  </getfont>
  <getnextmodified>
    <summary>
      Returns the record number for the next modified record in a buffered table or cursor.
    </summary>
    <param name="nRecordNumber">

      Specifies the record number after which <b>GETNEXTMODIFIED( )</b> searches for the next modified record. Specify 0 for nRecordNumber to determine the first record in the table or cursor that has been modified.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table or cursor for which <b>GETNEXTMODIFIED( )</b> returns the number of the next modified record.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor for which <b>GETNEXTMODIFIED( )</b> returns the number of the next modified record.
      If you do not specify an alias or work area, <b>GETNEXTMODIFIED( )</b> returns the record number for the next modified record in the currently selected table or cursor.

    </param>
    <param name="lNoFire">

      Specifies that all firing of rules are suppressed.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>GETNEXTMODIFIED( )</b> returns 0 if there are no modified records after the record you specify. Because of this, if you modify only one record, to verify its modification you must first use the <b>GO TOP</b> command to position the cursor before the changed record. A record is considered modified if the contents of any of its fields are changed in any way (even if the original field contents are restored) or the record's deletion status is changed.

      <b>GETNEXTMODIFIED( )</b> can operate only on tables and cursors for which table buffering is enabled. Table buffering is enabled with <b>CURSORSETPROP( )</b>.
      Since triggers are unaffected by <b>GETNEXTMODIFIED( )</b>, lNoFire suppresses only field and record rules, and the "Uniqueness of index ID is violated" error. lNoFire prevents the flushing of temporary data, such as data stored in controls or updates made to the current record, to the underlying cursor.
    </remarks>
    <example>
       <code language="X#">
        LOCAL lnCurRec
        CLEAR
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE Customer
        * Enable table buffering.
        SET MULTILOCKS ON
        =CURSORSETPROP("Buffering", 5, "customer")
        * Increase MAXORDAMT by 10% for customers in Mexico.
        UPDATE Customer SET MaxOrdAmt=MaxOrdAmt * 1.1 WHERE Country = "Mexico"
        * Start with the first modified record.
        lnCurRec = <b>GETNEXTMODIFIED</b>(0)
        * DO until all modified records are processed.
        DO WHILE .T.
        * Move to the current modified record.
        GOTO (m.lnCurRec)
        * Process modified row here.
        ? Customer.Company, Customer.MaxOrdAmt
        IF Customer.MaxOrdAmt &gt; 8500
        =TABLEREVERT(.F.)
        ENDIF
        ?? Customer.MaxOrdAmt
        * Get the next modified record from here.
        lnCurRec = <b>GETNEXTMODIFIED</b>(m.lnCurRec)
        IF m.lnCurRec = 0 &amp;&amp; No more modified records.
        EXIT
        ENDIF
        ENDDO
        =TABLEREVERT(.T.)  &amp;&amp; Restore sample data and discard all changes.
      </code>
    </example>
  </getnextmodified>
  <getobject>
    <summary>
      Activates an Automation object and creates a reference to the object.
    </summary>
    <param name="cFileName">

      Specifies the full path and name of the file to activate. The application does not need to be specified, because the OLE dynamic link libraries determine the application to start based on the file name you provide.
      For example, the following code launches Microsoft Excel, opens a file named BUDGET.XLS, and creates a reference through an object variable named MBUDVAR:
       <code language="X#">MBUDVAR = GETOBJECT('C:\EXCEL\WORK\BUDGET.XLS')</code>
      Moniker
      The identifier of a COM object that implements the IMoniker interface. A moniker can be any of the following types: file, item, generic composite, anti-, pointer, and URL. For details about COM monikers, search for "IMoniker" on the Microsoft Developer Network.
    </param>
    <param name="cClassName">

      Specifies the class name of the object to retrieve. Some applications can store more than one object type in the same file, making it possible for you to use the class name to specify the object to activate. For example, if a word processing application stores its documents, macro definitions, and ToolBar objects in the same file, you can create a reference to the document file with the following command:
       <code language="X#">MDOCFILE = GETOBJECT('C:\WRDPROC\MYDOC.DOC','WrdProc.Document')</code>
      With some server applications, each time you issue <b>GETOBJECT( )</b>, an additional instance of the application is started, using additional memory. If the application is already running, you can prevent additional instances of the application from starting by omitting FileName and including ClassName, as in this example:
       <code language="X#">oleApp = GETOBJECT(, "Excel.Application")</code>
      Object reference
    </param>
    <remarks>
      Use <b>GETOBJECT( )</b> to activate an Automation object from a file and to assign a reference to the object through a memory variable or array element.
      If you specify an invalid file or class name, an OLE error is displayed, and the <b>GETOBJECT( )</b> function returns an empty string.
    </remarks>
    <example>
       <code language="X#">
        *  Replace "DomainName" with the domain name, and "UserLoginID"
        *  with the login ID of the user you are looking up.
        oUser = GetObject("WinNT://DomainName/UserLoginID,user")
        ? oUser.FullName
      </code>
    </example>
  </getobject>
  <getpict>
    <summary>
      Displays the Open Picture dialog box and returns the name of the picture file you chose.
      You can preview images in Windows 2000 and later by clicking the View Menu icon and then Thumbnails. X# uses the Thumbnails view as the default setting to provide mini-previews of images. Therefore, the Open Picture dialog box no longer includes a frame for displaying an image. The Preview check box appears in the Open Picture dialog box only when running X# on operating systems earlier than Windows 2000.
    </summary>
    <param name="cFileExtensions">

      Specifies the file extensions of the picture files displayed in the scrollable list when the All Files menu item isn't chosen.
      cFileExtensions can take the following forms:
      If cFileExtensions contains a single extension (for example, .bmp), only files with that extension are displayed.
      cFileExtensions can also contain wildcards (* and ?). All files with extensions that meet the wildcard criteria are displayed. For example, if cFileExtensions is ?X?, all files with the extension .fxp, .exe, and .txt are displayed.
      If cFileExtensions contains an empty string (""), all available graphics files (for example, files with the extensions .bmp and .dib ) are displayed.

    </param>
    <param name="CFileNameCaption">

      Specifies the caption displayed to the left of the File Name text box. cFileNameCaption replaces "File Name" that appears when cFileNameCaption is omitted.

    </param>
    <param name="cOpenButtonCaption">

      Specifies a caption for the OK button.
    </param>
    <returns>
      Character data type. Returns the name of the picture file you chose.
    </returns>
    <remarks>
      The GETPICT( ) function returns the empty string if you exit the Open Picture dialog box by pressing ESC, choosing the Cancel button, or clicking the Close button. The Open Picture dialog box displayed by typing <b>GETPICT( )</b> in the Command window makes it possible for you to quickly locate all the graphic files supported in X#. In versions earlier than X# 8.0, check the Preview check box in the Picture Open dialog box to display the currently selected graphics file.
      The following table lists the graphic file formats that X# supports.
      Animated Cursor
      .ani
      Bitmap
      .bmp
      Cursor
      .cur
      Device Independent Bitmap
      .dib
      Exchangeable Image File
      .exif
      Graphics Interchange Format
      .gif, .gfa
      Joint Photographic Electronic Group, JPEG File Interchange Format
      .jpg, .jpeg, .jpe, .jfif
      Icon
      .ico
      Portable Networks Graphics
      .png
      Tag Image File Format
      .tif, .tiff
      Windows Enhanced Metafile
      .emf
      In X#, cursor, animated cursor, and icon files can be used as graphics files. For example, you can specify an animated cursor file for the Picture property for the Image control (however, the Image control displays the static representation of the cursor).
      Use the CLEAR RESOURCES command to clear all cached graphic files, including .gif and .jpg files.
    </remarks>
  </getpict>
  <getprinter>
    <summary>
      Displays the Printer dialog box and returns the name of the selected printer.
    </summary>
    <returns>
      GETPRINTER( )Return Value
      Character. <b>GETPRINTER( )</b> returns the name of the selected printer. If you exit the Printer dialog box by pressing ESC or by clicking Cancel or Close, <b>GETPRINTER( )</b> returns an empty string.
    </returns>
    <remarks>
      The contents of the Printer dialog box can differ between versions of Windows. For example, the Printer dialog box might contain only the printer name or include a network path.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        cPrinter = GETPRINTER( )
        WAIT WINDOW IIF(EMPTY(cPrinter), 'No printer chosen', cPrinter)
      </code>
    </example>
  </getprinter>
  <getresultset>
    <summary>
      Retrieves the work area number of a cursor marked by <b>SETRESULTSET( )</b> in the current data session.
    </summary>
    <returns>
      GETRESULTSET( )Return Value
      Numeric. <b>GETRESULTSET( )</b> returns the work area number of the marked cursor in the current data session or zero (0) if no cursor is marked in the current data session.
    </returns>
    <remarks>

      <b>GETRESULTSET( )</b> is supported in X# and the X# OLE DB Provider. You can use <b>GETRESULTSET( )</b> in a database container (DBC) stored procedure or send it to the X# OLE DB Provider, assuming that the cursor has been previously opened by the OLE DB Provider.
    </remarks>
  </getresultset>
  <getwordcount>
    <summary>
      Counts the words in a string.
    </summary>
    <param name="cString">

      Specifies the string whose words will be counted.

    </param>
    <param name="cDelimiters">

      Optional. Specifies one or more optional characters used to separate words in cString. The default delimiters are space, tab, carriage return, and line feed. Note that <b>GetWordCount( )</b> uses each of the characters in cDelimiters as individual delimiters, not the entire string as a single delimiter.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>GetWordCount( )</b> by default assumes that words are delimited by spaces or tabs. If you specify another character as delimiter, this function ignores spaces and tabs and uses only the specified character.
      If you use "AAA aaa, BBB bbb, CCC ccc." as the target string for <b>GetWordCount( ),</b> you can get all the following results.
       <code language="X#">
        cString = "AAA aaa, BBB bbb, CCC ccc."
        ? GetWordCount(cString)               &amp;&amp; 6 - character groups, delimited by " "
        ? GetWordCount(cString, ",")               &amp;&amp; 3 - character groups, delimited by ","
        ? GetWordCount(cString, ".")               &amp;&amp; 1 - character group, delimited by "."
      </code>
    </remarks>
  </getwordcount>
  <getwordnum>
    <summary>
      Returns a specified word from a string.
    </summary>
    <param name="cString">
      Specifies the string to be evaluated
    </param>
    <param name="nIndex">
      Specifies the index position of the word to be returned. For example, if nIndex is 3, <b>GetWordNum( )</b> returns the third word (if cString contains three or more words).
    </param>
    <param name="cDelimiters">
      Optional. Specifies one or more optional characters used to separate words in cString. The default delimiters are space, tab, carriage return, and line feed. Note that <b>GetWordNum( )</b> uses each of the characters in cDelimiters as individual delimiters, not the entire string as a single delimiter.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Returns the word at the position specified by nIndex in the target string, cString. If cString contains fewer than nIndex words, <b>GetWordNum( )</b> returns an empty string.
    </remarks>
  </getwordnum>
  <gomonth>
    <summary>
      Returns the date that is a specified number of months before or after a given Date or Date/Time expression.
    </summary>
    <returns>
      Date
    </returns>
    <remarks>
      GOMONTH( ) does not support dates earlier than 1753.
    </remarks>
    <example>
       <code language="X#">
        SET CENTURY ON
        STORE GOMONTH({^1998-02-16}, 5) TO gdDeadLine
        CLEAR
        ? gdDeadLine  &amp;&amp; Displays 07/16/1998
        ? GOMONTH({^1998-12-31}, 2)  &amp;&amp; Displays 02/28/1999
        ? GOMONTH({^1998-12-31}, -2)  &amp;&amp; Displays 10/31/1998
      </code>
    </example>
  </gomonth>
  <idxcollate>
    <summary>
      Returns the collating sequence for an index or index tag.
    </summary>
    <param name="cCDXFileName">

      Specifies the name of the compound index file. The compound index file you specify can be the structural compound index file automatically opened with the table or an independent compound index file.

    </param>
    <param name="nIndexNumber">

      Specifies the index or index tag for which <b>IDXCOLLATE( )</b> returns the collating sequence. <b>IDXCOLLATE( )</b> returns the collating sequence for indexes and index tags in the following order as nIndexNumber increases from 1 to the total number of open index files and index tags:
      Collating sequences for single-entry .idx index files (if any are open) are returned first. The order in which the single-entry index files are included in <b>USE</b> or <b>SET INDEX</b> determines how the collating sequences are returned.
      Collation sequences for tags in the structural compound index (if one is present) are returned next. The collating sequences are returned for the tags in the order in which the tags are created in the structural compound index.
      Collating sequences for tags in any open independent compound indexes are returned last. The collation sequences are returned for the tags in the order in which the tags are created in the independent compound indexes.
      The empty string is returned if nIndexNumber is greater than the total number of open single-entry .idx files and structural compound and independent compound index tags.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table for which <b>IDXCOLLATE( )</b> returns index file and index tag collating sequences.
      <b>IDXCOLLATE( )</b> returns the empty string if a table isn't open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which <b>IDXCOLLATE( )</b> returns index file and index tag collation sequences.
      X# generates an error message if you specify a table alias that doesn't exist.
    </param>
    <returns>
      Character
    </returns>
    <remarks>

      <b>IDXCOLLATE( )</b> can be used to return the collating sequence for each tag in multiple-entry compound index files, allowing you to completely delete an index file and rebuild it correctly, using a series of <b>SET COLLATE</b> and <b>INDEX</b> commands.
      Note that IDXCOLLATE( ) is not required for the proper functioning of <b>REINDEX</b>, because the collation sequence information is present in existing indexes and index tags.
      For additional information about X#'s international support, see Developing International Applications.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE Customer     &amp;&amp; Open Customer table.
        CLEAR
        FOR nCount = 1 TO TAGCOUNT( )
        IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index.
        ? TAG(nCount) + ' '  &amp;&amp; Display tag name.
        ?? IDXCOLLATE(nCount)  &amp;&amp; Display collation sequence.
        ELSE
        EXIT  &amp;&amp; Exit the loop when no more tags are found.
        ENDIF
        ENDFOR
      </code>
    </example>
  </idxcollate>
  <imestatus>
    <summary>
      Turns the IME (Input Method Editor) window on or off or returns the current IME status.
    </summary>
    <param name="nExpression">

      Turns the IME window on or off. The following table lists the values for nExpression and the corresponding state of the IME window.
      0
      Turns the IME window off.
      1
      Turns the IME window on.
      If nExpression is omitted, <b>IMESTATUS( )</b> returns the current IME status. The following table lists the values returned for the IME status. Use VERSION(3) to determine the current locale.
      The following table lists the values returned for the IME status in the Japanese locale.
      No IME installed
      IME on
      IME off
      IME disabled
      Hiragana mode (double-byte)
      Katakana mode (double-byte)
      Katakana mode (single-byte)
      Alphanumeric mode (double-byte)
      8
      Alphanumeric mode (single-byte)
      The following table lists the values returned for the IME status in the Korean locale.
      Hangul mode (single-byte)
      English mode (single-byte)
      English mode (double-byte)
      Hangul mode (double-byte)
      Hanja conversion mode (Hangul + single-byte mode)
      31
      Hanja conversion mode (Hangul + double-byte mode)
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      For more information, see Developing International Applications.
      This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
    </remarks>
  </imestatus>
  <indbc>
    <summary>
      Returns true (.T.) if the specified database object is in the current database; otherwise returns false (.F.).
    </summary>
    <param name="cDatabaseObjectName">

      Specifies the name of a named connection, field, index, table, or SQL view for which INDBC( ) returns a logical value indicating whether or not the object is in the current database.

    </param>
    <param name="cType">

      Specifies the database object type of cDatabaseObjectName. The following table lists the values for cType and the corresponding database object type.
      CONNECTION
      Named connection
      FIELD
      Field
      INDEX
      Index
      TABLE
      Table
      VIEW
      SQL View
      The CONNECTION, FIELD, INDEX, TABLE, and VIEW settings cannot be abbreviated.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      A database must be open and current when <b>INDBC( )</b> is issued; otherwise X# generates an error message.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CREATE DATABASE mydbc  &amp;&amp; Creates a new database
        CREATE TABLE mytable (field1 C(10)) &amp;&amp; Automatically added to database
        ? 'MyTable in the database? '
        ?? INDBC('mytable', 'TABLE')  &amp;&amp; Returns .T.
        CLOSE DATABASES
        DELETE DATABASE mydbc DELETETABLES
      </code>
    </example>
  </indbc>
  <indexseek>
    <summary>
      Without moving the record pointer, searches an indexed table for the first occurrence of a record whose index key matches a specified expression.
    </summary>
    <param name="eExpression">

      Specifies the index key expression for which you want INDEXSEEK( ) to search.

    </param>
    <param name="lMovePointer">

      Specifies if the record pointer is moved to the matching record. If lMovePointer is true (.T.) and a matching record exists, the record pointer is moved to the matching record. If lMovePointer is true (.T.) and a matching record doesn't exist, the record pointer isn't moved. If lMovePointer is false (.F.) or is omitted, the record pointer isn't moved even if a matching record exists.

    </param>
    <param name="nWorkArea">

      Specifies the work area number of the table that is searched for the index key.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table that is searched. If you omit nWorkArea and cTableAlias, the table in the currently selected work area is searched.

    </param>
    <param name="nIndexNumber">

      Specifies the number of the index file or tag that is used to search for the index key. nIndexNumber refers to the index files as they are listed in USE or SET INDEX. Open .IDX files are numbered first in the order in which they appear in USE or SET INDEX. Tags in the structural .cdx file (if one exists) are then numbered in the order in which they were created. Finally, tags in any open independent .cdx files are numbered in the order in which they were created. For more information about index numbering, see SET ORDER.

    </param>
    <param name="cIDXIndexFileName">

      Specifies an .idx file that is used to search for the index key.

    </param>
    <param name="cTagName">

      Specifies a tag of a .cdx file that is used to search for the index key. The tag name can be from a structural .cdx file or any open independent .cdx file.
      The .idx file takes precedence if duplicate .idx file and tag names exist.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>INDEXSEEK( )</b> returns true (.T.) if a match is found; otherwise false (.F.) is returned. You can use <b>INDEXSEEK( )</b> only with a table with an index order set, and you can search only for an index key. The match must be exact unless <b>SET EXACT</b> is set to OFF.

      <b>INDEXSEEK( )</b> provides a fast way to search for records without moving the record pointer. Because the record pointer isn't moved, rules and triggers aren't executed. If <b>INDEXSEEK( )</b> returns true (.T.) indicating that a matching record is found, you can execute <b>INDEXSEEK( )</b> again with the second parameter lMovePointer set to true (.T.) to move to the matching record.

      <b>INDEXSEEK( )</b> returns false (.F.) when you are attempting to find a value in the most recently created record (created with <b>INSERT INTO</b> or <b>APPEND BLANK</b>) until the record pointer is moved. You can execute a <b>GO BOTTOM</b> command to cause <b>INDEXSEEK( )</b> to find the most recently created record.
    </remarks>
  </indexseek>
  <inputbox>
    <summary>
      Displays a modal dialog used by a parameterized view for input of a single string.
    </summary>
    <param name="cInputPrompt">

      Specifies the Prompt displayed above the text entry box.

    </param>
    <param name="cDialogCaption">

      Specifies the text to display in the title bar of the dialog box.

    </param>
    <param name="cDefaultValue">

      Specifies a default value to display in the text entry box.

    </param>
    <param name="nTimeout">

      Specifies a timeout value in 1/1000 seconds.
      Specify zero in nTimeout to prevent the dialog from timing out. This is identical to omitting nTimeout.

    </param>
    <param name="cTimeoutValue">

      Specifies value to return if a timeout occurs. cTimeoutValue isn't returned if nTimeout is set to zero or is omitted.

    </param>
    <param name="cCancelValue">

      Specifies a character value to return if the user exits the dialog box by choosing the <b>Cancel</b> button or pressing the Esc key.
    </param>
    <remarks>
      The dialog box displays an edit box and <b>OK</b> and <b>Cancel</b> buttons. The <b>OK</b> button returns the contents of the edit box. A timeout returns the text specified in cTimeoutValue or an empty string if cTimeoutValue is unspecified. The Cancel button or the Esc key returns the text specified in cCancelValue or an empty string if cCancelValue is unspecified.
       <code language="X#">
        Y = "Nothing at all"
        Y = INPUTBOX("TypeHere","Input ",Y,5000)
        &amp;&amp; Displays dialog box for 5 seconds,
      </code>
      The following example displays a dialog box for five seconds and displays the return value in the main X# window. If the user clicks OK, the edit box returns the text which is either the default value, "Nothing at all," or user-specified text. If the user clicks Cancel or hits the ESC key, the edit box returns "Canceled." If the user waits the timeout period, the edit box closes and returns "Timed Out."
       <code language="X#">
        CLEAR
        Y = INPUTBOX("Type Here:", "Input Title",  ;
        "Nothing at all", 5000, 'Timed Out', 'Canceled')
        ? Y
      </code>
    </remarks>
  </inputbox>
  <insmode>
    <summary>
      Returns the current insert mode, or sets the insert mode on or off.
    </summary>
    <param name="lExpression">

      Turns the insert mode on or off. INSMODE(.T.) turns the insert mode on and INSMODE(.F.) turns it off. A logical value corresponding to the insert mode setting before INSMODE(.T.) or INSMODE(.F.) was issued is returned.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      If you omit the optional argument and the insert mode is on (characters are inserted before the cursor), INSMODE( ) returns true (.T.). If the insert mode is off (characters are overwritten at the insertion point), INSMODE( ) returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        SET TALK ON
        =INSMODE(.T.)  &amp;&amp; Set insert mode on
        ? INSMODE( )
        = INSMODE(!INSMODE( ))  &amp;&amp; Toggle insert mode to opposite state
        ? INSMODE( )
      </code>
    </example>
  </insmode>
  <isblank>
    <summary>
      Determines whether an expression is blank.
    </summary>
    <param name="eExpression">

      Specifies the expression for <b>ISBLANK( )</b> to evaluate. eExpression can be a field in a table, a variable or array element, or an expression.
    </param>
    <returns>
      Logical. <b>ISBLANK( )</b> returns True (.T.) if the expression eExpression is blank; otherwise, <b>ISBLANK( )</b> returns False (.F.).

      <b>ISBLANK( )</b> returns True (.T.) for fields when those fields contain certain values. The following table lists the values that field types contain for <b>ISBLANK( )</b> to return True.

      <b>Blob</b>

      Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on

      <b>Character</b>

      Empty string, spaces, or no value, such as a newly appended blank record or cleared with <b>BLANK</b>

      <b>Date</b>

      Blank date ({ / / }) or no value, such as a newly appended blank record or cleared with <b>BLANK</b>

      <b>DateTime</b>

      Blank datetime ({ / / : : }) or no value, such as a newly appended blank record or cleared with <b>BLANK</b>

      <b>Float</b>

      No value, such as a newly appended blank record or cleared with <b>BLANK</b>

      <b>General</b>

      Empty, for example, no OLE object

      <b>Logical</b>

      No value, such as a newly appended blank record or cleared with <b>BLANK</b>

      <b>Memo</b>

      Empty, for example, no memo contents

      <b>Numeric</b>

      No value, such as a newly appended blank record or cleared with <b>BLANK</b>

      <b>Varbinary</b>

      Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on
      Expressions with <b>Currency</b>, <b>Integer</b>, or <b>Double</b> type are never blank; therefore, <b>ISBLANK( )</b> always returns False (.F.) for these expression types.
    </returns>
    <remarks>
      To create a blank record, use the <b>APPEND BLANK</b> and <b>BLANK</b> commands. You can also use <b>BLANK</b> to clear data from fields in a record.

      <b>ISBLANK( ) </b>differs from <b>EMPTY( )</b> and <b>ISNULL( )</b>. For example, <b>EMPTY( )</b> returns True (.T.) if a character expression evaluates to empty, for example, it contains spaces, tabs, carriage returns, or line feeds. <b>ISBLANK( )</b> returns True (.T.) if the character expression contains only the empty string ("") or spaces.
    </remarks>
    <example>
       <code language="X#">
        CREATE TABLE mytable FREE (myfield C(20))
        APPEND BLANK  &amp;&amp; Add new blank record
        CLEAR
        ? ISBLANK(myfield)  &amp;&amp; Displays .T.
        REPLACE myfield WITH 'John Smith'  &amp;&amp; Insert a value in the field
        ? ISBLANK(myfield)  &amp;&amp; Displays .F.
      </code>
    </example>
  </isblank>
  <isexclusive>
    <summary>
      Returns true (.T.) if a table or database is opened for exclusive use; otherwise, returns false (.F.).
    </summary>
    <param name="cTableAlias">

      Specifies the alias of the table for which the exclusive use status is returned. X# generates an error message if you specify a table alias that doesn't exist.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table for which the exclusive use status is returned. ISEXCLUSIVE( ) returns false (.F.) if a table isn't open in the work area you specify.

    </param>
    <param name="cDatabaseName">

      Specifies the name of the database for which the exclusive use status is returned.

    </param>
    <param name="nType">

      Specifies whether the exclusive status is returned for a table or a database. The following table lists the values for nType and the corresponding status returned.
      1
      Table
      2
      Database
      To determine the exclusive status for a database, you must include nType with a value of 2.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      ISEXCLUSIVE( ) returns a value for the table open in the currently selected work area if you omit the optional cTableAlias, nWorkArea, or cDatabaseName arguments.
      A table is opened for exclusive use by including the EXCLUSIVE keyword in USE, or by setting SET EXCLUSIVE to ON before the table is opened.
      A database is opened for exclusive use by including the EXCLUSIVE keyword in OPEN DATABASE.
    </remarks>
    <example>
       <code language="X#">
        cExclusive = SET('EXCLUSIVE')
        SET EXCLUSIVE OFF
        SET PATH TO (HOME(2) + 'data\')
        OPEN DATA testdata  &amp;&amp; Opens the test databsase
        USE customer     &amp;&amp; Not opened exclusively
        USE employee IN 0 EXCLUSIVE    &amp;&amp; Opened exclusively in another work area
        IF ISEXCLUSIVE( )
        REINDEX  &amp;&amp; Can only be done if table opened exclusively
        ELSE
        WAIT WINDOW 'The table has to be exclusively opened'
        ENDIF
        SET EXCLUSIVE &amp;cExclusive
      </code>
    </example>
  </isexclusive>
  <isflocked>
    <summary>
      Returns the table lock status.
    </summary>
    <param name="nWorkArea">

      Specifies the work area number of the table for which the lock status is returned. If you omit cTableAlias and nWorkArea, the lock status is returned for the table open in the current work area.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which the lock status is returned. An "Alias not found" error message is generated if you specify an alias of a table that isn't open.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      ISFLOCKED( ) returns a logical true (.T.) if the table is locked; otherwise a logical false (.F.) is returned. ISFLOCKED( ) is similar to SYS(2011), but returns a logical value which does not require localization for international applications.
      ISFLOCKED() only returns .T. at the workstation that applied the file lock.
    </remarks>
  </isflocked>
  <ismemofetched>
    <summary>
      Determines if a memo field has been fetched during a delayed memo fetch.
    </summary>
    <param name="cFieldName">

      Specifies the name of the memo field for which the fetch status is returned.

    </param>
    <param name="nFieldNumber">

      Specifies the field number (based on the physical structure of the table or cursor) of the memo field for which the fetch status is returned.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor containing the memo field for which the fetch status is returned.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table or cursor containing the memo field for which the fetch status is returned.
    </param>
    <returns>
      Logical. A logical true (.T.) is returned if the specified memo field has been fetched, otherwise a logical false (.F.) is returned. True (.T.) is always returned for local data. The null value (.NULL.) is returned for a cursor if the record pointer is positioned at the beginning or end of the cursor. Use the BOF( ) Function and the EOF( ) Function to determine if the record pointer is positioned at the beginning or end of the cursor.
    </returns>
    <remarks>
      It can often take a while for a memo field fetch to occur with remote data, so you may choose to not download a memo field until it is absolutely needed.
      The FetchMemo setting in the DBGETPROP( ) Function and CURSORGETPROP( ) Function functions determine if a memo field is retrieved with View results or on demand. ISMEMOFETCHED( ) return true (.T.) when the memo field is fetched for delayed Memo data (FetchMemo=.F.).
      ISMEMOFETCHED( ) works with both memo and general fields.
    </remarks>
  </ismemofetched>
  <isnull>
    <summary>
      Returns true (.T.) if an expression evaluates to a null value; otherwise, ISNULL( ) returns false (.F.).
    </summary>
    <param name="eExpression">

      Specifies the expression to evaluate.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Use ISNULL( ) to determine if the contents of a field, memory variable, or array element contains a null value, or if an expression evaluates to a null value.
    </remarks>
    <example>
       <code language="X#">
        STORE .NULL. TO mNullvalue  &amp;&amp; Store a null value to a memory variable
        CLEAR
        ? mNullvalue  &amp;&amp; Display the value of the memory variable
        ? ISNULL(mNullvalue)  &amp;&amp; Returns .T., indicating a null value
        ? TYPE('mNullvalue')     &amp;&amp; Returns L, indicating a logical value
        ? (mNullvalue = .NULL.)  &amp;&amp; Returns .NULL., bad test for null values
      </code>
    </example>
  </isnull>
  <ispen>
    <summary>
      Determines if the last Tablet PC mouse event was a pen tap.
    </summary>
    <remarks>
      ISPEN( )Remarks
      The ISPEN( ) function returns a logical true (.T.) if the last Tablet PC mouse event was a pen tap. A logical false (.F.) is returned if the last mouse event wasn't a pen tap.
    </remarks>
  </ispen>
  <isreadonly>
    <summary>
      Determines whether a table or database is opened read-only.
    </summary>
    <returns>
      Logical
    </returns>
    <remarks>
      ISREADONLY( ) returns true (.T.) if a table is opened read-only; otherwise, ISREADONLY( ) returns false (.F.).
      You can open a table read-only by including the NOUPDATE option when opening the table with USE, by checking the Read Only check box when opening the table from the Open dialog box, or by assigning MS-DOS read-only attributes to the table.
      You cannot pass a non-current database alias to the ISREADONLY( ) function. To ensure that a database is present, you can use code such as the following:
       <code language="X#">!EMPTY(DBC())</code>
      A cursor created with the SELECT – SQL command is always read-only.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer    NOUPDATE  &amp;&amp; Open customer table read-only
        CLEAR
        ? ISREADONLY('customer')  &amp;&amp; Returns .T.
      </code>
    </example>
  </isreadonly>
  <isrlocked>
    <summary>
      Returns the record lock status.
    </summary>
    <param name="nRecordNumber">

      Specifies the number of the record for which the lock status is returned. If nRecordNumber is omitted, the record lock status is returned for the current record.

    </param>
    <param name="nWorkArea">

      Specifies the work area number of the table for which the record lock status is returned. If you omit cTableAlias and nWorkArea, the record lock status is returned for the table open in the current work area.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which the record lock status is returned.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      ISRLOCKED( ) returns a logical true (.T.) if the record is locked by the current application; otherwise a logical false (.F.) is returned.
      ISRLOCKED( ) only returns .T. in the data session that applied the record lock.
    </remarks>
  </isrlocked>
  <istransactable>
    <summary>
      Returns a logical value indicating if a free table or free cursor supports transactions.
    </summary>
    <param name="nWorkArea">

      Specifies the work area of the free table or free cursor for which ISTRANSACTABLE( ) determines if transactions are supported.

    </param>
    <param name="cAlias">

      Specifies the alias of the table or cursor for which ISTRANSACTABLE( ) determines if transactions are supported.
    </param>
    <returns>
      Logical. Returns a logical true (.T.) if a free table or free cursor supports transactions, otherwise a logical false (.F.) is returned.
    </returns>
    <remarks>
      Use the MAKETRANSACTABLE( ) Function to allow a free table or free cursor to support transactions.
    </remarks>
  </istransactable>
  <isupper>
    <summary>
      Determines whether the first character in a character expression is an uppercase alphabetic character.
    </summary>
    <param name="cExpression">

      Specifies the character expression that ISUPPER( ) evaluates. Any characters after the first character in icExpression/i are ignored.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      ISUPPER( ) returns true (.T.) if the first character in a character expression is an uppercase alphabetic character; otherwise, ISUPPER( ) returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        ? ISUPPER('Redmond')  &amp;&amp; Displays .T.
        ? ISUPPER('redmond')  &amp;&amp; Displays .F.
      </code>
    </example>
  </isupper>
  <key>
    <summary>
      Returns the index key expression for an index tag or index file.
    </summary>
    <param name="CDXFileName">

      Specifies the name of a compound index file. KEY( ) returns the index key expressions of the .cdx file's index tag. The compound index file you specify can be the structural compound index file automatically opened with the table, or it can be an independent compound index file.

    </param>
    <param name="nIndexNumber">

      Specifies which index key expression to return.
      USE and SET INDEX both support an index file list that lets you open multiple indexes for a table. Any combination of single-entry .idx index files, structural compound index files, or independent compound index files can be included in the index file list.
      The numeric expression nIndexNumber specifies which index expression to return from the open index files. KEY( ) returns index expressions from open index files in the following order as nIndexNumber increases from 1 to the total number of open single-entry .idx files and structural compound and independent compound index tags:
      Index expressions from single-entry .idx index files (if any are open) are returned first. The order in which the single-entry index files are included in USE or SET INDEX determines how the index expressions are returned.
      Index expressions for each tag in the structural compound index (if one is present) are returned next. The index expressions are returned from the tags in the order in which the tags are created in the structural compound index.
      Index expressions for each tag in any open independent compound indexes are returned last. The index expressions are returned from the tags in the order in which the tags are created in the independent compound indexes.
      The empty string is returned if nIndexNumber is greater than the total number of open single-entry .idx files and structural compound and independent compound index tags.

    </param>
    <param name="nWorkArea">

      Specifies the work area number of the table whose index key expressions you want KEY( ) to return.
      If a table isn't open in the work area you specify, KEY( ) returns the empty string.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table whose index key expressions you want KEY( ) to return.
      If no table has the alias you specify, X# generates an error message.
      If you omit nWorkArea and cTableAlias, the index key expressions are returned for the table open in the current work area.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      An index key expression is specified when an index tag or index file is created with INDEX. The index key expression determines how a table is displayed and accessed when the index tag or index file is opened as the master controlling index tag or file.
      For more information on creating index tags, index files, and index key expressions, see INDEX.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE Customer     &amp;&amp; Open customer table
        CLEAR
        FOR nCount = 1 TO TAGCOUNT( )
        IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
        ? TAG(nCount) + ' '  &amp;&amp; Display tag name
        ?? KEY(nCount)  &amp;&amp; Display index expression
        ELSE
        EXIT  &amp;&amp; Exit the loop when no more tags are found
        ENDIF
        ENDFOR
      </code>
    </example>
  </key>
  <keymatch>
    <summary>
      Searches an index tag or index file for an index key.
    </summary>
    <param name="eIndexKey">

      Specifies the index key that KEYMATCH( ) searches for. The index keys in an index file or index tag are determined by the index expression. An index expression is specified when an index file or index tag is created with INDEX. KEY( ) and SYS(14) can be used to return the index expressions for index files and index tags. For more information on creating index files, index expressions, and index keys, see INDEX.
      If you don't include any of the optional parameters, KEYMATCH( ) searches the master index file or master index tag for the index key you specify. If a master index file or index tag isn't in effect (for example, you've issued SET ORDER TO without any parameters to place the table in physical record order), X# generates an error message.

    </param>
    <param name="nIndexNumber">

      Specifies which index file or index tag is searched. nIndexNumber is typically an integer that starts at 1 and is increased by 1 to search additional index tags.
      If nIndexNumber is 1, the master single-entry .idx index file or master index tag (if one is present) is searched.
      As nIndexNumber increases, subsequent tags in the structural compound index (if one is present) are searched. The tags are searched in the order in which the tags were created in the structural compound index.
      As nIndexNumber continues to increase and all the tags in the structural compound index have been searched, tags in any open independent compound indexes are then searched. The tags are searched in the order in which the tags were created in the independent compound indexes.
      An error message is generated if nIndexNumber is greater than the total number of open single-entry .idx files and structural compound and independent compound index tags.

      nWorkArea| cTableAlias
      Searches index files or tags open in another work area. nWorkArea specifies the work area number and cTableAlias specifies the table alias. If you omit the work area and alias, KEYMATCH( ) searches index files or tags open for the table in the current work area.
      If no table has the alias you specify, X# generates an error message.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      KEYMATCH( ) searches an index tag or index file for a specific index key and returns true (.T.) if the index key is found; otherwise, KEYMATCH( ) returns false (.F.). KEYMATCH( ) can be used to prevent duplicate index keys.
      KEYMATCH( ) returns the record pointer to the record on which it was originally positioned before KEYMATCH( ) was issued.
    </remarks>
  </keymatch>
  <lineno>
    <summary>
      Returns the line number of a line being executed in a program relative to the first line of the main program.
    </summary>
    <returns>
      Numeric
    </returns>
    <remarks>
      Program lines are counted starting from the top of the program. Comment lines, continuation lines, and blank lines are included in the line number count. If a program is suspended during execution, LINENO( ) returns the number of the program line at which program execution was suspended. LINENO( ) returns 0 if a program is canceled.
      By default, line numbers are returned relative to the beginning of the main program. If a procedure is called, line numbering continues from the top of the calling program.
      LINENO( ) is useful for debugging programs. You can set a breakpoint to stop program execution at a specific line number by opening the Breakpoints window, setting the Type to 'Break when expression is true' and adding codeLINENO( ) = nExpression/code in the Expression textbox.
    </remarks>
    <example>
       <code language="X#">
        ON ERROR DO bug_proc WITH LINENO( )
        BRWS  &amp;&amp; Causes an error
        ON ERROR
        *** Bug_Proc error handler ***
        PROCEDURE bug_proc
        PARAMETERS gnBadLine
        WAIT WINDOW 'Error occurred at line: ' + ALLTRIM(STR(gnBadLine))
        RETURN
      </code>
    </example>
  </lineno>
  <loadpicture>
    <summary>
      Creates an object reference for a bitmap, icon, or Windows meta file.
    </summary>
    <param name="cFileName">

      Specifies the image file on disk for which an object is created. br
      brThe following image types are supported:/Pbr
      <b>Supported Image Types</b>




      Image Type Groups

      Filename Extensions


      bitmaps

      .bmp, .jpg, .jpeg, .jpe, .jfif, .gif, .giff, .gfa
      icons
      .ico
      windows metafiles
      .wmf
      windows enhanced metafiles
      .emf
      cursor
      .cur

      brThe following restrictions (tested with VFP 9 SP2 and OlePro32.dll Version 6.0.6002.18005) exist:/Pbr
      <b>Known Limitations</b>
      Restrictions &amp; Issues
      Loading these <b>.tif</b> and <b>.png</b> formats will cause an OLE error.
      Icons are allowed with sizes up to 128x128 and must not have more than 256 colors. Even if there is more than one icon stored in the icon file, always only the smallest icon gets displayed. The icon file may contain much more icons - even with more colors and larger sizes - as long as there is at least one that complies with the rules above, then no exception is thrown.
      Cursor files must not have more than 1K of file size, otherwise an OLE error is generated. Cursor files containing 16 color cursors can be loaded flawlessly, but only monochrome output is supported. Loading an animated cursor (.ani) causes an OLE error to be raised.
      <b>Null Picture Support</b>
      If cFileName is omitted, the "null picture" is returned.br
      You can include GETPICT( ) as cFileName to display the Open dialog from which you can choose a bitmap file.
    </param>
    <returns>
      Object
      <b>LOADPICTURE() function</b> returns a <b>Picture type COM object reference</b> that can be assigned to ActiveX controls and VFP’s Image object’s <b>PictureVal property</b>.
      However, the real primary interface <b>iPicture</b> only can be retrieved using code like this:br
      &amp;nbsp;
      <code language="X#">oIPicture = GETINTERFACE(LOADPICTURE(GETPICT()), "iPicture")</code>

    </returns>
    <remarks>
      Picture objects provide a language-neutral abstraction for bitmaps, icons, and metafiles.
      As with the standard font object, the system provides a standard implementation of the picture object.
      Its primary interfaces are <b>iPicture</b> and <b>iPictureDisp</b>.
      A picture object is created with <b>OleCreatePictureIndirect</b> and supports both the <b>iPicture</b> and the <b>iPictureDisp</b> interfaces.
      The OLE-provided picture object implements the complete semantics of the <b>iPicture</b> and <b>iPictureDisp</b> interfaces.
      In other words, there’s no need to use another interface than <b>iPicture</b>!
      <b>LOADPICTURE( ) Function</b> internally wraps the <b>OleCreatePictureIndirect() function</b> implemented in <b>OleAut32.dll</b>.
      Thus, all you can read about that function (above and online) is also true for VFP’s <b>LOADPICTURE() function</b>.
      <b>LOADPICTURE( ) Function</b> was added to VFP’s vocabulary to make it easier to load images with COM interfaces that many presentation properties of ActiveX controls require for their settings.
      For example, the ActiveX Outline control has a <b>PictureOpen property</b> that requires a COM object image reference for its setting.
      The COM object returned by <b>LOADPICTURE( ) Function</b> hides its primary interface <b>iPicture</b>.
      In contrast to the reference returnd by <b>LOADPICTURE( ) Function</b>, the OLE-image’s primary <b>iPicture</b> interface is the only fully functional one.
      In other words, only <b>iPitcure</b> can be used in VFP programms without generating any OLE errors.
      Because <b>iPicture</b> is a superset of Picture it may be, better, it should be used everywhere instead of the one returnd by <b>LOADPICTURE( ) Function</b>!br
      Example #1 in the examples section below proves that it makes no difference which OLE image interface gets assigned to a <b>oIMAGE.PICTUREVAL property.</b>
      The IID of the <b>iPicture</b> interface is defined as “{7BF80980-BF32-101A-8BBB-00AA00300CAB}”. br

      The following two lines of code both create a null picture OLE image object:
      <code language="X#">
        oIPicture1 = GETINTERFACE(LOADPICTURE(), "iPicture")
        oIPicture2 = CreateObjectEx("StdPicture","","{7BF80980-BF32-101A-8BBB-00AA00300CAB}")
      </code>

      The following table summarizes the PEMs <b>iPicture</b> interface./Pbr

      <b>iPicture Interface Members</b>



      PEM
      Name
      Used for
      ValueType
      Read/Writable


      property
      The <b>Attributes property</b> is said to hold the picture’s bit attributes. Actually, there are only two, which can be set alone, or additive. The following table lists both possible values:
      The following table lists all possible values of the <b>iPicture.Type property</b>:
      The most interesting method of the COM image object’s <b>iPicture interface</b> is <b>render()</b> which also works flawlessly only when called on the <b>iPicture interface</b>.
      The following table summarises the parameters of the <b>render() method</b>:
      The method returns standard values like E_FAIL, E_INVALIDARG and E_OUTOFMEMORY, as well as S_OK, E_POINTER and CTL_E_INVALIDPROPERTYVALUE. These values are described on MSDN.
      The render function has plenty of parameters. Some of them passing in pixel values, others HiMetric values.br
      <b>Example #3</b> has some useful conversions as well as other supporting functions and definitions.br
      To figure out how <b>render()</b> works try the VFP code below; type it in line by line into VFP’s command window:br
      /P

      Direct input into VFP’s command window

      <code language="X#">
        * locate an image with round about 100 x 100 pixels
        goPic = LOADPICTURE(GETPICT())
        gIP = GETINTERFACE(m.goPic, "iPicture")
        goForm = CreateObject("Form")
        goForm.Show()
        * declare access to the _client_area_ of a window
        DECLARE Integer GetDC IN USER32 integer HWnd
        * hDC should be  0 (otherwise that's an error)!
        hDC = GetDC(goForm.HWnd)
        * render your image directly onto form's client area
        gIP.Render(m.hDC,0,0,100,100,0,gIP.Height,gIP.Width,- gIP.Height,NULL)
        * declare release function
        DECLARE Integer ReleaseDC IN USER32 integer HWnd, integer hDC
        * next line should print 1 on the form's background >> "Okay"
        ? ReleaseDC(m.goForm.HWnd, m.hDC)
        * declare access to the _whole_ window
        DECLARE Integer GetWindowDC IN USER32 integer HWnd
        * hDC now references form's caption an border areas as well!
        hDC = GetWindowDC(goForm.HWnd)
        * render out partially overwriting form's border and caption
        gIP.Render(m.hDC,0,0,100,100,0,gIP.Height,gIP.Width,- gIP.Height,NULL)
        * never forget to free an allocated device context
        ? ReleaseDC(m.goForm.HWnd, m.hDC)
      </code>

      <b>iPicture.Render()</b> qualifies for painting on otherwise unreachable form regions, like the TitleBar or WindowBorders.
      Another interesting application for direct rendering stems from the fact that no VFP object reference is necessary for painting.
      The <b>render() method</b> solely uses a common windows handle. Thus, one can render on any known device context.br
      If one encounters the so-called hourglass problem, working with a COM-based image can be the preferred workaround.
      The hourglass mouse cursor gets displayed by the operation system during lengthy disk accesses.
      Sometimes VFP does not reset the hourglass mouse cursor correctly.
      Thus, the user still sees the “busy working” icon although VFP already is idle, as long she doesn’t touch the mouse.
      Most often these disk accesses stem from refreshing pictures loaded into native Image-Objects using the <b>Image.Picture property</b>.
      Storing a COM memory-based object to the Image-Object’s <b>.PictureVal property</b> instead, never causes any disk access.
      Thus, no more hourglass mouse cursor will appear after a refresh!

      <b>iPicture.Render()</b> does its work outside of - and unnoticed by – the VFP engine itself.
      That’s why VFP has no idea of what was painted “between the lines”.
      Each time VFP refreshes the form’s area (we’ve just rendered our picture onto), will clear out our image.
      To make rendered output persistent measures have to be taken against VFP wiping it out!
      There is another BUG one has to be aware of, when employing the hourglass workaround described above!br
      To see what happens, try the following code:

      <code language="X#">
        LOCAL lnLoop, oComPic1, oComPic2
        oComPic1 = LOADPICTURE(GETFILE())
        oComPic2 = LOADPICTURE(GETFILE())
        TRY
        _Screen.Addobject("oImage","IMAGE")
        CATCH
        FINALLY
        _Screen.oImage.Visible = .T.
        ENDTRY
        FOR lnLoop = 1 to 100
        _Screen.oImage.PictureVal = m.oComPic1
        _Screen.oImage.PictureVal = m.oComPic2
        NEXT
        *//
        *\\ whereas the next loop will break somewhere down the road:
        FOR lnLoop = 1 to 100
        _Screen.oImage.PictureVal = m.oComPic1
        _Screen.oImage.PictureVal = m.oComPic1
        _Screen.oImage.PictureVal = m.oComPic1
        _Screen.oImage.PictureVal = m.oComPic2
        NEXT
      </code>
      One can see, that the first loop executes flawlessly, the second one breaks after only a few loops with a “Property value is invalid” error message!
      This bug is hard to track and occurs only in cases when someone tries to assign the same COM-reference more than once in a row!
      The workaround for this is to keep track which COM-reference is actually assigned to the Image’s PictureVal property.
      Never ever then reassign the same reference a second time (overwriting the first one with a copy of itself)!
      BTW: It doesn’t matter what interface you are using.
      The error seems to stem from VFP’s Image class instance.
    </remarks>
    <example>
      The following example shows that both interfaces (<b>Picture</b> and <b>IPicture</b>) of a COM image instance can be assigned to VFP’s <b>Image.PictureVal property</b>:

      <code language="X#">
        PUBLIC goPic AS Object, goIPic AS Object
        goPic = LOADPICTURE(GETPICT())
        goIPic = GETINTERFACE(m.goPic, "iPicture")
        _SCREEN.AddObject("oPic1","IMAGE")
        _SCREEN.AddObject("oPic2","IMAGE")
        WITH _SCREEN.oPic1
        .VISIBLE = .T.
        .PICTUREVAL = m.goPic &amp;&amp; "Picture"-Interface
        ENDWITH
        WITH _SCREEN.oPic2
        .LEFT = 110
        .VISIBLE = .T.
        .PICTUREVAL = m.goIPic &amp;&amp; "IPicture"-Interface
        ENDWITH
        HIDE WINDOWS ALL
        WAIT WINDOW "Press any key..."
        _SCREEN.RemoveObject("oPic1")
        _SCREEN.RemoveObject("oPic2")
        STORE NULL TO goPic, goIPic
        CLEAR
        SHOW WINDOWS ALL
      </code>
      The following example shows how to query the <b>iPicture interface</b> of a COM image instance.
      Intentionally, there are no Try…Catch…Endtry sections in this demo code, so that OLE errors may occur.
      You have to run the code snippet multiple times with different image types to see them.

      <code language="X#">
        goPic = LOADPICTURE(GETPICT())
        IF VARTYPE(m.goPic) == "O"
        goIPic = GETINTERFACE(m.goPic, "iPicture")
        IF VARTYPE(m.goIPic) == "O"
        CLEAR &amp;&amp; just some informal output:
        WITH m.goIPic
        ?
        ? "Properties of 'IPicture'-Interface:"
        ? "Attributes"		,.Attributes
        *\\ next line will fail if an ICOn loaded
        ? "CurDC"	,.CurDC
        ? "Handle"	,.Handle
        ? "Height"	,.Height
        *\\ next line will fail if an ICOn loaded
        ? "hPal"	,.hPal
        ? "KeepOriginalFormat",.KeepOriginalFormat
        ? "Type"	,.Type
        ? "Width"	,.Width
        ?
        ENDWITH
        ENDIF
        ENDIF
      </code>
      The following code is a collection of supporting functions and declarations that come in handy while programming OLE image objects.

      <code language="X#">
        * Supporting Functions &amp; DEFINEs
        #DEFINE INCH2MILLIMETER 25.4 &amp;&amp; 1 Inch = 25.4 millimeters
        #DEFINE INCH2HIMETRICS (INCH2MILLIMETER * 100) &amp;&amp; 1 HIMETRIC = 0.01
        FUNCTION PXL2HIME(tnPixel AS Integer) AS Integer
        * Pixel to HiMetric conversion
        LOCAL lnPixelsOnOneHiMetricUnit AS Integer
        lnPixelsOnOneHiMetricUnit = INCH2HIMETRICS / GetDPI()
        RETURN ROUND(lnPixelsOnOneHiMetricUnit * m.tnPixel, 0)
        ENDFUNC
        FUNCTION HIME2PXL(tnHimetric AS Integer) AS Integer
        * HiMetric to Pixel conversion
        LOCAL lnPixelsOnOneHiMetricUnit AS Integer
        lnPixelsOnOneHiMetricUnit = INCH2HIMETRICS / GetDPI()
        RETURN ROUND(m.tnHimetric / m.lnPixelsOnOneHiMetricUnit, 0)
        ENDFUNC
        FUNCTION GetDPI(tnHDC AS Integer) AS Integer
        * retrieve dots per inch resolution
        * for VFP's _SCREEN device context
        DECLARE Integer GetDeviceCaps IN GDI32 integer hdc, integer nIndex
        DECLARE Integer GetWindowDC IN USER32 integer HWnd
        DECLARE Integer ReleaseDC IN USER32 integer HWnd, integer hDC
        * For simplicity, we assume X- and Y- dimensions
        * using the same DPI resolution.
        #DEFINE LOGPIXELSX 88 &amp;&amp; Logical pixels/inch in X
        #DEFINE LOGPIXELSY 90 &amp;&amp; Logical pixels/inch in Y
        * Get VFP's _Screen-hDC to calculate resolution:
        LOCAL lhDC AS Integer, lnDPI AS Integer
        STORE 0 TO lhDC, lnDPI
        lhDC = GetWindowDC(_Screen.HWnd)
        IF NOT m.lhDC = 0
        lnDPI = GetDeviceCaps(m.lhDC, LOGPIXELSX)
        ELSE
        lnDPI = 96 &amp;&amp; default to 96 DPI
        ENDIF
        * Free device context
        = ReleaseDC(_Screen.HWnd, m.lhDC)
        RETURN m.lnDPI
        ENDFUNC
        FUNCTION GetCanvas(tnHWND AS Integer, tlChild AS Boolean) AS Integer
        * Retrieve hDC (handle DeviceContext) of window handle
        * tlChild = TRUE  := Use GetDC()
        * tlChild = FALSE := Use GetWindowDC()
        DECLARE Integer GetDC IN USER32 integer HWnd
        DECLARE Integer GetWindowDC IN USER32 integer HWnd
        LOCAL lnHDC AS Integer
        IF m.tlChild
        lnHDC = GetDC(m.tnHWND)
        ELSE
        lnHDC = GetWindowDC(m.tnHWND)
        ENDIF
        RETURN m.lnHDC
        ENDFUNC
        FUNCTION ReleaseCanvas(tnHWND AS Integer, tnHDC AS Integer) AS Integer
        * Releases a borrowed hDC
        DECLARE Integer ReleaseDC IN USER32 integer HWnd, integer hDC
        RETURN ReleaseDC(m.tnHWND, m.tnHDC)
        ENDFUNC
        * The following function is not bullert-proof, as it fails on forms with scrollbars (oForm.Scrollbars > 0)
        FUNCTION GetChildAreaCanvas(tnhWnd AS Integer) AS Integer
        * VFP ‘TopLevelForms’ (oForm.ShowWindow = 2) have
        * a secondary window inside the outer one.
        * This is also true for forms showing scrollbars!
        LOCAL lnVfpHANDLE AS Integer, lnClienthWnd AS Integer, lnHDC AS Integer
        * Convert the given Windows hWnd to an internal VFP WHANDLE
        lnVfpHANDLE = SYS(2326, m.tnhWnd)
        * Retrieve the Windows hWnd for a client window
        * (WCLIENTWINDOW) of a specified X# parent window
        lnClienthWnd = SYS(2325, m.lnVfpHANDLE)
        * Check if there is a WCLIENTWINDOW
        IF lnClienthWnd = lnVfpHANDLE
        * No such WCLIENTWINDOW, return child’s client area
        lnHDC = GetCanvas(m.tnhWnd, .T.)
        ELSE
        * There IS a WCLIENTWINDOW!
        * Get the device context handle for the
        * whole client area of that window:
        lnHDC = GetCanvas(lnClienthWnd)
        ENDIF
        RETURN m.lnHDC
        ENDFUNC
      </code>
    </example>
  </loadpicture>
  <locfile>
    <summary>
      Locates a file on disk and returns the file name with its path.
    </summary>
    <param name="cFileName">

      Specifies the name of the file to locate. If cFileName includes only a file name, LOCFILE( ) searches the X# default directory or folder first. If the file is not found in the default directory or folder, the X# path is then searched. Use SET PATH to specify the X# path.
      If cFileName includes a path and a file name, the specified location is searched. If the file cannot be found in the specified location, LOCFILE( ) searches the X# default directory or folder and then the X# path.
      If the file is located, LOCFILE( ) returns the file name and path.

    </param>
    <param name="cFileExtensions">

      Specifies file extensions for the file to locate. If the file name you specify with cFileName does not include an extension, X# applies the file extensions listed in cFileExtensions to the file name and searches for the file again.
      cFileExtensions also specifies the file name extensions of the files displayed in the Open dialog box when the file you specified cannot be located.
      cFileExtensions can take a variety of forms:
      If cFileExtensions contains a single extension (for example, PRG), only files with that extension are displayed.
      cFileExtensions can also contain wildcards (* and ?). All files with extensions that meet the wildcard criteria are displayed. For example, if cFileExtensions is ?X?, all files with the extension .fxp, .exe, or .txt are displayed.
      In X# for Windows, cFileExtensions can contain a file description followed by a file extension or a list of file extensions separated with commas. The file description appears in the Files of Type list box. Separate the file description from the file extension or list of file extensions with a colon (:). Separate multiple file descriptions and their file extensions with a semicolon (;).
      For example, if cFileExtensions is "Text:TXT" the file description "Text" appears in the Files of Type list box and all files with a .txt extension are displayed.
      If cFileExtensions is "Tables:DBF; Files:TXT,BAK" the file descriptions "Tables" and "Files" appear in the Files of Type list box. When "Tables" is chosen from the Files of Type list box, all files with a .dbf extension are displayed. When "Files" is chosen from the Files of Type list box, all files with .txt and .bak extensions are displayed.

    </param>
    <param name="cFileNameCaption">

      Specifies the text you want to use to prompt the user. The text appears to the left of the textbox in which you enter the file name. If omitted, "File name:" is displayed.
      For a list of X# file extensions and corresponding creator types, see the File Extensions and File Types online topic.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      The Open dialog box is displayed if the file cannot be located in the default directory or folder, the X# path, or a specified location. The Open dialog box can be used to locate the file. When a file is chosen from the Open dialog box, the file name is returned with the file's path.
      If you exit the Open dialog box by choosing Cancel, pressing ESC, or choosing Close from the Control menu, X# generates an error message and LOCFILE( ) does not return a value.
    </remarks>
  </locfile>
  <lock>
    <summary>
      Attempts to lock one or more records in a table.
    </summary>
    <param name="cRecordNumberList">

      Specifies a list of one or more record numbers which you must include to attempt to lock multiple records. SET MULTILOCKS must be ON and you must include the work area or alias of the table for which you are attempting to place multiple record locks.
      LOCK( ) attempts to lock all of the records you specify. The record numbers specified with cRecordNumberList are separated by commas. For example, to attempt record locks on the first four records in a table, cRecordNumberList must contain 1,2,3,4.
      You can also lock multiple records by moving the record pointer to the record you would like to lock, issuing LOCK( ) or RLOCK( ) and then repeating these steps for each additional record.
      In X#, you can specify 0 as a record number. Specifying 0 makes it possible for you to attempt to lock the table header.
      Keep the table header locked for as short a time as possible because other users cannot add records to the table when the table header is locked.
      Release the table header lock with UNLOCK RECORD 0, UNLOCK or UNLOCK ALL.
      If all the records specified in cRecordNumbers are successfully locked, LOCK( ) returns true (.T.). If even one of the records specified with cRecordNumbers cannot be locked, LOCK( ) returns false (.F.) and none of the records are locked. However, any existing record locks remain in place. Multiple record locking is an additive process. Placing additional record locks does not release locks on other records.
      The maximum number of records that can be locked in each work area is approximately 8,000. It is always faster to lock the entire table rather than even a small number of records.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      LOCK( ) is identical to RLOCK( ).
      Changes to explicitly locked records aren't saved until the record is unlocked or the record pointer is moved.
      If the lock or locks are successfully placed, LOCK( ) returns true (.T.). Locked records are available for both read and write access to the user who placed the locks; they are available for read-only access to all other users on the network.
      Executing LOCK( ) does not guarantee that the record lock or locks will be successfully placed. A record lock cannot be placed on a record already locked by another user or in a table locked by another user. If the record lock or locks cannot be placed for any reason, LOCK( ) returns false (.F.).
      By default, LOCK( ) makes one attempt to lock a record. Use SET REPROCESS to automatically retry a record lock when the first attempt fails. SET REPROCESS determines the number of lock attempts or the length of time during which lock attempts are made when the initial lock attempt is unsuccessful. For more information, see SET REPROCESS.
      SET MULTILOCKS determines whether you can lock multiple records in a table. If SET MULTILOCKS is OFF (the default), you can lock only a single record in a table. When SET MULTILOCKS is ON, you can lock multiple records in a table. For more information, see SET MULTILOCKS.

      <b>Unlocking Records</b>   A table record can be unlocked only by the user who placed the lock. You can release record locks by issuing UNLOCK, closing the table, or exiting X#.
      UNLOCK can be used to release record locks in the current work area, a specific work area, or in all work areas. For more information, see UNLOCK.
      Switching SET MULTILOCKS from ON to OFF or from OFF to ON implicitly performs UNLOCK ALL — all record locks in all work areas are released.
      Tables can be closed with USE, CLEAR ALL, or CLOSE DATABASES.
      For more information about record and file locking and sharing tables on a network, see Programming for Shared Access.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        SET REPROCESS TO 3 AUTOMATIC
        STORE '1,2,3,4' TO gcRecList
        gcOldExc = SET('EXCLUSIVE')
        SET EXCLUSIVE OFF
        SELECT 0
        USE employee  &amp;&amp; Open Employee table
        SELECT 0
        USE customer  &amp;&amp; Open Customer table
        ? LOCK('1,2,3,4', 'customer')  &amp;&amp; Lock 1st 4 records in customer
        ? RLOCK(gcRecList, 'employee')  &amp;&amp; Lock 1st 4 records in employee
        UNLOCK IN customer
        UNLOCK IN employee
        SET EXCLUSIVE &amp;gcOldExc
      </code>
    </example>
  </lock>
  <lookup>
    <summary>
      Searches a table for the first record with a field matching the specified expression.
    </summary>
    <returns>
      Character, Numeric, Currency, Float, Integer, Double, Date, DateTime, or Logical.
    </returns>
    <remarks>
      If the search is successful, LOOKUP( ) moves the record pointer to the matching record and returns the contents of a specified field in the record.
      If LOOKUP( ) does not find the search expression, it returns a blank value the same length and data type as ReturnField. The record pointer is positioned at the end of the file.
      If you use LOOKUP( ) to search a parent table, record pointers in all related child tables are moved to the related records.
      This function cannot be optimized with Rushmore Query Optimization.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer ORDER company  &amp;&amp; Open Customer table
        CLEAR
        @ 2,2 SAY LOOKUP(contact, 'Ernst Handel', company, 'company')
      </code>
    </example>
  </lookup>
  <maketransactable>
    <summary>
      Allows a free table or free cursor to support transactions.
    </summary>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor for which transactions will be supported.

    </param>
    <param name="cAlias">

      Specifies the alias of the table or cursor for which transactions will be supported.
    </param>
    <returns>
      Logical. Returns a logical true (.T.) if MAKETRANSACTABLE( ) was able to make the free table or cursor support transactions, otherwise a logical false (.F.) is returned.
    </returns>
    <remarks>
      A free table is a table that has not been added to a database with the ADD TABLE Command. A free cursor is a cursor that is created from a free table or with the CREATE CURSOR - SQL Command.
      When MAKETRANSACTABLE( ) is used to make a free table or free cursor support transactions, you can use the BEGIN TRANSACTION, END TRANSACTION, and ROLLBACK commands for the free table or free cursor. Use the ISTRANSACTABLE( ) function to determine if a free table or free cursor supports transactions.
      When MAKETRANSACTABLE( ) is used to make a free table or free cursor support transactions, the free table or free cursor supports transactions in all work areas and data sessions in which it is opened. MAKETRANSACTABLE( ) makes all open instances of a free table or free cursor support transactions, including those in other data sessions within a single instance of VFP.
      If a free table that does not support transactions is open in more than one data session, the free table cannot be made to support transactions. However, you can open a free table that already supports transactions in additional data sessions.
      If row buffering is enabled, then a table update is performed if the free table or free cursor has pending changes before the free table or free cursor is made to support transactions. You cannot use MAKETRANSACTABLE( ) to enable transactions for a free table that has table buffering enabled.
      To disable transactions for a free table, you must close the free table in all data sessions.
    </remarks>
  </maketransactable>
  <mdx>
    <summary>
      Returns the name of the open .cdx compound index file that has the specified index position number.
    </summary>
    <param name="nIndexNumber">

      Specifies which compound index file name to return. If the table has a structural compound index file and nIndexNumber is 1, the name of the structural compound index file (which is always the same as the name of the table) is returned. If nIndexNumber is 2, the name of the first compound index file specified with USE or SET INDEX is returned. If nIndexNumber is 3, the second compound index file name is returned, and so on. If nIndexNumber is greater than the number of open compound index files, an empty string is returned.
      If the table doesn't have a structural compound index file and nIndexNumber is 1, the name of the first compound index file specified with USE or SET INDEX is returned. If nIndexNumber is 2, the second compound index file name is returned, and so on. If nIndexNumber is greater than the number of open compound index files, an empty string is returned.

    </param>
    <param name="nWorkArea">

      Specifies the work area number for compound index files open in work areas other than the current one. If you omit this optional argument, names of compound index files are returned for the current work area.

    </param>
    <param name="cTableAlias">

      Specifies the table alias for compound index files open in work areas other than the current one. If you omit this optional argument, names of compound index files are returned for the current work area.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      MDX( ) is identical to CDX( ).
      Index files can be opened for a table with the INDEX clause of the USE command or with SET INDEX. A structural compound index file is automatically opened with its table. MDX( ) ignores any .idx index files specified with USE or with SET INDEX.
      Use TAG( ) to return tag names from a compound index file; use NDX( ) to return the name of an open .idx index file.
      In X# for Windows, when SET FULLPATH is ON, MDX( ) returns the path to the .cdx file with the .cdx file name. When SET FULLPATH is OFF, MDX( ) returns the drive the .cdx file resides on with the .cdx file name.
    </remarks>
  </mdx>
  <mdy>
    <summary>
      Returns the specified date or datetime expression in month-day-year format with the name of the month spelled out.
    </summary>
    <param name="dExpression">

      Specifies the date expression to return in month-day-year format.

    </param>
    <param name="tExpression">

      Specifies the datetime expression to return in month-day-year format.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      If SET CENTURY is OFF, the character expression is returned in a month dd, yy format. If SET CENTURY is ON, the format is month dd, yyyy.
    </remarks>
    <example>
       <code language="X#">
        SET CENTURY OFF
        CLEAR
        ? Longdate({^1998-02-16})  &amp;&amp; Displays Monday, February 16, 98
        SET CENTURY ON
        ? Longdate({^1998-02-16})  &amp;&amp; Displays Monday, February 16, 1998
        *** LongDate ***
        FUNCTION longdate
        PARAMETERS gdDate
        RETURN CDOW(gdDate) + ', ' + MDY(gdDate)
      </code>
    </example>
  </mdy>
  <messagebox>
    <summary>
      Displays a user-defined dialog box.
    </summary>
    <param name="eMessageText">

      Specifies the text that appears in the dialog box. You can also specify any valid X# function, object, or data type instead of eMessageText. The maximum amount of text you can specify is 1024 characters.
      X# converts object references to the string, "(Object)". If you specify a function that evaluates to a noncharacter value, X# automatically uses the <b>TRANSFORM( )</b> function to provide the character equivalent. In the following example, a character type date is returned and passed to <b>MESSAGEBOX( )</b>:
       <code language="X#">MESSAGEBOX(DATE())</code>
      To move a portion of the message to the next line in the dialog box, use a carriage return, CHR(13), in eMessageText. The height and width of the dialog box increases as needed to contain eMessageText.

    </param>
    <param name="nDialogBoxType">

      Specifies the buttons and icons that appear in the dialog box, the default button when the dialog box is displayed, and the behavior of the dialog box.
      In the following tables, the dialog box button values 0 to 5 specify the buttons that appear in the dialog box. The icon values 16, 32, 48, and 64 specify the icon that appears in the dialog box. The default values 0, 256, and 512 specify which button in the dialog box is the default button. The default button is selected when the dialog box is displayed. Omitting nDialogBoxType is identical to specifying a value of 0 for nDialogBoxType.
      OK button only
      OK and Cancel buttons
      Abort, Retry, and Ignore buttons
      Yes, No, and Cancel buttons
      Yes and No buttons
      Retry and Cancel buttons
      Stop sign
      Question mark
      Exclamation point
      Information (i) icon
      First button
      Second button
      Third button
      nDialogBoxType can be the sum of up to three values, one value from each of the preceding tables. For example, if nDialogBoxType is 290 (2+32+256), the specified dialog box has the following characteristics:
      Abort, Retry, and Ignore buttons.
      The message box displays the question mark icon.
      The second button, Retry, is the default.
      Additional information about the constants is available in the FoxPro.h file, located in the X# home directory. Using defined constants such as MB_ABORTRETRYIGNORE + MB_ICONQUESTION + MB_DEFBUTTON2 can be more readable than 2 + 32 + 256.
      The question mark icon is no longer recommended, because it does not clearly represent a specific type of message and because the phrasing of a message as a question could apply to any message type. In addition, users could confuse the message symbol question mark with Help Information. Therefore, it is not recommended to use the question mark symbol in your message boxes. The system continues to support inclusion only for backwards compatibility.

    </param>
    <param name="cTitleBarText">

      Specifies the text that appears in the title bar of the dialog box. If you omit cTitleBarText, the title "X#" appears in the title bar.

    </param>
    <param name="nTimeout">

      Specifies the number of milliseconds X# displays eMessageText without input from the keyboard or the mouse before clearing eMessageText. You can specify any valid timeout value. A value of less than 1 never times out until user enters input and behaves the same as omitting the nTimeout parameter.
    </param>
    <returns>
      Numeric data type. <b>MESSAGEBOX( )</b> returns a value that indicates which button was chosen in the dialog box. The following table lists the values <b>MESSAGEBOX( )</b> returns for each button.
      1
      OK
      2
      Cancel
      3
      Abort
      4
      Retry
      5
      Ignore
      6
      Yes
      7
      No
      In dialog boxes with a Cancel button, pressing ESC to exit the dialog box returns the same value (2) as choosing Cancel.

      <b>MESSAGEBOX( )</b> returns a value of -1 when a timeout occurs.
    </returns>
    <remarks>
      The shortest abbreviation for <b>MESSAGEBOX( )</b> is <b>MESSAGEB( )</b>.
      The <b>MESSAGEBOX( )</b> function uses smart parameters in that the parameter type determines which parameter is used. The first parameter is required and is always eMessageText. However, the optional second parameter can be nDialogBoxType if the type is <b>Numeric</b> or cTitleBarText if type is <b>Character</b>. The nTimeout parameter is always assumed for the second optional numeric parameter passed. Valid examples include:
       <code language="X#">
        MESSAGEBOX("HELLO","MyTitle",68,6000)
        MESSAGEBOX("HELLO",68,"MyTitle",6000)
        MESSAGEBOX("HELLO",68,6000)
        MESSAGEBOX("HELLO",68,6000,"MyTitle")
      </code>
    </remarks>
    <example>
       <code language="X#">
        eMessageTitle = 'My Application'
        eMessageText = 'Record not found. Would you like to search again?'
        nDialogType = 4 + 16 + 256
        *  4 = Yes and No buttons
        *  16 = Stop sign icon
        *  256 = Second button is default
        nAnswer = MESSAGEBOX(eMessageText, nDialogType, eMessageTitle)
        DO CASE
        CASE nAnswer = 6
        WAIT WINDOW 'You chose Yes'
        CASE nAnswer = 7
        WAIT WINDOW 'You chose No'
        ENDCASE
      </code>
    </example>
  </messagebox>
  <ndx>
    <summary>
      Returns the name of an open index (.IDX) file for the current or specified table.
    </summary>
    <param name="nIndexNumber">

      Specifies which .idx file name to return. USE and SET INDEX both support an index file list that makes it possible for you to open .idx files for a table. The order of the file names in this index file list determines which .idx file name NDX( ) returns. For example, if nIndexNumber is 1, NDX( ) returns the name of the first .idx file in the index file list; if nIndexNumber is 2, NDX( ) returns the second .idx file name, and so on. NDX( ) ignores names of compound index (.cdx) files in the index file list.
      NDX( ) returns an empty string if nIndexNumber is greater than the number of .idx files in the index file list.

    </param>
    <param name="nWorkArea">

      Specifies the work area number for .IDX files open in a work area other than the current one. NDX( ) returns an empty string if no table is open in the work area you specify. If you omit nWorkArea, NDX( ) returns the names of .idx files open with the table in the current work area.

    </param>
    <param name="cTableAlias">

      Specifies the table alias for .idx files open in a work area other than the current one. If no table has the alias you include, X# generates an error message. If you omit cTableAlias, NDX( ) returns the names of .idx files open with the table in the current work area.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      The CDX( ) and MDX( ) functions can be used to return the names of open compound (.cdx) index files.
      In X# for Windows, when SET FULLPATH is ON, NDX( ) returns the path to the .idx file with the .idx file name. When SET FULLPATH is OFF, NDX( ) returns the drive the .idx file resides on with the .idx file name.
    </remarks>
  </ndx>
  <newobject>
    <summary>
      Creates a new class or object directly from a visual class library (.vcx) file or program (.prg) file without opening the file.
    </summary>
    <param name="cClassName">

      Specifies the class or object from which the new class or object is created.

    </param>
    <param name="cModule">

      Specifies a .vcx file or X# program (.prg, .fxp, .mpr, .app, .exe, and so on) containing the class or object specified with cClassName. The default is a .vcx file. If you specify a program file, you must include an extension.
      A class library can have an alias. To specify a class or object from a class library with an alias, include the class library alias followed by a period and the object name.
      When possible, specify the compiled program name (.fxp) when a class is stored in a program file (.prg). This ensures that the class is loaded from the proper class definition file.
      If cModule is omitted, or is the empty string or the null value, X# searches for the class or object in the following order:
      X# base classes.
      Classes in the current program.
      Class libraries opened with SET CLASSLIB.
      Classes in procedure files opened with SET PROCEDURE.
      Classes in the X# program execution chain.
      The OLE registry if SET OLEOBJECT is ON.

    </param>
    <param name="cInApplication">

      Specifies the X# application (.exe or .app) containing the .vcx file you specify with cModule. You must include an extension for the application. CInApplication is ignored if cModule is omitted, or if cInApplication is the empty string or the null value.
      If you want to use the cInApplication parameter, you must specify the name of .vcx file for cModule. You cannot pass the name of a .prg file or compiled program (.fxp).

    </param>
    <param name="0">

      Specifies that the class or object is instantiated without executing any of the event or method code in the class or object. This feature is not supported in runtime applications.
      All child classes or objects of the parent class are also instantiated. The event or method code in the child class or object isn't executed.
      This option is provides the ability to view the structure of a class or object (with the AMembers( ) Function, for example) without opening the class or object in the Class or Form Designer.
      Note that code in the class or object should never be executed - code execution is not supported and can make X# unstable. You should never explicitly call an event or method, or set properties. Setting properties can call Access and Assign methods.

      eParameter1, eParameter2, ...
      Specifies optional parameters that are passed to the Init event procedure for the class or object.
    </param>
    <returns>
      Object
    </returns>
    <remarks>
      To assign the object reference returned by NEWOBJECT( ) to a variable or array element, use the equal sign (=) or STORE command. If an object assigned to a variable or array element is released, the variable or array element contains the null value. To remove the variable or array element from memory, use the RELEASE command.
      For NEWOBJECT( ), X# performs an internal SET CLASSLIB or SET PROCEDURE for the second or third parameters using the ADDITIVE clause where the parameters are first used to determine the search order. If these parameters already exist in the SET CLASSLIB or SET PROCEDURE list, X# rearranges the order in the list so they come first. X# then locates all the classes, creates the object, and calls the Init events. Finally, X# restores the original SET CLASSLIB or SET PROCEDURE list if the installation did not change list.
      OLE objects are created with the following syntax for cClassName:
       <code language="X#">ApplicationName.Class</code>
      For example, to create a Microsoft Excel worksheet, which supports Automation, use the following syntax:
       <code language="X#">oExcelSheet = NEWOBJECT('Excel.Sheet')</code>
    </remarks>
  </newobject>
  <normalize>
    <summary>
      Converts an expression, supplied by a user, into the same form of the expression used internally by X#. You can use the normalized form of an expression to make more accurate comparisons with the expressions returned from X# commands or functions.
    </summary>
    <param name="cExpression">

      Specifies the character expression to normalize.
    </param>
    <returns>
      Character
    </returns>
    <remarks>

      <b>NORMALIZE( )</b> returns a character string from the character expression cExpression with the following changes. <b>NORMALIZE( )</b>:
      Converts the character expression to uppercase. However, it does not change embedded strings. An example of an embedded string is "Hello" in the character expression "LEFT('Hello',1)".
      Expands any abbreviated X# keywords in the character expression to their full length.
      Converts to periods any -&gt; operators that separate aliases from field names.
      Surrounds by periods the logical operators AND, OR and NOT: .AND. .OR. .NOT.
      In filter expressions, removes any blank spaces between terms.
      Checks the syntax of any X# commands or functions within the character expression, However, it does not evaluate the expression. If the syntax is incorrect, X# generates a syntax error. <b>NORMALIZE( )</b> does not look for any fields, tables, memory variables, user-defined functions, or other references in the character expression.
      For example, a user may enter an index expression such as the following in the Expression Builder:
       <code language="X#">UPPE(cust-&gt;lname) + UPPE(cust-&gt;fname)</code>
      While this is a valid X# index key expression, it is difficult to compare this to the return values from a X# function like <b>KEY( )</b>. <b>NORMALIZE( )</b> returns the following character string for the expression above:
       <code language="X#">UPPER(CUST.LNAME) + UPPER(CUST.FNAME)</code>
      You can easily compare this to the value returned by a function like <b>KEY( )</b>. This enables you to verify the existence of an index or index tag with the user-supplied index expression.
      Also, you can use NORMALIZE to compare the results of <b>SET("Filter")</b> or <b>FILTER( )</b>. For example, you could create the following filter expression:
       <code language="X#">
        STORE '"VIRGINIA" $ UPPER(state) AND NOT "MAINE" $ UPPER(state)' TO
        MyFilter
        USE Addresses
        LINK Word.Document.8 "C:\\Documents and Settings\\v-rodhil\\My Documents\\DocStudio\\Projects\\dv_foxhelp91\\cc1ce3c4-1dc6-4d8f-9406-c8bab4d6a40a.xml" "OLE_LINK1" \a \r  \* MERGEFORMAT STORE '"VIRGINIA" $ UPPER(state) AND NOT "MAINE" $ UPPER(state)' TO
        MyFilter
        SET FILTER TO &amp;MyFilter
      </code>
      However, the value returned by <b>SET("Filter")</b> or <b>FILTER( ) </b>will not exactly match the original filter.
       <code language="X#">? SET("FILTER") == MyFilter  &amp;&amp; .F.</code>

      <b>SET("FILTER")</b> or <b>FILTER( )</b> return the following:
       <code language="X#">"VIRGINIA"$UPPER(STATE).AND..NOT."MAINE"$UPPER(STATE)</code>
      To ensure a correct comparison, use:
       <code language="X#">? NORMALIZE(MyFilter) == SET("FILTER")  &amp;&amp; .T."</code>
    </remarks>
  </normalize>
  <numlock>
    <summary>
      Returns the current mode of the NUM LOCK key or sets the mode of the NUM LOCK key on or off.
    </summary>
    <param name="lExpression">

      Turns the NUM LOCK key on or off. If lExpression is true (.T.), the NUM LOCK key is turned on; if lExpression is false (.F.), the NUM LOCK key is turned off. NUMLOCK( ) returns a logical value corresponding to the NUM LOCK key setting before NUMLOCK(.T.) or NUMLOCK(.F.) is issued.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      NUMLOCK( ) returns true (.T.) if the NUM LOCK key is on (pressing a key on the numeric keypad returns a number), or false (.F.) if NUM LOCK is off (pressing a key on the numeric keypad moves the cursor).
    </remarks>
    <example>
       <code language="X#">
        gcOldLock = NUMLOCK( )  &amp;&amp; Save original setting
        WAIT WINDOW 'Press a key to turn Num Lock on'
        = NUMLOCK(.T.)  &amp;&amp; Turn Num Lock on
        WAIT WINDOW 'Press a key to turn Num Lock off'
        = NUMLOCK(!NUMLOCK( ))  &amp;&amp; Toggle Num Lock to the opposite value
        WAIT WINDOW 'Press a key to restore original Num Lock setting'
        = NUMLOCK(gcOldLock)     &amp;&amp; Return to original setting
      </code>
    </example>
  </numlock>
  <nvl>
    <summary>
      Returns a non-null value from two expressions.
    </summary>
    <returns>
      Character, Date, DateTime, Numeric, Currency, Logical, or the null value
    </returns>
    <remarks>
      Use NVL( ) to remove null values from calculations or operations where null values are not supported or are not relevant.
    </remarks>
    <example>
       <code language="X#">
        STORE .NULL. TO glMyNull  &amp;&amp; A memory variable containing the null value
        CLEAR
        ? NVL(.T., glMyNull)  &amp;&amp; Displays .T.
        ? NVL(glMyNull, glMyNull)  &amp;&amp; Displays .NULL.
      </code>
    </example>
  </nvl>
  <oldval>
    <summary>
      Returns original field values for fields that have been modified but not updated.
    </summary>
    <param name="cExpression">

      Specifies an expression whose original value <b>OLDVAL( )</b> returns from a table or a remote data source. cExpression is typically a field or an expression consisting of a set of fields from the table or remote data source.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table or cursor from which the original field values are returned.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor from which the original field values are returned.
    </param>
    <returns>
      Character, Currency, Date, DateTime, Double, Float, Integer, Logical, Numeric, or Memo
    </returns>
    <remarks>

      <b>OLDVAL( )</b> returns original field values for records in a X# table or cursor that has row or table buffering enabled with <b>CURSORSETPROP( )</b>.
      If a table in a database or a cursor has validation rules, <b>OLDVAL( )</b> does not require that row or table buffering be enabled in order to return original field values.
      If the record pointer is moved to a different record when row buffering is enabled, or if <b>TABLEUPDATE( )</b> is issued to commit changes to the record, or there is some other action that causes an update, such as ending a transaction, the fields are updated and the original field values are no longer available.
      The data type of the value <b>OLDVAL( )</b> returns is determined by the expression you specify with cExpression.
      <b>OLDVAL( )</b> can return .NULL., even for a field declared as NOT NULL and with SET NULL OFF.
      The original field values are returned for the table or cursor open in the currently selected work area if <b>OLDVAL( )</b> is issued without the optional cTableAlias or nWorkArea arguments.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        * Create new table and add blank record
        CREATE TABLE employee (cLastName C(10))
        APPEND BLANK
        * Insert initial value
        INSERT INTO employee (cLastName) VALUES ("Smith")
        * Enable and set table buffering
        SET MULTILOCKS ON  &amp;&amp; Allow table buffering
        =CURSORSETPROP("Buffering", 5, "employee" )  &amp;&amp; Enable table buffering
        * Display initial value
        =MESSAGEBOX("Original cLastName value: "+ cLastName, 0, "Results")
        * Change record value and display results
        REPLACE cLastName WITH "Jones"
        =MESSAGEBOX("Modified cLastName value: "+ cLastName, 0, "Results")
        * Store the old value of the field to cTemp variable and display results
        cTemp=OLDVAL("cLastName", "employee")
        =MESSAGEBOX("Original cLastName value: "+ cTemp, 0, "Results")
        * Update table and display final value
        =TABLEUPDATE(.T.)
        =MESSAGEBOX("Final cLastName value: "+ cLastName, 0, "Results")
        * Close and delete example table file
        USE
        DELETE FILE employee.dbf
      </code>
    </example>
  </oldval>
  <order>
    <summary>
      Returns the name of the controlling index file or tag for the current or specified table.
    </summary>
    <param name="nWorkArea">

      Specifies the work area of a table whose controlling index file name or controlling tag name ORDER( ) returns.

    </param>
    <param name="cTableAlias">

      Specifies a table alias whose controlling index file name or controlling tag name ORDER( ) returns.

    </param>
    <param name="nPath">

      Specifies that the drive and directory are returned along with the single-entry or compound index file name. The numeric expression nPath can have any value.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      A table can have several index files open simultaneously. However, only one single-entry index file (the controlling index file) or tag from a compound index file (the controlling tag) controls the order in which the table is displayed or accessed. Certain commands, such as SEEK, use the controlling index file or controlling tag to search for records. This function returns the name of the controlling index file or controlling tag.
      USE and SET INDEX both support opening more than one index with an index file list. A controlling index file or controlling tag can be designated in this index file list. SET ORDER can also be used to designate a controlling index or controlling tag.
      By default, ORDER( ) returns the controlling index file name or controlling tag name for the current work area. ORDER( ) returns the empty string if an order has not been set (SET ORDER TO is issued or there is no controlling index file or tag).
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer ORDER cust_id &amp;&amp; Opens Customer table
        ? ORDER( )  &amp;&amp; Displays CUST_ID
        ? ORDER('customer', 1)  &amp;&amp; Displays CUSTOMER.CDX
      </code>
    </example>
  </order>
  <payment>
    <summary>
      Returns the amount of each periodic payment on a fixed-interest loan.
    </summary>
    <param name="nPrincipal">

      Specifies the beginning principal of the loan.

    </param>
    <param name="nInterestRate">

      Specifies the fixed interest rate per period. If monthly payments are made on the loan but the interest rate is annual, divide the annual interest rate by 12.

    </param>
    <param name="nPayments">

      Specifies the total number of payments to be made on the loan.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      PAYMENT( ) assumes a constant periodic interest rate and assumes that payments are made at the end of each period.
    </remarks>
    <example>
       <code language="X#">
        STORE 100000 to gnPrincipal     &amp;&amp; $100,000 beginning principal
        STORE .105/12 TO gnInterest  &amp;&amp; 10.5% annual interest rate
        STORE (20*12) TO gnPayments     &amp;&amp; 20 years of monthly payments
        CLEAR
        ? PAYMENT(gnPrincipal, gnInterest, gnPayments)  &amp;&amp; Displays 998.38
      </code>
    </example>
  </payment>
  <pcol>
    <summary>
      Returns the current column position of the printer's print head.
    </summary>
    <returns>
      PCOL( )Return Value
      Numeric
    </returns>
    <remarks>
      The value <b>PCOL( )</b> returns is relative to the current setting of the left printer margin. You can set the left margin with SET MARGIN or by storing a value to the system memory variable _PLOFFSET.

      <b>PCOL( )</b> is especially useful for relative addressing of printed text.
      You can use the $ operator in place of <b>PCOL( )</b>.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        @ PROW( ), PCOL( )+12 SAY 'Contact person'
        @ PROW( ), $+12 SAY 'Contact person'
      </code>
    </example>
  </pcol>
  <primary>
    <summary>
      Returns true (.T.) if an index tag is a primary index tag; otherwise, returns false (.F.).
    </summary>
    <param name="nIndexNumber">

      Specifies the number of the index tag for which PRIMARY( ) returns the primary status. PRIMARY( ) returns the primary status in the following order as nIndexNumber increases from 1 to the total number of structural compound and independent compound index tags.
      Primary status for each tag in the structural compound index (if one is present) are returned first. The primary status is returned for the tags in the order the tags are created in the structural index.
      Primary status for each tag in any open, independent compound indexes are returned next. The primary status is returned for the tags in the order in which the tags are created in the independent compound indexes.
      If you omit nIndexNumber, PRIMARY( ) checks the master controlling index tag to see if it's a primary index tag. If there is no master controlling index tag, PRIMARY( ) returns false (.F.).

    </param>
    <param name="nWorkArea">

      Specifies the work area of the index tag specified with nIndexNumber.

    </param>
    <param name="cTableAlias">

      Specifies the work area of the index tag specified with nIndexNumber.
      If you omit nWorkArea and cTableAlias, PRIMARY( ) checks the index tag in the currently selected work area to see if it's a primary index tag.
    </param>
    <returns>
      Logical
    </returns>
    <example>
       <code language="X#">
        CLOSE DATABASES
        SET PATH TO (HOME(2) + 'Data\')   &amp;&amp; Sets path to database
        OPEN DATABASE testdata  &amp;&amp; Open testdata database
        USE Customer     &amp;&amp; Open customer table
        FOR nCount = 1 TO TAGCOUNT( )
        IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
        ? TAG(nCount)  &amp;&amp; Display tag name
        ? PRIMARY(nCount)     &amp;&amp; Display primary status
        ELSE
        EXIT  &amp;&amp; Exit the loop when no more tags are found
        ENDIF
        ENDFOR
      </code>
    </example>
  </primary>
  <program>
    <summary>
      Returns the name of the program at a specified program level, the name of the currently executing program, the current program level, or the name of the program executing when an error occurred.
    </summary>
    <param name="nLevel">

      Specifies the number of program levels to search for the program name. The nLevel parameter can range from 0 to the program nesting depth. For more information about program nesting levels, see maximum number of DO calls in X# System Capacities.
      When nLevel is omitted, <b>PROGRAM( )</b> returns the name of the currently executing program. If you specify 0 or 1 for nLevel, <b>PROGRAM( )</b> returns the name of the master program, or the highest-level program.
      If you specify –1 for nLevel, <b>PROGRAM( )</b> returns the current program level as a numeric value. However, using codePROGRAM(–1)/code in the Command window always returns zero (0).
      If nLevel exceeds the program nesting depth, <b>PROGRAM( )</b> returns an empty string ("").
    </param>
    <returns>
      Character or Numeric. <b>PROGRAM( )</b> returns a program name, the number of the current program level, or an empty string.
    </returns>
    <remarks>
      You can use <b>PROGRAM( )</b> to help your program recover from errors. The <b>PROGRAM( )</b> function is similar to SYS(16) - Executing Program File Name.
    </remarks>
    <example>
       <code language="X#">
        ON ERROR DO errhand WITH PROGRAM( )
        *** The next line should generate an error ***
        USE nodatabase
        ON ERROR     &amp;&amp; Returns to system default error-handling routine
        PROCEDURE errhand
        PARAMETERS gcProgram
        WAIT 'An error occurred in the program ' + gcProgram WINDOW
      </code>
    </example>
  </program>
  <prow>
    <summary>
      Returns the current row number of the printer's print head.
    </summary>
    <returns>
      PROW( )Return Value
      Numeric
    </returns>
    <remarks>
      If you issue <b>EJECT</b>, X# resets <b>PROW( )</b> to 0.

      <b>PROW( )</b> is especially useful for relative addressing of printed text.
    </remarks>
    <example>
       <code language="X#">
        @ PROW( ), PCOL( ) + 12 SAY 'Contact person'
        @ PROW( ), $+12 SAY 'Contact person'
      </code>
    </example>
  </prow>
  <prtinfo>
    <summary>
      Returns the current specified printer setting.
    </summary>
    <param name="nPrinterSetting">

      Specifies which X# printer setting to return. The following table lists descriptions of the type of printer settings returned.
      nPrinterSetting
      1
      PRT_ORIENTATION
      Paper orientation
      2
      PRT_PAPERSIZE
      Paper size
      3
      PRT_PAPERLENGTH
      Paper length in .1 millimeter increments
      4
      PRT_PAPERWIDTH
      Paper width in .1 millimeter increments
      5
      PRT_SCALE
      Factor by which printer output is scaled
      6
      PRT_COPIES
      Number of copies to print
      7
      PRT_DEFASOURCE
      Default paper source
      8
      PRT_PRINTQUAL
      A positive value that indicates the horizontal resolution in dots per inch (DPI) or a negative value that indicates the print quality.
      9
      PRT_COLOR
      A value that indicates if a color printer rends color or monochrome output
      10
      PRT_DUPLEX
      Duplex mode
      11
      PRT_YRESOLUTION
      The vertical resolution in dots per inch (DPI). If not available, a value of -1 is returned.
      12
      PRT_TTOPTION
      A value that indicates how TrueType® fonts are printed
      13
      PRT_COLLATE
      A value that indicates if output is collated

    </param>
    <param name="cPrinterName">

      Specifies the name of the printer for which information is returned. If cPrinterName is omitted, information is returned for the default printer.
    </param>
    <returns>
      Numeric data type. The following tables list values returned when specifying particular values for nPrinterSetting.
      If nPrinterSetting is 1, <b>PRTINFO( )</b> returns the paper orientation as the following:
      –1
      Information not available
      0
      Portrait
      1
      Landscape
      If nPrinterSetting is 2, <b>PRTINFO( )</b> returns the paper size as the following:
      –1 or value other than listed
      Information not available. Use nPrinterSetting = 3 and nPrinterSetting = 4 to return the paper size.
      1
      Letter, 8 1/2 x 11 in
      2
      Letter Small, 8 1/2 x 11 in
      3
      Tabloid, 11 x 17 in
      4
      Ledger, 17 x 11 in
      5
      Legal, 8 1/2 x 14 in
      6
      Statement, 5 1/2 x 8 1/2 in
      7
      Executive, 7 1/4 x 10 1/2 in
      8
      A3, 297 x 420 mm
      9
      A4, 210 x 297 mm
      10
      A4, Small 210 x 297 mm
      11
      A5, 148 x 210 mm
      12
      B4, 250 x 354 mm
      13
      B5, 182 x 257 mm
      14
      Folio, 8 1/2 x 13 in
      15
      Quarto, 215 x 275 mm
      16
      10 x 14 in
      17
      11 x 17 in
      18
      Note, 8 1/2 x 11 in
      19
      Envelope #9, 3 7/8 x 8 7/8 in
      20
      Envelope #10, 4 1/8 x 9 1/2 in
      21
      Envelope #11, 4 1/2 x 10 3/8 in
      22
      Envelope #12, 4 1/2 x 11 in
      23
      Envelope #14, 5 x 11 1/2 in
      24
      C size sheet
      25
      D size sheet
      26
      E size sheet
      27
      Envelope DL, 110 x 220 mm
      28
      Envelope C5, 162 x 229 mm
      29
      Envelope C3, 324 x 458 mm
      30
      Envelope C4, 229 x 324 mm
      31
      Envelope C6, 114 x 162 mm
      32
      Envelope C65, 114 x 229 mm
      33
      Envelope B4, 250 x 353 mm
      34
      Envelope B5, 176 x 250 mm
      35
      Envelope B6, 176 x 125 mm
      36
      Envelope, 110 x 230 mm
      37
      Envelope Monarch, 3 7/8 x 7.5 in
      38
      6 3/4 Envelope, 3 5/8 x 6 1/2 in
      39
      US Std Fanfold, 14 7/8 x 11 in
      40
      German Std Fanfold, 8 1/2 x 12 in
      41
      German Legal Fanfold, 8 1/2 x 13 in
      If nPrinterSetting is 7, <b>PRTINFO( )</b> returns the default paper source as the following:
      1
      Upper bin
      2
      Lower bin
      3
      Middle bin
      4
      Manual feed
      5
      Envelope bin
      6
      Manual feed envelope
      7
      Automatic feed
      8
      Tractor feed
      9
      Small format
      10
      Large format
      11
      Large capacity
      14
      Cassette
      15
      Default input bin (automatically select)
      If nPrinterSetting is 8 and <b>PRTINFO( )</b> returns a negative value, the return value indicates the print quality as the following:
      –1
      Draft
      –2
      Low
      –3
      Medium
      –4
      High
      If nPrinterSetting is 9, <b>PRTINFO( )</b> returns a value indicating if a color printer renders color or monochrome output as the following:
      1
      Monochrome
      2
      Color
      If nPrinterSetting is 10, <b>PRTINFO( )</b> returns the duplex mode as the following:
      1
      Simplex printing
      2
      Vertical duplex
      3
      Horizontal duplex
      If nPrinterSetting is 12, <b>PRTINFO( )</b> returns a value that indicates how TrueType® fonts are printed as the following:
      1
      Print as bitmapped graphics
      2
      Download as soft fonts
      3
      Substitute device fonts
      If nPrinterSetting is 13, <b>PRTINFO( )</b> returns a value that indicates if output is collated as the following:
      0
      No collation
      1
      Collated
    </returns>
    <remarks>
      You can set X# printer settings in the printer Page Setup dialog box. For more information, see Page Setup Dialog Box.
    </remarks>
  </prtinfo>
  <putfile>
    <summary>
      Invokes the Save As dialog box and returns the file name you specify.
    </summary>
    <param name="cCustomText">

      Specifies custom text to appear in the Save As dialog box.

    </param>
    <param name="cFileName">

      Specifies the default file name displayed in the text box.

    </param>
    <param name="cFileExtensions">

      Specifies file name extensions. Only file names with the specified extension are displayed in the scrollable list of the Save As dialog box when the All Files check box is cleared. The first extension in cFileExtensions is automatically appended to the file name entered if an extension isn't included with the file name. The cFileExtensions parameter cannot exceed 254 characters in length. For a list of X# file extensions and corresponding creator types, see the File Extensions and File Types online topic.
      The character expression cFileExtensions can take one of the following forms:
      cFileExtensions can contain a single extension, such as PRG, and only file names with that extension are displayed.
      cFileExtensions can contain a list of file name extensions separated by semicolons. For example, if you include PRG;FXP, X# displays all file names with the extensions .prg and .fxp.
      If file names have the same root name but different extensions (for example, Customer.prg and Customer.fxp), X# displays only the file name with the extension that appears first in cFileExtensions.
      cFileExtensions can contain a list of file name extensions separated by vertical bars, such as PRG|FXP. In such a case, X# displays all file names with listed extensions, even if the files have the same root name.
      If cFileExtensions contains only a semicolon (;), X# displays all file names that don't have an extension.
      If cFileExtensions is an empty string, X# displays the names of all files in the current directory or folder.
      If cFileExtensions contains MS-DOS wildcards, such as the question mark (?) and asterisk (*), X# displays all file names with extensions that meet the wildcard criteria. For example, if cFileExtensions is ?X?, all file names with the extensions .fxp, .exe, .txt, and so on, are displayed.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Use <b>PUTFILE( ) </b>to choose an existing file name or specify a new file name. <b>PUTFILE( )</b> returns the file name with its path. If you don't enter a file name, <b>PUTFILE( )</b> returns the default file name (specified with cFileName) and extension (specified by cFileExtensions). If you choose Cancel or press ESC, <b>PUTFILE( )</b> returns an empty string. You can use the file name that <b>PUTFILE( )</b> returns to name a file and save it to disk.
    </remarks>
    <example>
       <code language="X#">
        gcTableName = GETFILE('DBF', 'Open Table:')
        USE (gcTableName)
        gcDelimName = ALIAS( ) + '.DLM'
        gcDelimFile = PUTFILE('Delimited file:', gcDelimName, 'DLM')
        IF EMPTY(gcDelimFile)  &amp;&amp; Esc pressed
        CANCEL
        ENDIF
        COPY TO (gcDelimFile) DELIMITED   &amp;&amp; Create delimited file
        MODIFY FILE (gcDelimFile) NOEDIT
      </code>
    </example>
  </putfile>
  <pv>
    <summary>
      Returns the present value of an investment.
    </summary>
    <param name="nPayment">

      Specifies the periodic payment amount. nPayment can evaluate to a positive or negative number. <b>PV( )</b> assumes that the payments are made at the end of each period.

    </param>
    <param name="nInterestRate">

      Specifies the periodic interest rate. If the interest rate of an investment is annual and the payments are made monthly, divide the annual interest rate by 12.

    </param>
    <param name="nTotalPayments">

      Specifies the total number of payments.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>PV( )</b> computes the present value of an investment based on a series of equal periodic payments at a constant periodic interest rate.
    </remarks>
    <example>
       <code language="X#">
        STORE 500 to gnPayment  &amp;&amp; Periodic payments made monthly
        STORE .075/12 TO gnInterest     &amp;&amp; 7.5% annual interest rate
        STORE 48 TO gnPeriods  &amp;&amp; Four years (48 months)
        CLEAR
        ? PV(gnPayment, gnInterest, gnPeriods)  &amp;&amp; Displays 20679.19
      </code>
    </example>
  </pv>
  <quarter>
    <summary>
      Returns the quarter of the year in which a date or datetime expression occurs.
    </summary>
    <param name="dExpression">

      Specifies the <b>Date</b> expression for which you want <b>QUARTER( )</b> to return a value.

    </param>
    <param name="tExpression">

      Specifies the <b>DateTime</b> expression for which you want <b>QUARTER( )</b> to return a value.

    </param>
    <param name="nMonth">

      Specifies an optional starting month to the examined quarter. You can use this to specify quarters based on a fiscal rather than a calendar year.
    </param>
    <returns>
      Numeric data type. <b>QUARTER( )</b> returns the quarter of the year in which a date occurs, and the values can be 0, 1, 2, 3, or 4.
      <b>QUARTER( )</b> returns 0 if passed an empty <b>Date</b> or <b>DateTime</b> value, for example, codeQUARTER({//})/code.
    </returns>
  </quarter>
  <raiseevent>
    <summary>
      You can use <b>RAISEEVENT( )</b> to raise, or trigger, an event from a custom method. Though <b>RAISEEVENT( )</b> applies primarily to custom methods, you can use it for raising native events and methods.
    </summary>
    <param name="oEventSource">

      Specifies the event source, which must be a valid X# object.

    </param>
    <param name="cEvent">

      Specifies the name of the event, method, or property you want to raise.

    </param>
    <param name="eParm1...">

      Specifies one or more parameters to pass if the method has parameters.
    </param>
    <returns>
      Logical data type. <b>RAISEEVENT( )</b> always returns True (.T.).
    </returns>
    <remarks>
      X# automatically raises events for custom methods that are bound to objects using <b>BINDEVENT( )</b> if the methods are called directly. For example, the following code does not raise an event:
       <code language="X#">oForm.GetMyData(cData)</code>
      Instead, to raise an event for a custom method, you need to make the following call:
       <code language="X#">RAISEEVENT( oForm, "GetMyData", cData )</code>
      You can also change this behavior by using <b>BINDEVENT( )</b> with nFlags set to 2 or 3.
      The event you wish to raise must be marked <b>Public</b>, not <b>Hidden</b> or <b>Protected</b>.
      If you use <b>RAISEEVENT( )</b> on a property, X# sets the property to itself. The following example sets the <b>Caption</b> property for <b>_SCREEN</b> to the current value for <b>Caption</b>:
       <code language="X#">RAISEEVENT( _SCREEN, "Caption" )</code>
      Raising an event fails if you bind to an event, for example, using <b>BINDEVENT( )</b>, that has parameters that are passed by reference.
      X# disregards recursive <b>RAISEEVENT( )</b><b> </b>calls to an event from within the same raised event.
    </remarks>
    <example>
       <code language="X#">RAISEEVENT( Form1, "Activate" )</code>
    </example>
  </raiseevent>
  <ratc>
    <summary>
      Returns the numeric position of the last occurrence of a character expression or memo field within another character expression or memo field.
    </summary>
    <param name="cSearchExpression">

      Specifies the character expression that RATC( ) looks for in cExpressionSearched.

    </param>
    <param name="cExpressionSearched">

      Specifies the character expression that RATC( ) searches. The character expressions cSearchExpression and cExpressionSearched can be memo fields of any size.

    </param>
    <param name="nOccurrence">

      Specifies which occurrence, starting from the right and moving left, of cSearchExpression RATC( ) searches for in cExpressionSearched. By default, RATC( ) searches for the last occurrence of cSearchExpression (nOccurrence equals 1). If nOccurrence is 2, RATC( ) searches for the next to last occurrence, and so on.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      RATC( ) is designed for expressions containing double-byte characters. If the expression contains only single-byte characters, RATC( ) is equivalent to RAT( ).
      RATC( ) returns the numeric position of the last occurrence of a character expression or memo field within another character expression or memo field. The character expressions or memo fields can contain any combination of single-byte and double-byte characters.
      RATC( ) is the reverse of the AT_C( ) function: it searches from right to left.
      RATC( ) returns an integer indicating the position of the first character in cSearchExpression in cExpressionSearched. RATC( ) returns 0 if cSearchExpression isn't found in cExpressionSearched, or if nOccurrence is greater than the number of times cSearchExpression occurs in cExpressionSearched.
      The search performed by RATC( ) is case-sensitive.
      This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
    </remarks>
  </ratc>
  <refresh>
    <summary>
      Refreshes data in an updatable SQL remote or local view, or <b>CursorAdapter</b> cursor.
    </summary>
    <param name="nRecords">

      Specifies the number of records to refresh. If nRecords is 1 or you omit nRecords, only the current record is refreshed. If nRecords is 0, no records are refreshed.

    </param>
    <param name="nRecordOffset">

      Specifies the number of records before the current record where the refresh begins. For example, if the current record is record 10 and nRecordOffset is 4, record refresh begins with record 6. If nRecordOffset is 0 or you omit nRecordOffset, the refresh begins with the current record.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the cursor associated with a SQL remote or local view, or a <b>CursorAdapter</b> cursor where records are refreshed.

    </param>
    <param name="nWorkArea">

      Specifies the work area of cursor where records are refreshed. If you omit nWorkArea and cTableAlias, records are refreshed in the currently selected work area.
    </param>
    <returns>
      Numeric. <b>REFRESH( )</b> returns the number of records refreshed.
    </returns>
    <remarks>
      The records are refreshed with data from the tables that define the SQL view or <b>CursorAdapter</b>. Unless specified, records are refreshed in the SQL view or <b>CursorAdapter</b> cursor open in the currently selected work area.
      <b>REFRESH( )</b> does not refresh content for buffered records; however, field values that are accessible for the record through the <b>CURVAL( )</b> function are refreshed. For more information, see CURVAL( ) Function.
      Records must have unique primary keys. If a key for a record cannot be located in the base table, the corresponding record in the SQL view or <b>CursorAdapter</b> is marked for deletion.
      Calling the <b>REFRESH( )</b> function can result in a significant impact on performance because the function re-executes the query on which the view is based. Therefore, do not call this function more than necessary.
    </remarks>
  </refresh>
  <relation>
    <summary>
      Returns a specified relational expression for a table that is open in a specific work area.
    </summary>
    <param name="nRelationNumber">

      Specifies which relation is returned. For example, if nRelationNumber is 3, <b>RELATION( )</b> returns the relational expression for the third relation created.

    </param>
    <param name="nWorkArea">

      Specifies the work area for a table open in another work area. If a table is not open in the specified work area, <b>RELATION( )</b> returns an empty string.

    </param>
    <param name="cTableAlias">

      Specifies the table alias for a table open in another work area.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      By default, RELATION( ) returns relational expressions for a specified table. If you do not specify a work area or alias, RELATION( ) returns relational expressions for the table in the currently selected work area. If no relations exist, it returns an empty string. For additional information about creating relations between tables, see SET RELATION.
      DISPLAY STATUS and LIST STATUS display relational expressions. Issue MODIFY DATABASE to display the Database Designer. This enables you to view and modify relations between tables in the current open database. Issue SET to display the Data Session window. This enables you to view and modify relations between free tables.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer IN 0 ORDER cust_id  &amp;&amp; Opens Customer table
        USE employee IN 0 ORDER emp_id  &amp;&amp; Opens Customer table
        USE orders IN  0 ORDER order_id  &amp;&amp; Opens Customer table
        SELECT orders
        SET RELATION TO emp_id INTO employee
        SET RELATION TO cust_id INTO customer ADDITIVE
        ? RELATION(1)  &amp;&amp; Displays CUST_ID
        ? RELATION(2)  &amp;&amp; Displays EMP_ID
        ? RELATION(3)  &amp;&amp; Displays empty string
      </code>
    </example>
  </relation>
  <removeproperty>
    <summary>
      Removes a property from an object at run time.
    </summary>
    <param name="oObjectName">

      Specifies the name of the object from which to remove the property.

    </param>
    <param name="cPropertyName">

      Specifies the name of the existing property to remove from the object. You can specify only a property name, not an event or method name.
    </param>
    <returns>
      Logical data type. <b>REMOVEPROPERTY( )</b> returns True (.T.) if it successfully removes the property; otherwise, it returns False (.F.).
    </returns>
    <remarks>
      You can use <b>REMOVEPROPERTY( )</b> to remove properties, but not methods or events. You can use <b>REMOVEPROPERTY( )</b> with object instances created from X# classes, COM classes, <b>SCATTER...NAME</b> command, <b>_VFP</b>, and <b>_SCREEN</b>.
      Properties must be visibly <b>Public</b>, not <b>Hidden</b> or <b>Protected</b> and have been added to an instance of an object, typically using the <b>ADDPROPERTY( )</b> function, the <b>AddProperty</b> method, or <b>SCATTER...NAME</b> command, so that they can be removed using <b>REMOVEPROPERTY( )</b>.
      You cannot remove a property if it is a member of the class definition used to create the instance of the object.

      <b>REMOVEPROPERTY( )</b> function does not remove properties that are specific array elements. To remove an array, provide only the array name.

      <b>Example 1</b>

      The following example adds a new property to an object created with the <b>SCATTER</b> command and then removes it.
       <code language="X#">
        USE customers
        SCATTER NAME oCust
        ADDPROPERTY(oCust,"MyProperty")
        REMOVEPROPERTY(oCust,"MyProperty")
      </code>

      <b>Example 2</b>

      The following example creates a property array for the object, codeoMyForm/code, displays its contents, code1/code and code"Two"/code, and then removes it.
       <code language="X#">
        oMyForm = CreateObject('Form')
        ADDPROPERTY(oMyForm, 'MyArray(2)', 1)
        oMyForm.MyArray(2) = "Two"
        CLEAR
        ? oMyForm.MyArray(1)
        ? oMyForm.MyArray(2)
        REMOVEPROPERTY(oMyForm, 'MyArray')
        RELEASE oMyForm
        CLEAR
      </code>
    </remarks>
  </removeproperty>
  <requery>
    <summary>
      Retrieves data again for a SQL view.
    </summary>
    <param name="nWorkArea">

      Specifies the work area in which the SQL view is open.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the SQL view. If you omit nWorkArea and cTableAlias, the data for the SQL view open in the currently selected work area is retrieved.
    </param>
    <returns>
      Numeric. <b>REQUERY( )</b> returns 1 if the data is successfully retrieved; otherwise, it returns 0.
    </returns>
    <remarks>

      <b>REQUERY( )</b> is typically used to refresh a SQL view when data has changed on the data source.
    </remarks>
  </requery>
  <rgbscheme>
    <summary>
      Returns an RGB color pair or an RGB color pair list from a specified color scheme.
    </summary>
    <param name="nColorSchemeNumber">

      Specifies the number of the color scheme for which you want a complete RGB color listing. RGBSCHEME( ) returns 10 RGB color pairs.

    </param>
    <param name="nColorPairPosition">

      Returns a single RGB color pair from a color scheme. nColorPairPosition specifies the position of the RGB color pair in the color scheme. For example, if nColorPairPosition is 4, the fourth RGB color pair is returned.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Use SCHEME( ) to return a traditional color pair or a color pair list from a color scheme. RGB color pairs use numeric values to specify colors. Traditional color pairs use letters to specify colors.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RGBSCHEME(4,3)
      </code>
    </example>
  </rgbscheme>
  <savepicture>
    <summary>
      Creates a bitmap (.bmp) file from a picture object reference.
    </summary>
    <param name="oObjectReference">

      Specifies a picture object reference from which SAVEPICTURE( ) creates a bitmap file.

    </param>
    <param name="cFileName">

      Specifies the name of the bitmap file that SAVEPICTURE( ) creates. If cFileName includes a path, the file is created in the directory specified in the path. If a file with the same name already exists, it is overwritten without warning, even if SET SAFETY is ON.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Picture object references are typically created with LOADPICTURE( ). However, certain properties (such as the PictureOpen property for the OLE Outline control) use a default picture object reference, which can be used to create a bitmap file.
    </remarks>
  </savepicture>
  <scheme>
    <summary>
      Returns a color pair list or a single color pair from a specified color scheme.
    </summary>
    <param name="nSchemeNumber">

      Specifies the number of the color scheme for which you want a complete color-pair list. SCHEME( ) returns ten color pairs.

    </param>
    <param name="nColorPairNumber">

      Specifies the position of one color pair in the color scheme, and SCHEME( ) returns only this color pair. For example, if nColorPairNumber is 4, SCHEME( ) returns the fourth color pair from the color scheme.
    </param>
    <returns>
      Character
    </returns>
    <example>
       <code language="X#">? SCHEME(4,3)</code>
    </example>
  </scheme>
  <seconds>
    <summary>
      Returns the number of seconds that have elapsed since midnight.
    </summary>
    <returns>
      SECONDS( )Return Value
      Numeric. <b>SECONDS( )</b> returns a numeric value in decimal format with a resolution of 1 millisecond. For versions of X# running on Windows NT 4.0 or later, <b>SECONDS( )</b> returns a resolution of 10 milliseconds.
    </returns>
    <example>
       <code language="X#">
        CLEAR
        ? SECONDS( )
        ? SECONDS( )/(60 * 60)
      </code>
    </example>
  </seconds>
  <seek>
    <summary>
      Searches an indexed table for the first occurrence of a record whose index key matches a specified expression. Issuing SEEK( ) is equivalent to issuing SEEK and FOUND( ) in succession.
      X# does not support seek operations for binary indexes.
    </summary>
    <param name="eExpression">

      Specifies the index key expression for which you want SEEK( ) to search.

    </param>
    <param name="nWorkArea">

      Specifies the work area number of the table that is searched for the index key.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table that is searched.
      If you omit nWorkArea and cTableAlias, the table in the currently selected work area is searched.

    </param>
    <param name="nIndexNumber">

      Specifies the number of the index file or tag that is used to search for the index key. nIndexNumber refers to the index files as they are listed in USE or SET INDEX. Open .idx files are numbered first in the order in which they appear in USE or SET INDEX. Tags in the structural .cdx file (if one exists) are then numbered in the order in which they were created. Finally, tags in any open independent .cdx files are numbered in the order in which they were created. For more information about index numbering, see SET ORDER Command.

    </param>
    <param name="cIDXIndexFileName">

      Specifies an .idx file that is used to search for the index key.

    </param>
    <param name="cTagName">

      Specifies a tag of a .cdx file that is used to search for the index key. The tag name can be from a structural .cdx file or any open independent .cdx file.
      The .idx file takes precedence if duplicate .idx file and tag names exist.
    </param>
    <returns>
      Logical. SEEK( ) returns True (.T.) if a match is found and the record pointer moves to the matching record. Otherwise, SEEK( ) returns False (.F.) if a match is not found, and the record pointer moves to the end of the file if SET NEAR is OFF or to the closest matching record if SET NEAR is ON.
    </returns>
    <remarks>
      You can use SEEK( ) on a table with an index order set, or if an index order is not set on the table, set the controlling index with the 3rd parameter, nIndexNumber, cIDXIndexFileName, or cTagName. The match must be exact unless SET EXACT is set to OFF.
      If you omit the nIndexNumber, IDXIndexFileName, and cTagName arguments, SEEK( ) uses the master controlling index or index tag to search for the index key.
      The SET KEY setting is ignored if SEEK( ) uses a non-active index.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer ORDER cust_id  &amp;&amp; Opens Customer table
        ? SEEK('CHOPS')  &amp;&amp; Returns .T., record found
      </code>
    </example>
  </seek>
  <select>
    <summary>
      Returns the number of the currently selected work area or the highest-numbered unused work area.
    </summary>
    <param name="cTableAlias">

      Specifies the alias of the table for which SELECT( ) returns the work area.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      SELECT( ) returns the number of the current work area if SET COMPATIBLE is set to OFF. If SET COMPATIBLE is set to ON, SELECT( ) returns the number of the unused work area with the highest number.
      A work area can be selected (activated) with SELECT.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        SET COMPATIBLE ON
        OPEN DATABASE (HOME(2) + 'data\testdata')
        SELECT 0  &amp;&amp; Unused work area
        USE customer  &amp;&amp; Opens Customer table
        SELECT 0  &amp;&amp; Unused work area
        USE orders  &amp;&amp; Opens Orders table
        CLEAR
        ? SELECT( )  &amp;&amp; Returns 3, lowest available work area
      </code>
    </example>
  </select>
  <setfldstate>
    <summary>
      Assigns a field modification or deletion state value to a field or record in a table or cursor.
    </summary>
    <param name="nFieldState">

      Specifies a value for the field modification or deletion status. The following table lists the field modification or deletion state value and the corresponding modification or deletion status:
      nFieldState
      1
      Field has not been modified or deletion status has not changed.
      2
      Field has been modified or deletion status has changed.
      3
      Field in an appended record has not been modified or deletion status has not changed for the appended record.
      4
      Field in an appended record has been modified or deletion status has changed for the appended record.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table or cursor in which the modification or deletion status is assigned.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor in which the modification or deletion status is assigned. The field modification or deletion state value is assigned for the table or cursor open in the currently selected work area if SETFLDSTATE( ) is issued without the optional cTableAlias or nWorkArea arguments.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      X# uses field state values to determine which fields in tables or cursors are updated. SETFLDSTATE( ) makes it possible for you to control which fields X# attempts to update, regardless of which fields have been modified in the table or cursor.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        SET MULTILOCKS ON  &amp;&amp; Must be on for table buffering
        SET PATH TO (HOME(2) + 'Data\')     &amp;&amp; Sets path to database
        OPEN DATABASE testdata  &amp;&amp; Open testdata database
        USE Customer     &amp;&amp; Open customer table
        = CURSORSETPROP('Buffering', 5, 'customer')  &amp;&amp; Enable table buffering
        CLEAR
        ? GETFLDSTATE('cust_id')  &amp;&amp; Displays 1, not modified
        REPLACE cust_id    WITH '***'  &amp;&amp; Changes field contents
        ? GETFLDSTATE('cust_id')  &amp;&amp; Returns 2, field modified
        = SETFLDSTATE('cust_id', 1)  &amp;&amp; Change the field status
        ? GETFLDSTATE('cust_id')  &amp;&amp; Displays 1, not modified
        = TABLEREVERT(.T.)  &amp;&amp; Discard all table changes
      </code>
    </example>
  </setfldstate>
  <setresultset>
    <summary>
      Marks a cursor as a result set in the current data session.
      Only one cursor per data session can be marked. When marking a new cursor, <b>SETRESULTSET( )</b> clears the marker from any previously marked cursor.
    </summary>
    <param name="nWorkArea">

      Specifies a work area number.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the cursor you want to mark.
    </param>
    <returns>
      Numeric. <b>SETRESULTSET( )</b> returns the number of the work area of the previously marked cursor in the current data session or zero (0) if no cursor is marked in the current data session.
    </returns>
    <remarks>

      <b>SETRESULTSET( )</b> is supported in X# and the X# OLE DB Provider. You can use <b>SETRESULTSET( )</b> in a database container (DBC) stored procedure or send it to the X# OLE DB Provider, assuming that the cursor has been previously opened by the OLE DB Provider. For example, suppose a previous command opens a cursor named MyCursor in the OLE DB Provider. The following line of code retrieves an ADO RecordSet for the cursor, MyCursor:
       <code language="X#">oRecordSet = oConn.Execute("SETRESULTSET('MyCursor')")</code>
      By using <b>SETRESULTSET( )</b> to mark a cursor or table opened by the X# OLE DB Provider, you can retrieve a rowset created from the table or cursor from a database container (DBC) stored procedure. When the OLE DB Provider completes command execution, it creates a rowset from the marked cursor, if it exists, then clears the marker flag from the cursor.
      In this scenario, the OLE DB Provider disregards all other return values. For example, if a stored procedure contains a <b>RETURN</b> Value statement and a marked cursor, the OLE DB Provider does not return the value. Instead, it returns the marked cursor as a rowset to the calling application. When the rowset closes, the cursor also closes.
      However, even though the OLE DB Provider disregards all return values when a marked cursor exists, you can use <b>SETRESULTSET( )</b> with the <b>RETURN</b> command. For example:
       <code language="X#">RETURN SETRESULTSET("MyCursor")</code>
      This statement creates and returns a rowset from the marked cursor, not the return value from <b>SETRESULTSET( )</b>.
    </remarks>
  </setresultset>
  <sqlcolumns>
    <summary>
      Stores a list of column names and information about each column for the specified data source table to a X# cursor.
    </summary>
    <param name="nStatementHandle">

      Specifies an active statement handle.

    </param>
    <param name="cTableName">

      Specifies the name of the table from which the column names are returned. TableName can contain the wildcard characters ? and *. The question mark (?) matches any single character and the asterisk (*) matches any number of characters.
      FOXPRO | NATIVE
      Specifies the format for the column information in the result set. Be sure to enclose FOXPRO or NATIVE in quotation marks. The NATIVE format option stores column information for tables in the same format as the data source. The FOXPRO format option stores the column information in the same format as that used for the X# table or cursor that would be created if you imported the data source table into X#. If you omit FOXPRO or NATIVE, the format option defaults to FOXPRO.
      The following table shows the columns in the result set for the FOXPRO format.
      Field_name
      Column name
      Field_type
      Column data type
      Field_len
      Column length
      Field_dec
      Number of decimal places
      The columns in the result set for the NATIVE format depend on the data source. If the table you specify with cTableName does not exist and the format is set to NATIVE, <b>SQLCOLUMNS( )</b> returns true (.T.) and creates an empty table or cursor. If the table you specify with cTableName does not exist and the format is set to FOXPRO, <b>SQLCOLUMNS( )</b> returns false (.F.).
    </param>
    <param name="cCursorName">

      Specifies the name of the X# cursor for the result set. If you do not include a cursor name, X# uses the default name SQLRESULT.
    </param>
    <returns>
      Numeric or Logical. <b>SQLCOLUMNS( )</b> returns 1 if the cursor is successfully created, 0 if <b>SQLCOLUMNS( )</b> is still executing, – 1 if a connection level error occurs, and – 2 if an environment level error occurs.
    </returns>
    <remarks>

      <b>SQLCOLUMNS( )</b> is one of the four functions that you can execute either synchronously or asynchronously. The Asynchronous setting of <b>SQLSETPROP( )</b> determines if these functions execute synchronously or asynchronously. In asynchronous mode, you must call <b>SQLCOLUMNS( )</b> repeatedly until a value other than false (.F.) (still executing) is returned.
    </remarks>
    <example>
       <code language="X#">= SQLCOLUMNS(gnHandle, 'authors', 'FOXPRO', 'MyCursor')</code>
    </example>
  </sqlcolumns>
  <sqlcommit>
    <summary>
      Commits a transaction.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by <b>SQLCONNECT( )</b>.
    </param>
    <returns>
      Numeric. <b>SQLCOMMIT( )</b> returns 1 if the transaction is successfully committed; otherwise, it returns -1. If <b>SQLCOMMIT( )</b> returns -1, you can use <b>AERROR( )</b> to determine why the transaction could not be committed.
    </returns>
    <remarks>
      If manual transactions are in effect (the <b>SQLSETPROP( )</b> Transactions property is set to Manual), you can send multiple updates to remote tables and commit all the updates with <b>SQLCOMMIT( )</b>.
      Updates can be rolled back with <b>SQLROLLBACK( )</b>.
    </remarks>
    <example>
       <code language="X#">
        = SQLSETPROP(gnHandle, 'Transactions', 2)  &amp;&amp; Manual transactions
        = SQLEXEC(gnHandle, "INSERT INTO authors (au_id, au_lname);
        VALUES ('aupoe', 'Poe')")  &amp;&amp; Modify the authors table
        = SQLCOMMIT(gnHandle)  &amp;&amp; Commit the changes
      </code>
    </example>
  </sqlcommit>
  <sqlconnect>
    <summary>
      Establishes a connection to a data source. There are two versions of the syntax.
    </summary>
    <param name="nStatementHandle">

      Specifies that a new statement handle be created for the underlying shared connection that is represented by nStatementHandle. The new statement handle uses the settings provided from nStatementHandle instead of using the default settings.
      You cannot create a new statement handle for a connection that is not shared. X# generates an error if you attempt to create a new statement handle against a nonshared connection.
      You can also use <b>SQLCONNECT( )</b> to obtain a new statement handle on a shared connection that was opened using <b>SQLSTRINGCONNECT( )</b>.

    </param>
    <param name="cConnectionName">

      Specifies a named connection created by the <b>CREATE CONNECTION</b> command.
      When using <b>CREATE CONNECTION</b> or the Connection Designer to create a named connection, you can configure the connection by specifying a data source name, user ID, and password. When using the named connection in <b>SQLCONNECT( )</b> as cConnectionName, you can pass values different from those in the named connection for the optional cUserID and cPassword parameters. These passed values are used instead of the user ID and password in the named connection specified by cConnectionName.
      For example, suppose you create a named connection called codemyNamedConnection/code using <b>CREATE CONNECTION</b> or the Connection Designer and specify the values codemyUserID/code and codemyPassword/code for the named connection. For <b>SQLCONNECT( )</b>, you can specify codemyNamedConnection/code as cConnectionName and then specify codemyAltUserID/code and codemyAltPassword/code as an alternate user ID and password as in the following code:
       <code language="X#">SQLCONNECT("myNamedConnection", "myAltUserID", "myAltPassword")</code>
      However, if you create a named connection using a connection string with <b>CREATE CONNECTION</b> or the Connection Designer, use the named connection in <b>SQLCONNECT( )</b>, and attempt to pass optional user ID and password parameters to <b>SQLCONNECT( )</b>, X# generates the appropriate message.
      When creating a new shared connection, the cConnectionName parameter refers to a named connection in the current database container (DBC).
      When creating a new statement handle based on an existing shared connection, the cConnectionName parameter refers to a previous connection opened in shared mode.
      If you use the cConnectionName parameter without the lShared parameter or with lShared parameter as False (.F.), you will always create a new connection that is not shared.
      When using cConnectionName, if lShared is True (.T.) and the named connection is already open in shared mode, the user name and password provided should match those previously used. Otherwise, X# generates the appropriate message.

    </param>
    <param name="cDataSourceName">

      Specifies the name of a data source as defined in your Odbc.ini file.
      You can also choose a data source from the Select Connection or Data Source Dialog Box, which appears when you call <b>SQLCONNECT( )</b> without any additional arguments or with only the lShared parameter.

    </param>
    <param name="cUserID">

      Specifies the user identifier used to log on to the data source.

    </param>
    <param name="cPassword">

      Specifies the password for gaining access to the data source.

    </param>
    <param name="lShared">

      Specifies whether or not to create a shared connection.
      lShared
      False (.F.)
      <b>SQLCONNECT( )</b> does not create a shared connection. (Default)
      True (.T.)
      <b>SQLCONNECT( )</b> creates a shared connection.
    </param>
    <returns>
      Numeric data type. <b>SQLCONNECT( )</b> returns a positive nonzero numeric value as the statement handle if you successfully connect to the data source. <b>SQLCONNECT( )</b> returns –1 if it cannot make the connection.
      You should store this statement handle in a memory variable and use the variable in subsequent function calls that require a connection handle.
    </returns>
    <remarks>
      The <b>SQLCONNECT( )</b> and <b>SQLSTRINGCONNECT( )</b> functions return a numeric value as the statement handle rather than a connection handle. You cannot obtain a connection handle directly. You can still set and get connection properties using the <b>SQLSETPROP( )</b> and <b>SQLGETPROP( )</b> functions by passing the statement handle for that connection and the string, "Shared", as arguments. All other SQL functions use a statement handle instead of a connection handle.
      If you issue a statement such as codeSQLCONNECT(cConnectionName, .T.)/code, and a shared connection is already open with the same name, then the settings for that connection do not change to the settings stored for that connection in the database container (DBC). However, the new statement handle will use the statement settings from the DBC.
      You must disable the Open Database Connectivity (ODBC) login dialog box to support SQL pass through with Microsoft Transaction Server. To disable the ODBC login dialog box, use the statement codeSQLSETPROP(nStatementHandle, 'DispLogin', 3)/code, where cStatementHandle is the statement handle returned by <b>SQLCONNECT( )</b>. You can also disable the ODBC login dialog box in the Connection Designer.
    </remarks>
    <example>

      <b>Example 1</b>

      The following example assumes that an ODBC data source called MyFoxSQLNT exists and is available. <b>SQLCONNECT( )</b> returns a numeric value, which is stored to a variable named codegnConnHandle/code.
      If you successfully connect to the data source, <b>SQLCONNECT( )</b> returns a positive number, a dialog box appears, and <b>SQLDISCONNECT( )</b> is called to disconnect from the data source.
      If you cannot connect to the data source, <b>SQLCONNECT( )</b> returns a negative number and displays a message.
       <code language="X#">
        STORE SQLCONNECT('MyFoxSQLNT', 'myUserID', 'myPassword') TO gnConnHandle
        IF gnConnHandle &lt;= 0
        = MESSAGEBOX('Cannot make connection', 16, 'SQL Connect Error')
        ELSE
        = MESSAGEBOX('Connection made', 48, 'SQL Connect Message')
        = SQLDISCONNECT(gnHandle)
        ENDIF
      </code>

      <b>Example 2</b>

      Each of the following examples create new shared connections. The Choose Data Source Dialog Box appears, and <b>SQLCONNECT( )</b> creates the resulting connection as shared.
       <code language="X#">
        SQLCONNECT(.T.)
        SQLCONNECT( myConnectionName, .T. )
        SQLCONNECT( myDataSourceName, myUserID, myPassword, .T. )
      </code>

      <b>Example 3</b>

      Each of the following examples creates a new statement handle based on an existing shared connection.
       <code language="X#">
        SQLCONNECT( nStatementHandleValue )
        SQLCONNECT( myConnectionName, .T. )
      </code>
    </example>
  </sqlconnect>
  <sqldisconnect>
    <summary>
      Terminates a connection to a data source.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by <b>SQLCONNECT( )</b>. Specify 0 for nStatementHandle to terminate all active connections.
    </param>
    <returns>
      Numeric. <b>SQLDISCONNECT( )</b> returns 1 if the connection is successfully terminated, – 1 if there is a connection level error, and – 2 if there is an environment level error.
    </returns>
    <remarks>

      <b>SQLDISCONNECT( )</b> terminates a connection to a data source. You must supply the statement handle that <b>SQLCONNECT( )</b> returned when you established the connection.
      If you execute <b>SQLDISCONNECT( )</b> within an asynchronous function sequence or during a transaction, <b>SQLDISCONNECT( )</b> generates an error.
    </remarks>
    <example>
       <code language="X#">
        STORE SQLCONNECT('MyFoxSQLNT', '&lt;userid&gt;', '&lt;password&gt;') TO gnHandle
        IF gnHandle &lt;= 0
        = MESSAGEBOX('Cannot make connection', 16, 'SQL Connect Error')
        ELSE
        = MESSAGEBOX('Connection made', 48, 'SQL Connect Message)
        = SQLDISCONNECT(gnHandle)
        ENDIF
      </code>
    </example>
  </sqldisconnect>
  <sqlexec>
    <summary>
      Sends a SQL statement to the data source, where the statement is processed.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by the <b>SQLCONNECT( )</b> function. For more information, see SQLCONNECT( ) Function.

    </param>
    <param name="cSQLCommand">

      Specifies the SQL statement passed to the data source.
      The SQL statement can contain a parameterized WHERE clause, which creates a parameterized view. You must define all parameters in the WHERE clause before issuing <b>SQLEXEC( )</b>. For example, if the parameters are variables, the variables must be created and initialized before <b>SQLEXEC( )</b> is issued. For more information about parameterized views, see How to: Create Parameterized Views.
      You can include expressions in the SQL statement. X# evaluates all expressions in the SQL statement that you pass before sending them to the data source. X# can evaluate memory variable names, function calls, and expressions enclosed in parentheses as parameter values.

    </param>
    <param name="cCursorName">

      Specifies the name of the X# cursor to which the result set is sent. If you don't include a cursor name, X# uses the default name SQLRESULT.
      For multiple result sets, new cursor names are derived by appending an incremented number to the name of the first cursor.

    </param>
    <param name="">

      Specifies the name of the array to populate with row count information. If the array doesn’t exist, it is created. The array has two columns: 1 – Alias, 2 –Count.
      0
      Character
      Indicates that SQL command did not return any results. Either no records were returned or the SQL command failed before results could be returned. (final <b>SQLMORERESULTS</b> call) or execution failed before any result could be processed. Can be only on the first row. Count column for the row contains value -1.
      Non-empty uppercase string
      Alias of the cursor – target for the record fetch operation. The Count column for the row contains the number of fetched records or -1 if fetch failed. If Count is -1, cursor may not have been created. During asynchronous execution, the fetch process for a cursor can be split between multiple SQLMORERESULTS or SQLEXEC calls; each call returns its own fetch count for the cursor.
      Empty String
      Indicates that the SQL command (INSERT, UPDATE, or DELETE) did not return a result set.
      Number of affected or fetched records.
      Integer
      Indicates the number of affected records as returned by the ODBC SQLRowCount function. Returns -1 if the number of records is unavailable.
    </param>
    <returns>
      Numeric data type. <b>SQLEXEC( )</b> returns the number of result sets if there is more than one. <b>SQLEXEC( )</b> returns 0 if it is still executing and returns 1 when it has finished executing. <b>SQLEXEC( )</b> returns –1 if a connection level error occurs.
    </returns>
    <remarks>
      If the SQL statement you want to pass is quite long, check to see if it exceeds the maximum length of a string literal in X#, which is 255 characters. Longer strings will cause a "Command contains unrecognized phrase/keyword" error. However, you can pass long SQL statements if you break them up into several concatenated literals. For example:
       <code language="X#">
        lnRetVal = SQLEXEC(lnHandle, "SELECT &lt;long list of fields&gt; " + ;
        "FROM &lt;several tables&gt; " + ;
        "WHERE &lt;complex filter expression&gt;")
      </code>
      If <b>SQLEXEC( )</b> is used to execute a SQL statement prepared with <b>SQLPREPARE( )</b>, only the connection handle argument nStatementHandle is required. The cSQLCommand and CursorName arguments should be omitted. For more information, see SQLPREPARE( ) Function.
      If the SQL statement generates one result set, <b>SQLEXEC( )</b> stores the result set to the specified X# cursor. If the SQL statement generates two or more result sets, you can name each result set by setting the connection's BatchMode property to False (.F.) using the SQLSETPROP( ) function and changing the cursor name each time you call the SQLMORERESULTS( ) function. Otherwise, SQLEXEC( ) names each result set by appending sequential numbers to the name of the first one.

      <b>SQLEXEC( )</b> is one of the four functions that you can execute either synchronously or asynchronously. The Asynchronous setting of <b>SQLSETPROP( )</b> determines whether these functions execute synchronously or asynchronously. In asynchronous mode, you must call <b>SQLEXEC( )</b> repeatedly until it returns a value other than 0 (still executing).
    </remarks>
    <example>
      The following example shows various ways to use <b>SQLEXEC( )</b> to execute ad-hoc queries and to call or create stored procedures:
       <code language="X#">
        CLEAR
        LOCAL lnConn
        LOCAL lnPercent AS Int  &amp;&amp; Input parameters must be typed.
        LOCAL lnOutput
        lnPercent = 50
        lnOutput = 0
        * Make connection, assuming a local trusted connection.
        lnConn = SQLCONNECT('local')
        IF m.lnConn &gt; 0  &amp;&amp; Success.
        * Set the active database to PUBS.
        SQLEXEC(m.lnConn, 'use pubs')
        * Execute SELECT statement.
        SQLEXEC(m.lnConn, 'SELECT * FROM authors', 'PubAuthors')
        BROWSE

        * Execute INSERT statement, get value of identity field.
        SQLEXEC(m.lnConn, "INSERT INTO JOBS (job_desc, min_lvl, max_lvl);
        VALUES ('Developer',75,150)")
        SQLEXEC(m.lnConn, "SELECT SCOPE_IDENTITY()", "job_id")
        ? "ID for added Job is " + LTRIM(STR(job_id.exp))
        * Execute DELETE statement. Get number of records affected.
        SQLEXEC(m.lnConn, "DELETE FROM JOBS WHERE job_desc ='Developer'")
        SQLEXEC(m.lnConn, "SELECT @@ROWCOUNT", 'rowcount')
        ? rowcount.exp, "record(s) deleted"
        * Call a stored procedure with no parameters.
        SQLEXEC(m.lnConn, 'sp_who', 'activeusers')
        BROWSE
        * Execute stored procedure with an INPUT parameter.
        SQLEXEC(m.lnConn, 'exec byroyalty ?lnPercent','HalfOffAuthors')

        * Create temp stored procedure with OUTPUT parameter and call it.
        SQLEXEC(m.lnConn, "CREATE PROCEDURE #MyProc @outparam int OUTPUT AS;
        SELECT @outparam=100")
        SQLEXEC(m.lnConn, "exec #myProc ?@lnOutput")
        ? m.lnOutput

        * Create a temp stored procedure with INPUT and OUTPUT parameters
        * and call it.
        SQLEXEC(m.lnConn, "CREATE PROCEDURE #MyProc2 " + ;
        "@inputparam INT, " + ;
        "@outparam int OUTPUT " + ;
        "AS SET @outparam=@inputparam*10")
        SQLEXEC(m.lnConn, "exec #myProc2 ?lnPercent, ?@lnOutput")
        ? m.lnOutput
        * Get version information.
        SQLEXEC(m.lnConn, 'SELECT @@VERSION','SQLVersion1')
        ? STRTRAN(SQLVersion1.Exp,CHR(0))
        * Disconnect.
        SQLDISCONNECT(m.lnConn)
        ELSE
        ? "Unable to connect to SQL Server"
        ENDIF
        RETURN
      </code>
    </example>
  </sqlexec>
  <sqlgetprop>
    <summary>
      Retrieves the current or default settings for an active connection.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by SQLCONNECT( ). If you specify 0 for nStatementHandle, SQLGETPROP( ) returns the environment setting.

    </param>
    <param name="cSetting">

      Specifies the setting. For a list of the settings you can specify, see SQLSETPROP( ) Function.
    </param>
    <returns>
      Character, Numeric, or Logical data type. SQLGETPROP( ) returns the current or default settings for an active connection. SQLGETPROP( ) returns -1 if a connection level occurs and -2 if an environment level error occurs.
    </returns>
    <example>
       <code language="X#">
        CLOSE ALL
        CLEAR ALL
        CLEAR
        nHandle=SQLCONNECT()
        IF nHandle &gt; 0
        cSource= SQLGETPROP(nHandle, "datasource")
        =MESSAGEBOX("Current Data Source = "+cSource,0,"Connection Results")
        ELSE
        =MESSAGEBOX("Connection Error = " + ;
        ALLTRIM(STR(nHandle)),0,"Connection Results")
        ENDIF
        =SQLDISCONNECT(nHandle)
      </code>
    </example>
  </sqlgetprop>
  <sqlidledisconnect>
    <summary>
      Allows a SQL pass-through connection or connections to be temporarily disconnected.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle of the connection to be temporarily disconnected.
      Specify 0 for nStatementHandle to temporarily disconnect all active connections.
    </param>
    <returns>
      Numeric.
      1 is returned if SQLIDLEDISCONNECT( ) successfully temporarily disconnects the SQL pass-through connection or connections.
      -1 is returned if SQLIDLEDISCONNECT( ) was unable to temporarily disconnect the SQL pass-through connection or connections.
    </returns>
    <remarks>
      The function fails (returns -1) if the statement handle is busy or a connection is in manual commit mode. The AERROR( ) Function can be used to obtain information about the cause of the error.
      A temporarily disconnected connection is automatically restored as soon as it is needed to perform an operation; the original connection string is used. The ODBC ODBChstmt property returns 0 if the statement handle is temporarily released and the ODBChdbc property returns 0 if the connection is temporarily disconnected. A shared connection is temporarily disconnected as soon as all its statement handles are temporarily disconnected (released).
    </remarks>
  </sqlidledisconnect>
  <sqlmoreresults>
    <summary>
      Copies another result set to a X# cursor if more result sets are available.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by SQLCONNECT( ).

    </param>
    <param name="cCursorName">

      Specifies the name of the X# cursor to which the result set is sent. If you do not include a cursor name, X# uses the default name SQLRESULT.
      For multiple result sets, new cursor names are derived by appending an incremented number to the name of the first cursor.

    </param>
    <param name="">

      Specifies the name of the array to populate with row count information. If the array doesn’t exist, it is created. The array has two columns: 1 – Alias, 2 –Count.
      0
      Character
      Indicates that SQL command did not return any results. Either no records were returned or the SQL command failed before results could be returned. (final <b>SQLMORERESULTS</b> call) or execution failed before any result could be processed. Can be only on the first row. Count column for the row contains value -1.
      Non-empty uppercase string
      Alias of the cursor – target for the record fetch operation. The Count column for the row contains the number of fetched records or -1 if fetch failed. If Count is -1, cursor may not have been created. During asynchronous execution, the fetch process for a cursor can be split between multiple SQLMORERESULTS or SQLEXEC calls; each call returns its own fetch count for the cursor.
      Empty String
      Indicates that the SQL command (INSERT, UPDATE, or DELETE) did not return a result set.
      Number of affected or fetched records.
      Integer
      Indicates the number of affected records as returned by the ODBC SQLRowCount function.
      Returns -1 if the number of records is unavailable.

    </param>
    <returns>
      Numeric. SQLMORERESULTS( ) returns 0 if the SQL statement is still executing, returns 1 if it is finished executing, and returns 2 if no more data is found. In non-batch mode, SQLMORERESULTS( ) should be called after each successful SQLEXEC( ) call until SQLMORERESULTS( ) returns 2 (no more data found). The setting of the SQLSETPROP( ) batch mode option determines whether SQLEXEC( ) executes a SQL statement in batch or non-batch mode.
      SQLMORERESULTS( ) returns – 1 if a connection level error occurs, and returns – 2 if an environment level error occurs.
    </returns>
    <remarks>
      SQLMORERESULTS( ) determines if more result sets are available from a SQL statement executed with SQLEXEC( ) in non-batch mode. If more result sets are available, they are copied to a X# cursor, one set at a time.
      SQLMORERESULTS( ) is one of the four functions that you can execute either synchronously or asynchronously. The asynchronous setting of SQLSETPROP( ) determines if these functions execute synchronously or asynchronously. In asynchronous mode, you must call SQLMORERESULTS( ) repeatedly until it returns a value other than 0 (still executing).
    </remarks>
    <example>
       <code language="X#">
        = SQLSETPROP(gnHandle, 'BatchMode', .F.)  &amp;&amp; Individual result sets
        = SQLEXEC(gnHandle, 'SELECT * FROM authors;
        SELECT * FROM titles')
        = SQLMORERES(gnHandle)  &amp;&amp; First result set
        = SQLMORERES(gnHandle)  &amp;&amp; Second result set
      </code>
    </example>
  </sqlmoreresults>
  <sqlprepare>
    <summary>
      Prepares a SQL statement for remote execution by SQLEXEC( ).
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by SQLCONNECT( ).

    </param>
    <param name="cSQLCommand">

      Specifies the SQL statement passed to the data source.
      The SQL statement can contain a parameterized WHERE clause, which creates a parameterized view. All parameters in the WHERE clause must be defined before SQLPREPARE( ) is issued. For example, if the parameters are variables, the variables must be created and initialized before SQLPREPARE( ) is issued. For more information about parameterized views, see How to: Create Parameterized Views.

    </param>
    <param name="cCursorName">

      Specifies the name of the X# cursor to which the result set is sent. If you don't include a cursor name, X# uses the default name SQLRESULT.
      For multiple result sets, new cursor names are derived by appending an incremented number to the name of the first cursor.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      SQLPREPARE( ) sends the SQL statement to the data source where it is compiled for faster execution. After the SQL statement is compiled, it can be executed with SQLEXEC( ). If SQLEXEC( ) is used to execute a SQL statement prepared with SQLPREPARE( ), only the statement handle is required in SQLEXEC( ).
    </remarks>
    <example>
       <code language="X#">
        gcAuthor = 'Smith'
        = SQLPREPARE(gnHandle, 'SELECT * FROM authors;   WHERE au_lname = ?gcAuthor')
        = SQLEXEC(gnHandle)
        ...
        gcAuthor = 'Jones'
        = SQLEXEC(gnHandle)
      </code>
    </example>
  </sqlprepare>
  <sqlrollback>
    <summary>
      Cancels any changes made during the current transaction.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by SQLCONNECT( ).
    </param>
    <returns>
      Numeric. SQLROLLBACK( ) returns 1 if the transaction is successfully rolled back; otherwise, it returns -1. If SQLROLLBACK( ) returns -1, you can use AERROR( ) to determine why the transaction could not be rolled back.
    </returns>
    <remarks>
      If manual transactions are in effect (the SQLSETPROP( ) transaction property is set to manual), you can send multiple updates to remote tables. The updates can all be rolled back with SQLROLLBACK( ).
      Updates can be committed with SQLCOMMIT( ).
    </remarks>
    <example>
       <code language="X#">
        = SQLSETPROP(gnHandle, 'Transactions', 2)  &amp;&amp; manual
        = SQLEXEC(gnHandle, "INSERT INTO authors (au_id, au_lname);
        VALUES ('aupoe', 'Poe')")
        = SQLROLLBACK(gnHandle)
      </code>
    </example>
  </sqlrollback>
  <sqlsetprop>
    <summary>
      Specifies settings for an active connection. You can use SQLSETPROP( ) to specify settings at the connection level. To specify X# default settings at the environment level, include 0 as the statement handle.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by SQLCONNECT( ).

    </param>
    <param name="cSetting">

      Specifies the setting. The following table lists the values for cSetting.
      Asynchronous
      Specifies whether result sets are returned synchronously (False (.F.), the default), or asynchronously (True (.T.)). Read/write.
      BatchMode
      Specifies whether SQLEXEC( ) returns result sets all at once (True (.T.), the default), or individually with SQLMORERESULTS( ) (False (.F.)).  Read/write.
      ConnectBusy
      Contains True (.T.) if a shared connection is busy; otherwise contains False (.F.).  Read-only.
      ConnectString
      The login connection string.  Read-only.
      ConnectTimeOut
      Specifies the time to wait (in seconds) before returning a connection time-out error. If you specify 0, the wait is indefinite and a time-out error is never returned. ConnectTimeOut can be 0 to 600. The default is 15.  Read/write.
      DataSource
      The name of the data source as defined in the ODBC.INI file.  Read/write.
      DisconnectRollback
      Specifies if a pending transaction is committed or rolled back when SQLDISCONNECT( ) is called for the last connection handle.
      The default is false (.F.), indicating that a pending transaction is committed when SQLDISCONNECT( ) is called for the last connection handle.
      Specify true (.T.) to roll back a pending transaction when SQLDISCONNECT( ) is called for the last connection handle.
      Connections with automatic transaction processing are not affected by this setting.
      DispLogin
      Contains a numeric value that determines when the ODBC Login dialog box is displayed. DispLogin may assume the following values:
      1 or DB_PROMPTCOMPLETE (from FOXPRO.H).1 is the default.
      2 or DB_PROMPTALWAYS (from FOXPRO.H).
      3 or DB_PROMPTNEVER (from FOXPRO.H).
      If 1 or DB_PROMPTCOMPLETE is specified, X# displays the ODBC Login dialog box only if any required information is missing.
      If 2 or DB_PROMPTALWAYS is specified, the ODBC Login dialog box is always displayed, making it possible for you to change settings before connecting.
      If 3 or DB_PROMPTNEVER is specified, the ODBC Login dialog box isn't displayed and X# generates an error if the required login information isn't available. Read/write.
      DispWarnings
      Specifies if error messages are displayed (True (.T.)) or are not displayed (False (.F.), the default).  Read/write.
      IdleTimeout
      The idle timeout interval in minutes. Active connections are deactivated after the specified time interval. The default value is 0 (wait indefinitely).  Read/write.
      ODBChdbc
      The internal ODBC connection handle, which may be used by external library files (FLL files) to call ODBC.  Read-only.
      ODBChstmt
      The internal ODBC statement handle, which may be used by external library files (FLL files) to call ODBC.  Read-only.
      PacketSize
      The size of the network packet used by the connection. Adjusting this value can improve performance. The default value is 4096 bytes (4K).  Read/write
      Password
      The connection password.  Read-only.
      QueryTimeOut
      Specifies the time to wait (in seconds) before returning a general time-out error. If you specify 0 (the default), the wait is indefinite and a time-out error is never returned. QueryTimeOut can be 0 to 600.  Read/write.
      Shared
      Specifies whether the underlying connection is a shared connection (True (.T.)), or not (False (.F.)).
      Transactions
      Contains a numeric value that determines how the connection manages transactions on the remote table. Transactions may assume the following values:
      1 or DB_TRANSAUTO (from FOXPRO.H).1 is the default. Transaction processing for the remote table is automatically handled.
      2 or DB_TRANSMANUAL (from FOXPRO.H). Transaction processing is handled manually through SQLCOMMIT( ) and SQLROLLBACK( ). Read/write.
      UserId
      The user identification. Read-only.
      WaitTime
      The amount of time in milliseconds that elapses before X# checks if the SQL statement has completed executing. The default is 100 milliseconds.  Read/write.

    </param>
    <param name="eExpression">

      Specifies the value for the setting you designate with cSetting. If you omit eExpression, the default value is restored for the setting.
    </param>
    <returns>
      Numeric data type. SQLSETPROP( ) returns 1 if it is successful. Otherwise, it returns – 1 if a connection level error occurs or – 2 if an environment level error occurs.
    </returns>
    <remarks>
      You can use SQLGETPROP( ) to return the current value for a specified setting.
      You must disable the Open Database Connectivity (ODBC) login dialog box to support SQL pass through with Microsoft Transaction Server. To disable the ODBC login dialog box, use the statement codeSQLSETPROP(cStatementHandle, 'DispLogin', 3)/code, where cStatementHandle is the statement handle returned by <b>SQLCONNECT( )</b>. You can also disable the ODBC login dialog box in the Connection Designer.
      The ConnectTimeOut option can be set only at the X# level and has no equivalent at the connection level. You can set all other options at either the connection or the X# level. Each option set at the X# level serves as a default value for subsequent connections.
    </remarks>
    <example>
       <code language="X#">
        CLOSE ALL
        CLEAR ALL
        CLEAR
        nHandle=SQLCONNECT()
        IF nHandle &gt; 0
        nSet=SQLSETPROP(nHandle, "PacketSize", 2048 )
        IF nSet &gt; 0
        =MESSAGEBOX("PacketSize was set to 2048",0,"Connection Results")
        ELSE
        =MESSAGEBOX("Error setting PacketSize",0,"Connection Results")
        ENDIF
        ELSE
        =MESSAGEBOX("No Connection",0,"Connection Results")
        ENDIF
        =SQLDISCONNECT(nHandle)
      </code>
    </example>
  </sqlsetprop>
  <sqlstringconnect>
    <summary>
      Establishes a connection to a data source using a connection string.
    </summary>
    <param name="lShared">

      Specifies whether to create a shared connection.
      lShared
      False (.F.)
      <b>SQLSTRINGCONNECT( )</b> does not create a shared connection. (Default)
      True (.T.)
      <b>SQLSTRINGCONNECT( )</b> creates a shared connection.

    </param>
    <param name="cConnectString">

      Specifies the data source connection string required by some Open Database Connectivity (ODBC) drivers. X# passes the connection string to the ODBC driver. For more information about data source connection strings, see your ODBC driver documentation.
      You can also choose a data source from the Select Connection or Data Source Dialog Box, which appears when you call <b>SQLSTRINGCONNECT( )</b> without cConnectString.

    </param>
    <param name="lSharable">

      Specifies if the data source specified with cConnectString has a shared connection.
    </param>
    <returns>
      Numeric data type. <b>SQLSTRINGCONNECT( )</b> returns a positive nonzero numeric value as the statement handle if you successfully connect to the data source. <b>SQLSTRINGCONNECT( )</b> returns –1 if it cannot make the connection.
      You should store this statement handle in a memory variable and use the variable in subsequent function calls that require a connection handle.
    </returns>
    <remarks>
      The <b>SQLCONNECT( )</b> and <b>SQLSTRINGCONNECT( )</b> functions return a numeric value as the statement handle rather than a connection handle. You cannot obtain a connection handle directly. You can still set and get connection properties using the <b>SQLSETPROP( )</b> and <b>SQLGETPROP( )</b> functions by passing the statement handle for that connection and the string, "Shared", as arguments. All other SQL functions use a statement handle instead of a connection handle.

      <b>SQLSTRINGCONNECT( )</b> always creates a new connection when it successfully makes a connection. However, setting the lShared parameter determines whether you can share the connection later. If you specify a connection as shareable by setting lShared to True (.T.), you can share the connection later by calling <b>SQLCONNECT( )</b> and passing the numeric value of the connection handle as the first parameter. For more information, see SQLCONNECT( ) Function.
      You can use <b>SQLCONNECT( )</b> to obtain a new statement handle on a shared connection that was opened using <b>SQLSTRINGCONNECT( )</b>.
    </remarks>
    <example>

      <b>Example 1</b>

      The following example assumes that an ODBC data source called MyFoxSQLNT exists and is available. <b>SQLSTRINGCONNECT( )</b> returns a numeric value, which is stored to a variable named codegnHandle/code.
      If you successfully connect to the data source, <b>SQLSTRINGCONNECT( )</b> returns a positive number, a dialog box appears, and <b>SQLDISCONNECT( )</b> is called to disconnect from the data source.
      If you cannot connect to the data source, <b>SQLSTRINGCONNECT( )</b> returns a negative number and displays a message.
       <code language="X#">
        STORE SQLSTRINGCONNECT('dsn=MyFoxSQLNT;uid=myUserID;pwd=myPassword')
        TO gnConnHandle
        IF gnConnHandle &lt; 0
        = MESSAGEBOX('Cannot make connection', 16, 'SQL Connect Error')
        ELSE
        = MESSAGEBOX('Connection made', 48, 'SQL Connect Message')
        = SQLDISCONNECT(gnHandle)
        ENDIF
      </code>

      <b>Example 2</b>

      The following examples show how you can use the <b>SQLSTRINGCONNECT( )</b> function without a Data Source Name (DSN).
       <code language="X#">lcDSNLess="driver = SQL Server;server=&lt;servername&gt;;uid=&lt;userid&gt;;pwd=&lt;password&gt;"</code>
      -or-
       <code language="X#">lcDSNLess="driver = {SQL Server};server=&lt;servername&gt;;uid=&lt;userid&gt;;pwd=&lt;password&gt;" </code>
      -or-
       <code language="X#">
        lcDSNLess="DRIVER = {SQL Server};" ;
        + "SERVER=&lt;servername&gt;;" ;
        + "UID=&lt;userid&gt;;" ;
        + "PWD=&lt;password&gt;;" ;
        + "DATABASE=PUBS;" ;
        + "WSID=&lt;machine name or userid&gt;;" ;
        + "APP=MicroX(R) Sample App"
        lnConnHandle=SQLSTRINGCONNECT(m.lcDSNLess)
      </code>

      <b>Example 3</b>

      Each of the following examples creates a new shared connection. In the first statement, the Select Connection or Data Source Dialog Box appears and <b>SQLSTRINGCONNECT( )</b> creates the resulting connection as shared.
       <code language="X#">
        SQLSTRINGCONNECT(.T.)
        SQLSTRINGCONNECT('myConnectionString', .T.)
      </code>
    </example>
  </sqlstringconnect>
  <sqltables>
    <summary>
      Stores the names of tables in a data source to a X# cursor.
    </summary>
    <param name="nStatementHandle">

      Specifies the statement handle to the data source returned by SQLCONNECT( ).

    </param>
    <param name="cTableTypes">

      Specifies one or more table types. Valid table types are 'TABLE,' 'VIEW,' 'SYSTEM TABLE,' or any valid data source-specific table type identifier. If you include a list of table types, separate the table types with commas.
      All table names in the data source are selected if you omit cTableTypes or if cTableTypes is the empty string.
      The table type you specify must be delimited with single quotation marks. The following example demonstrates how to specify the 'VIEW' and 'SYSTEM TABLE' table types as a string literal.
       <code language="X#">? SQLTABLES(handle, "'VIEW', 'SYSTEM TABLE'", "mydbresult")</code>

    </param>
    <param name="cCursorName">

      Specifies the name of the X# cursor to which the result set is sent. If you don't include a cursor name, X# uses the default name SQLRESULT. The structure of the results depends on the internal SQLTABLES( ) function for the ODBC Handle.
    </param>
    <returns>
      Numeric. SQLTABLES( ) returns 1 if the cursor is successfully created, 0 if SQLTABLES( ) is still executing, – 1 if a connection level error occurs, and – 2 if an environment level error occurs.
    </returns>
    <remarks>
      SQLTABLES( ) is one of the four functions that you can execute either synchronously or asynchronously. The setting of the SQLSETPROP( ) asynchronous option determines if these functions execute synchronously or asynchronously. In asynchronous mode, you must call SQLTABLES( ) repeatedly until it returns a value other than False (.F.), meaning the function is still executing.
    </remarks>
    <example>
       <code language="X#">
        STORE SQLCONNECT('MyFoxSQLNT', '&lt;userid&gt;', '&lt;password&gt;') TO gnConnHandle
        IF gnConnHandle &lt; 0
        = MESSAGEBOX('Cannot make connection', 16, 'SQL Connect Error')
        ELSE
        = MESSAGEBOX('Connection made', 48, 'SQL Connect Message')
        STORE SQLTABLES(gnConnHandle, 'TABLE', 'mycursor') TO nTables
        IF nTables = 1
        SELECT mycursor
        LIST
        ENDIF
        ENDIF
      </code>
    </example>
  </sqltables>
  <strconv>
    <summary>
      Converts character expressions between single-byte, double-byte, UNICODE, and locale-specific representations.
    </summary>
    <param name="cExpression">

      Specifies the character expression that STRCONV( ) converts.

    </param>
    <param name="nConversionSetting">

      Specifies the type of conversion. The following table lists the values of nConversionSetting and the type of conversion performed.
      1
      Converts single-byte characters in cExpression to double-byte characters.
      Supported for Locale ID only (specified with the nRegionalIdentifier or nRegionalIDType parameters).
      2
      Converts double-byte characters in cExpression to single-byte characters.
      3
      Converts double-byte Katakana characters in cExpression to double-byte Hiragana characters.
      4
      Converts double-byte Hiragana characters in cExpression to double-byte Katakana characters.
      5
      Converts double-byte characters to UNICODE (wide characters).
      6
      Converts UNICODE (wide characters) to double-byte characters.
      7
      Converts cExpression to locale-specific lowercase.
      8
      Converts cExpression to locale-specific uppercase.
      9
      Converts double-byte characters in cExpression to UTF-8
      10
      Converts Unicode characters in cExpression to UTF-8
      11
      Converts UTF-8 characters in cExpression to double-byte characters.
      12
      Converts UTF-8 characters in cExpression to UNICODE characters.
      13
      Converts single-byte characters in cExpression to encoded base64 binary.
      14
      Converts base64 encoded data in cExpression to original unencoded data.
      15
      Converts single-byte characters in cExpression to encoded hexBinary.
      16
      Converts single-byte characters in cExpression to decoded hexBinary.

    </param>
    <param name="nRegionalIdentifier">

      Specifies the Locale ID, code page, or FontCharSet value to use for the conversion. If nRegionalIDType is omitted, the Locale ID is used for the conversion. If nRegionalIdentifier is omitted, the system locale ID is used by default.
      If nRegionalIdentifier is invalid or not supported on the machine, the error "Invalid locale ID" is generated.
      1029
      Czech
      1031
      German
      1033
      English (Default)
      1034
      Spanish
      1036
      French
      1040
      Italian
      1045
      Polish
      1046
      Portuguese (Brazil)
      2070
      Portuguese (Portugal)

    </param>
    <param name="nRegionalIDType">

      Specifies if a Locale ID, code page, or FontCharSet is used for the conversion.
      The nRegionalIdentifier parameter, described above, is used to specify the actual Locale ID, code page, or FontCharSet used for the conversion.
      nRegionalIDType
      0
      (Default) Specifies that the nRegionalIdentifier parameter is a Locale ID value.
      1
      Specifies that nRegionalIdentifier is a code page value.
      2
      Specifies that nRegionalIdentifier is a FontCharSet value.

    </param>
    <returns>
      Character data type. STRCONV( ) returns the converted character expression.
    </returns>
    <remarks>
      X# disregards invalid characters or incorrect length in base 64- and hexBinary- encoded strings.
      This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
    </remarks>
  </strconv>
  <strextract>
    <summary>
      Retrieves a string between two delimiters.
    </summary>
    <param name="cSearchExpression">

      Specifies the string to search.

    </param>
    <param name="cBeginDelim">

      Specifies the character that delimits the beginning of cSearchExpression.

    </param>
    <param name="cEndDelim">

      Specifies the character that delimits the end of cSearchExpression.

    </param>
    <param name="nOccurrence">

      Specifies at which occurrence of cBeginDelim in cSearchExpression to start the extraction.

    </param>
    <param name="nFlag">

      Specify the type of controls placed on the search. The number you specify in nFlag provides a bit-value that determines options according to the following table:
      0
      1
      Case-insensitive search
      2
      End delimiter not required. Specifies that a search, which finds no occurrence of cEndDelim, returns the contents of cSearchExpression from the cBeginDelim location.
      4
      Include the delimiters in the returned expression.
      Character or Varbinary.br
      The Result data type is derived by the first parameter data type.
    </param>
    <remarks>
      The default is a case sensitive search in which delimiters must be found (no nFlag value).
      If cBeginDelim is an empty string, the search is conducted from the beginning of cSearchExpression to the first occurrence of cEndDelim. If cEndDelim is an empty string STREXTRACT( ) returns a string from nOccurrence of cBeginDelim to the end of cSearchExpression.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        SET PATH TO (HOME(2) + 'Data\')   &amp;&amp;Set path to the customer table
        USE customer &amp;&amp; any table
        ?cursortoxml(0,"x",1,0,2)   &amp;&amp; Produce variable "x" that has XML of  first 2 records of table
        ?x         &amp;&amp; show the XML
        xmlproc(x,0)      &amp;&amp; Parse the XML
        PROCEDURE xmlproc(x as String, nLev as Integer)   as void
        LOCAL cTagName, cContents, mterm
        DO WHILE .t.
        cTagName = STREXTRACT(x,"&lt;","&gt;")
        IF LEN(cTagName) = 0   &amp;&amp; no tag found
        ??' ',x   &amp;&amp; print out raw string as contents
        EXIT
        ENDIF
        IF RIGHT(cTagName,1) = '/'   &amp;&amp; like "&lt;region/&gt;"
        cTagName = LEFT(cTagName, LEN(cTagName)-1)
        cContents=""
        mterm = "&lt;"+cTagName+"/&gt;"   &amp;&amp; "&lt;region/&gt;"
        ELSE
        mterm = "&lt;/"+cTagName+"&gt;"   &amp;&amp; "&lt;/region&gt;"
        cContents = STREXTRACT(x,"&lt;"+cTagName+"&gt;", mterm,1,2)
        ENDIF
        ?REPLICATE("  ",nLev),nLev+1,PADR(cTagName,20)
        xmlproc(cContents, nLev+1)
        x = STREXTRACT(x, mterm)   &amp;&amp; get the rest of the xml
        ENDDO
      </code>
    </example>
  </strextract>
  <strtofile>
    <summary>
      Writes the contents of a character string to a file.
      STRTOFILE( ) does not write to hidden files when running X# on Windows 2000 and later.
    </summary>
    <param name="cExpression">

      Specifies the character string that is written to the file. cExpression can be a literal character string, an expression that evaluates to a character string, or a character type variable, array element, or field.

    </param>
    <param name="cFileName">

      Specifies the name of the file to which the character string is written. Include a path with the file name if the file is in a directory other than the current default directory. If the file you specify does not exist, X# automatically creates it.

      lAdditive (for backward compatibility)
      Specifies whether the character string is appended to the end of the file. If lAdditive is true (.T.), the character string is appended to the end of the file.
      If lAdditive is false (.F.) (the default), the file is overwritten with the character string. You are asked if you want to overwrite an existing file if SET SAFETY is set to ON. If SET SAFETY is set to OFF, the file is overwritten without warning.
    </param>
    <param name="nFlag">

      Beginning with X# 7, you can use the nFlag parameter instead of lAdditive which enables you to also chose to write UTF-8 and Unicode Byte Order Marks. The following table describes the valid nFlag values.
      0 (default)
      0000
      The file is overwritten with the character string (formerly lAdditive=.f.)
      1
      0001
      The string is appended to the end of the file (formerly lAdditive=.t.).
      2
      0010
      Write Unicode Byte Order Mark (BOM) FF FE at the beginning of file. cExpression is assumed to be UNICODE, therefore no translation is performed. The file is overwritten
      4
      0100
      Write UTF-8 Byte Order Mark (BOM) EF BB BF at the beginning of file. cExpression is assumed to be UTF-8, therefore no translation is performed. The file is overwritten.
    </param>
    <returns>
      Numeric; the number of bytes written to the file.
    </returns>
    <remarks>
      An nFlag value of 3 or 5 is not valid. You cannot attempt to write a new Byte Order Mark if nFlag bit 1, Additive, is set.
      Unlike earlier versions of X#, STRTOFILE( ) opens a file in Shared rather than Exclusive mode. This is useful when multiple servers attempt to simultaneously write to the same file. Because of this change, you might not need to check for STRTOFILE( ) to return 0 (failure to open a file).
    </remarks>
  </strtofile>
  <sys>
    <summary>
      Returns system information or sets its behavior.
    </summary>
    <param name="nSetting">Number of setting to query or change</param>
    <param name="uNewValue">Optional new value for setting</param>
  </sys>
  <sysmetric>
    <summary>
      Returns the size of the operating system's screen elements.
    </summary>
    <param name="nScreenElement">

      Specifies a screen element. The following table shows values for nScreenElement and the corresponding screen element:
      1
      Screen width
      2
      Screen height.
      3
      Width of sizable window frame
      4
      Height of sizable window frame
      5
      Width of scroll arrows on vertical scroll bar
      6
      Height of scroll arrows on vertical scroll bar
      7
      Width of scroll arrows on horizontal scroll bar
      8
      Height of scroll arrows on horizontal scroll bar
      9
      Height of window title
      10
      Width of non-sizable window frame
      11
      Height of non-sizable window frame
      12
      Width of DOUBLE or PANEL window frame
      13
      Height of DOUBLE or PANEL window frame
      14
      Scroll box width on horizontal scroll bar in text editing windows
      15
      Scroll box height on vertical scroll bar in text editing windows
      16
      Minimized window icon width
      17
      Minimized window icon height
      18
      Maximum insertion point width
      19
      Maximum insertion point height
      20
      Single-line menu bar height
      21
      Maximized window width
      22
      Maximized window height
      23
      Kanji window height
      24
      Minimum sizable window width
      25
      Minimum sizable window height
      26
      Minimum window width
      27
      Minimum window height
      28
      Window controls width
      29
      Window controls height
      30
      1 if mouse hardware present; otherwise 0
      31
      1 for Microsoft Windows debugging version; otherwise 0
      32
      1 if mouse buttons swapped; otherwise 0
      33
      Width of a button in a half-caption window's caption or title bar
      34
      Height of half-caption window caption area
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      SYSMETRIC( ) returns the size of screen elements. Screen elements include menus, windows, window controls, and the insertion point. Values are returned in pixels unless otherwise noted and can vary for different displays, display drivers, and video hardware. For further information on screen elements, refer to the GetSystemMetrics function in the MSDN Library at <b>http://msdn.microsoft.com/library</b>.
      SYSMETRIC( ) enables you to determine the size of menus, windows, and window controls you create in X#. Windows and menus created with DEFINE WINDOW and DEFINE MENU use the same screen element sizes as the operating system's windows and menus.
    </remarks>
  </sysmetric>
  <tablerevert>
    <summary>
      Discards changes made to a buffered row or a buffered table or cursor and restores the OLDVAL( ) data for remote cursors and the current disk values for local tables and cursors.
      On a network, the data currently on disk might differ from the data on the disk when the table was opened or the cursor was created. Other users on the network might have changed the data after the table was opened or the cursor was created.
    </summary>
    <param name="lAllRows">

      Determines whether all changes made to the table or cursor are discarded. The following table describes the values for lAllRows.
      False (.F.)
      If table buffering is enabled, only changes made to the current record in the table or cursor are discarded. (Default)
      True (.T.)
      If table buffering is enabled, changes made to all records are discarded in the table or cursor.
      If row buffering is enabled, X# disregards the value of lAllRows, and changes made to the current record in the table or cursor are discarded.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table or cursor in which the changes are discarded.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor in which the changes are discarded.
    </param>
    <returns>
      Numeric data type. TABLEREVERT( ) returns the number of records for which changes were discarded.
    </returns>
    <remarks>
      TABLEREVERT( ) cannot discard changes made to a table or cursor that does not have row or table buffering enabled. If you issue TABLEREVERT( ) and row or table buffering is not enabled, X# generates an error message. Use CURSORSETPROP( ) to enable or disable row and table buffering.
      Changes are discarded in the table or cursor open in the currently selected work area if TABLEREVERT( ) is issued without the optional cTableAlias or nWorkArea arguments.
      TABLEREVERT( ) does not return the record pointer to its original position.
      TABLEREVERT( ) operates on CursorAdapter objects in the same way as other buffered cursors.
      In X# 9.0, you cannot issue the TABLEREVERT( ) function when a TABLEUPDATE( ) is in operation.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        SET MULTILOCKS ON  &amp;&amp; Must be on for table buffering
        SET PATH TO (HOME(2) + 'data\')     &amp;&amp; Sets path to database
        OPEN DATABASE testdata  &amp;&amp; Open testdata database
        USE Customer     &amp;&amp; Open customer table
        = CURSORSETPROP('Buffering', 5, 'customer')  &amp;&amp; Enable table buffering
        CLEAR
        ? 'Original cust_id value: '
        ?? cust_id  &amp;&amp; Displays current cust_id value
        REPLACE cust_id    WITH '***'  &amp;&amp; Changes field contents
        ? 'New cust_id value: '
        ?? cust_id  &amp;&amp; Displays new cust_id value
        = TABLEREVERT(.T.)  &amp;&amp; Discard all table changes
        ? 'Reverted cust_id value: '
        ?? cust_id  &amp;&amp; Displays reverted cust_id value
      </code>
    </example>
  </tablerevert>
  <tableupdate>
    <summary>
      Commits changes made to a buffered row, a buffered table, cursor, or cursor adapter.
    </summary>
    <param name="nRows">

      Specifies which changes made to the table or cursor should be committed.
      X# enables Optimistic Row Buffering by default for those cursors associated with a <b>CursorAdapter</b> object.
      The following table describes the values for nRows.
      0
      If row or table buffering is enabled, commit only the changes made to the current row in the cursor. (Default)
      When working with <b>CursorAdapter</b> objects, X# executes the appropriate command in the InsertCmd, UpdateCmd, or DeleteCmd property for that row only.
      1
      If table buffering is enabled, commit changes made to all records to the table or cursor.
      If row buffering is enabled, commit only changes made to the current record in the table or cursor.
      When working with <b>CursorAdapter</b> objects, X# executes the appropriate commands in the <b>InsertCmd</b>, <b>UpdateCmd</b>, and <b>DeleteCmd</b> properties for each affected row.
      Commit changes made to the table or cursor in the same manner as when nRows = 1. However, an error does not occur when a change cannot be committed. X# continues to process any remaining records in the table or cursor.
      If cErrorArray is included, an array containing error information is created when an error occurs.
      For compatibility with previous X# applications, the nRows parameter also accepts False (.F.) and True (.T.) instead of 0 and 1 respectively.
      When specifying 0 or 1 for nRows, the record pointer remains on the record where changes could not be committed. To determine why the changes could not be committed, use the AERROR( ) function.
      When working with <b>CursorAdapter</b> objects and specifying 1 or 2 for nRows, all changes made to the cursor in the following <b>CursorAdapter</b> events must be committed during the same call to <b>TABLEUPDATE( )</b> unless an error occurs:
      <b>BeforeInsert</b>

      <b>AfterInsert</b>
      <b>BeforeDelete</b>
      <b>AfterDelete</b>
      <b>BeforeUpdate</b>
      <b>AfterUpdate</b>
      X# passes the values of nRows to the <b>CursorAdapter</b> BeforeCursorUpdate event.

    </param>
    <param name="lForce">

      Determines whether X# overwrites changes made to the table or cursor by another user on a network.
      The following table describes the values for lForce.
      False (.F.)
      Commits changes to the table or cursor, starting with the first record and continuing towards the end of the table or cursor. (Default)
      True (.T.)
      Overwrites any changes made to the table or cursor by another user on a network. The <b>WHERE</b> clause uses only key fields.
      When working with <b>CursorAdapter</b> objects, X# passes the value of lForce to the following <b>CursorAdapter</b> events:
      BeforeCursorUpdate

      BeforeInsert
      BeforeUpdate
      BeforeDelete
      AfterInsert
      AfterUpdate
      AfterDelete

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table or cursor in which the changes are committed. If you include a table or cursor alias, you must include the lForce argument.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table or cursor in which the changes are committed. If you include a work area, you must include the lForce argument.

    </param>
    <param name="cErrorArray">

      Specifies the name of an array created when nRows = 2 and changes to a record cannot be committed. The array contains a single column containing the record numbers of the records for which changes could not be committed. If you include an array name, you must include either a table or cursor alias cTableAlias or a work area number nWorkArea.
      If an error other than a simple commit error occurs while updating records, the first element of cErrorArray will contain –1, and you can then use <b>AERROR( )</b> to determine the why the changes could not be committed.
      X# passes the value of cErrorArray, when it exists, to the <b>CursorAdapter</b> AfterCursorUpdate event.
    </param>
    <returns>
      Logical data type. <b>TABLEUPDATE( )</b> returns True (.T.) if changes to all records are committed.
      Otherwise, <b>TABLEUPDATE( )</b> returns False (.F.) indicating a failure. An ON ERROR routine isn't executed. The AERROR( ) function can be used to retrieve information about the cause of the failure.
      <b>TABLEUPDATE( )</b> always returns True (.T.) when you are updating data, using Table Buffering, and updating the table or tables in the data source from multiple clients when setting <b>BatchUpdateCount</b> to a value greater than 1. Therefore, avoid setting <b>BatchUpdateCount</b> to a value greater than 1 in these scenarios.
    </returns>
    <remarks>

      <b>TABLEUPDATE( )</b> cannot commit changes made to a table or cursor that does not have row or table buffering enabled. If you issue <b>TABLEUPDATE( )</b> and row or table buffering is not enabled, X# generates an error message. However, <b>TABLEUPDATE( )</b> can still commit changes to a table or cursor that has validation rules. To enable or disable row and table buffering, use <b>CURSORSETPROP( )</b>.
      Changes are committed to the table or cursor open in the currently selected work area if <b>TABLEUPDATE( )</b> is issued without the optional cTableAlias or nWorkArea arguments.
      If table buffering is used and multiple records are updated, <b>TABLEUPDATE( )</b> moves the record pointer to the last record updated.
      Calling <b>TABLEUPDATE( )</b> for a local table or view that does not use key fields generates a long <b>WHERE</b> clause to find the update row. The default number of fields supported in the <b>WHERE</b> clause is 40. If you receive the error SQL: Statement too long (Error 1812), you should either use a key field for the update or increase the complexity of the <b>WHERE</b> clause with SYS(3055). If you use the <b>SYS(3055)</b> function, increase its value to a number that is eight times the number of fields in the table as shown in the following example:
       <code language="X#">SYS(3055, 8 * MIN(40, FCOUNT( ))</code>
      When performing a batched <b>TABLEUPDATE( )</b> operation, due to the way that Open Database Connectivity (ODBC) behaves, X# is unable to detect conflicts when no error is generated by the server, yet nothing is updated, for example, no row matches the <b>WHERE</b> clause. This can occur when you use WhereType set to DB_KEYANDUPDATABLE, DB_KEYANDMODIFIED, or DB_KEYANDTIMESTAMP, and another user has changed one of the underlying values in the <b>WHERE</b> clause such that the row is not found by the update statement.

      <b>Interaction with CursorAdapter Objects</b>   The following behaviors apply when working with <b>CursorAdapter</b> objects:

      <b>TABLEUPDATE( )</b> operates only on the cursor associated with the <b>CursorAdapter</b> object.

      <b>TABLEUPDATE( )</b> executes commands according to the data source type and those stored in the <b>CursorAdapter</b> <b>InsertCmd</b>, <b>UpdateCmd</b>, or <b>DeleteCmd</b> properties against the current cursor row or rows as appropriate.

      <b>TABLEUPDATE( )</b> passes the value of codeGETFLDSTATE(1)/code to the following <b>CursorAdapter</b> events of each row affected:

      BeforeInsert


      BeforeUpdate


      BeforeDelete

      For more information about <b>GETFLDSTATE( )</b>, see GETFLDSTATE( ) Function.
      The successful completion of <b>TABLEUPDATE( )</b> resets the field states according to usual <b>TABLEUPDATE( )</b><b> </b>behavior.
      When table buffering is enabled, you can move away from the current record in the following <b>CursorAdapter</b> events:

      BeforeInsert


      AfterInsert


      BeforeUpdate


      AfterUpdate


      BeforeDelete


      AfterDelete

      You can also modify data in the cursor. This functionality supports scenarios such as retrieving the autoincrement value from the base table and inserting it into the cursor. When this scenario occurs, the <b>CursorAdapter</b> object should automatically return to the record whose changes are about to be committed after the event has occurred and commit the changes.
      In X# 9.0, you cannot issue the TABLEREVERT( ) Function when a TABLEUPDATE( ) is in operation.
      Typically, the CursorAdapter object uses the transaction management functionality provided by the ADO or ODBC API's and X# closes transactions when the TABLEUPDATE( ) function completes successfully. However, if you want to send transaction management commands directly to the backend, you can set the UseTransactions property of the CursorAdaptor object to False (.F.) and the CursorAdapter does not use transactions to send Insert, Update, or Delete commands.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CREATE TABLE employee (cLastName C(10))
        SET MULTILOCKS ON  &amp;&amp; Must turn on for table buffering.
        = CURSORSETPROP('Buffering', 5, 'employee' )  &amp;&amp; Enable table buffering.
        INSERT INTO employee (cLastName) VALUES ('Smith')
        CLEAR
        ? 'Original cLastName value: '
        ?? cLastName  &amp;&amp; Displays current cLastName value (Smith).
        REPLACE cLastName WITH 'Jones'
        ? 'New cLastName value: '
        ?? cLastName  &amp;&amp; Displays new cLastName value (Jones).
        = TABLEUPDATE(.T.)  &amp;&amp; Commits changes.
        ? 'Updated cLastName value: '
        ?? cLastName  &amp;&amp; Displays current cLastName value (Jones).
      </code>
    </example>
  </tableupdate>
  <tag>
    <summary>
      Returns a tag name from an open compound index (.cdx) file or the name of an open single-entry (.idx) index file.
    </summary>
    <param name="CDXFileName">

      Specifies the name of the .cdx file to return a tag name from.

    </param>
    <param name="nTagNumber">

      Specifies a number corresponding to the order in which a tag was created in the compound index file.
      For example, if nTagNumber is 1, <b>TAG( )</b> returns the name of the first tag created in the compound index file. If nTagNumber is 2, <b>TAG( )</b> returns the name of the second tag created, and so on. TAG( ) returns the empty string when nTagNumber exceeds the number of tag names.
      If you omit CDXFileName, <b>TAG( )</b> returns compound index file tag names and single-entry index file names in a specific order as follows:
      Names of single-entry index files are returned based on their order in the <b>INDEX</b> clause of <b>USE</b> or <b>SET INDEX</b>. For more information, see USE Command and SET INDEX Command.
      Tag names from the structural compound index file (if one exists for the table) are returned.
      Tag names from other open compound index files are returned, again in the order in which the tags were created in the compound index files and in the order in which the compound index files are specified in the <b>INDEX</b> clause for <b>USE</b> or <b>SET INDEX</b>.

      nWorkArea| cTableAlias
      Returns tag names and index file names from files open in another work area. nWorkArea specifies a work area number and cTableAlias specifies a table alias. By default, tag names and index file names are returned from files in the current work area.
    </param>
    <returns>
      Character. <b>TAG( )</b> returns an index tag name as an uppercase character string.
    </returns>
    <remarks>
      Tags are index entries in compound index (.cdx) files created with the <b>INDEX</b> command. Single-entry index (.idx) files contain only one entry; therefore, <b>TAG( )</b> returns the file name for .idx files.
      A structural compound index (.cdx) file opens with its table automatically. You can open non-structural .cdx files and .idx index files for a table using the <b>INDEX</b> clause in the <b>USE</b> command or using the <b>SET INDEX</b> command.
    </remarks>
    <example>

      <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\TestData')
        USE Customer
        CLEAR
        FOR nCount = 1 TO TAGCOUNT()
        ? TAG(CDX(1),nCount)
        ENDFOR
      </code>
    </example>
  </tag>
  <tagcount>
    <summary>
      Returns the number of .cdx compound index file tags and open .idx single-entry index files.
    </summary>
    <param name="CDXFileName">

      Specifies the name of a compound index file for which TAGCOUNT( ) returns the number of tags. If CDXFileName does not exist for the current table, you must specify the nWorkarea or cTableAlias in which it does exist.
      If you omit CDXFileName, TAGCOUNT( ) returns the number of tags in all .cdx compound index files and open .idx single-entry index files in the currently selected work area or alias.

    </param>
    <param name="nWorkarea">

      Specifies the work area of the table for which TAGCOUNT( ) returns the number of tags for the .cdx compound index file.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which TAGCOUNT( ) returns the number of tags for the .cdx compound index file.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      Included for compatibility with dBASE.
    </remarks>
  </tagcount>
  <tagno>
    <summary>
      Returns the index position for .cdx compound index file tags and open .idx single-entry index files.
    </summary>
    <param name="IndexName">

      Specifies the name of a .cdx compound index file tag or an open .idx single-entry index file for which TAGNO( ) returns the index position.

    </param>
    <param name="CDXFileName">

      Specifies the name of a .cdx compound index file containing the name of the tag you specify with IndexName.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table for which TAGNO( ) returns the index position for .cdx compound index file tags and .idx single-entry index files.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which TAGNO( ) returns the index position for .cdx compound index file tags and .idx single-entry index files.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      TAGNO( ) returns 0 if a master index is not set (the table is in natural record number order) and the optional parameters are omitted.
      Included for compatibility with dBASE.
    </remarks>
  </tagno>
  <target>
    <summary>
      Returns the alias of a table that is the target for a relation as specified in the INTO clause of SET RELATION.
    </summary>
    <param name="nRelationshipNumber">

      Specifies the number of a relationship. Include a number from 1 to the number of relationships out of the specified work area. The aliases of the target tables are returned (in no specific order) until nRelationshipNumber is greater than the number of relationships. When nRelationshipNumber is greater than the number of relationships, the empty string is returned.

      nWorkArea| cTableAlias
      Returns the alias of the target table in another work area. nWorkArea specifies a work area number and cTableAlias specifies a table alias. By default, the alias of the target table from the current work area is returned if you don't specify the work area or alias.
    </param>
    <returns>
      Character
    </returns>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE orders IN 0 ORDER order_id
        USE customer IN 0 ORDER cust_id
        SELECT orders
        SET RELATION TO cust_id INTO customer
        ? TARGET(1)  &amp;&amp; Displays customer
        ? TARGET(2)  &amp;&amp; Empty string
      </code>
    </example>
  </target>
  <textmerge>
    <summary>
      Provides evaluation of a character expression.
    </summary>
    <param name="cExpression">

      Specifies the string expression to be evaluated.

    </param>
    <param name="lRecursive">

      Specifies whether to repeatedly iterate through all levels of delimiters in cExpression, evaluating until no text merge delimiters remain.

    </param>
    <param name="cLeftDelim">

      Specifies the left delimiter to use for the text merge search. cLeftDelim is limited to two characters.

    </param>
    <param name="cRightDelim">

      Specifies the right delimiter to use for the text merge search. cRightDelim is limited to two characters.
    </param>
    <returns>
      Character string. Represents the value of cExpression, the merged text.
    </returns>
    <remarks>
      The cLeftDelim and cRightDelim parameters temporarily override any SET TEXTMERGE DELIMITERS values.
      The TEXTMERGE( ) function responds to current settings of SET TEXTMERGE SHOW | NOSHOW.
    </remarks>
    <example>
       <code language="X#">
        SET TEXTMERGE OFF
        TEXT to myvar noshow &amp;&amp;textm
        this is a test   &lt;&lt;datetime()&gt;&gt;
        &lt;&lt;program(-1)&gt;&gt;
        &lt;&lt;myvar&gt;&gt;
        textmerge(myvar) (this line is literal)
        &lt;&lt;doit(myvar)&gt;&gt;   (cause recursion
        END of orig text
        endtext
        ?myvar
        ?"Now starting textmerge"
        ?textmerge(myvar)
        PROCEDURE doit(myvar)
        *  r=i   &amp;&amp; cause an error
        if program(-1) &gt; 3
        return "THEEND*********"
        endif
        return textmerge(myvar)
      </code>
    </example>
  </textmerge>
  <ttoc>
    <summary>
      Converts a <b>DateTime</b> expression to a <b>Character</b> value with the specified format.
    </summary>
    <param name="tExpression">

      Specifies a <b>DateTime</b> expression to convert into a character string.
      If tExpression contains only a time, X# adds the default date of 12/30/1899 to tExpression. If tExpression contains only a date, X# adds a default time of 12:00:00 AM (if SET HOURS is 12) or 00:00:00 (if SET HOURS is 24) to tExpression to produce a valid DateTime value.
      1
      Returns tExpression as a character string in a format suitable for indexing. The character string returned has a 14-character format, yyyymmddhhmmss, that is not affected by the <b>SET CENTURY</b>, the <b>SET HOURS</b>, or <b>SET SECONDS</b> commands. For more information, see SET CENTURY, SET HOURS, and SET SECONDS.
      2
      Returns tExpression as a character string containing only the time portion of tExpression.
      To control whether to include the seconds of the time portion in the character string, set the <b>SET SECONDS</b> and <b>SET DATE</b> commands. The <b>SET HOURS</b> command determines if AM or PM is appended to the time portion returned.
      For more information, see SET DATE and SET HOURS.
      If <b>SET DATE</b> is set to <b>LONG</b> or <b>SHORT</b>, the format of the time setting in the Windows Control Panel determines the format of the character string.
      3
      Returns tExpression as a character string with the XML DateTime format. The character string returned has a 19-character yyyy-mm-ddThh:mm:ss format that is not affected by the settings of the <b>SET CENTURY</b>, <b>SET HOURS</b>, or <b>SET SECONDS</b> commands.
    </param>
    <returns>
      Character. <b>TTOC( )</b> returns a <b>DateTime</b> expression as a character string.
      When passing the value 1 or 3 as the second parameter, the character string returned does not include the AM or PM designations to indicate times before or after noon, respectively. Instead, the string uses a 24-hour clock, also known as military time. For example, the time 18:30:00 is equivalent to 06:30:00 PM.
    </returns>
    <remarks>
      If an invalid value is passed as the second parameter, <b>TTOC( )</b> handles the invalid value as if it was a value of 1.
    </remarks>
    <example>
       <code language="X#">
        STORE DATETIME( ) TO gtDateTime
        ? "gtDateTime has type: "+TYPE('gtDateTime')
        gtDateTime = TTOC(gtDateTime)
        ? "gtDateTime is now type: "+TYPE('gtDateTime')
      </code>
    </example>
  </ttoc>
  <txnlevel>
    <summary>
      Returns a numeric value indicating the current transaction level.
    </summary>
    <returns>
      TXNLEVEL( )Return Value
      Numeric
    </returns>
    <remarks>
      Use BEGIN TRANSACTION to create a transaction. Transactions are nested by issuing BEGIN TRANSACTION when another transaction is in progress. Transactions can be nested in this manner to five levels. Use TXNLEVEL( ) to determine the current transaction level.
      TXNLEVEL( ) returns a value from 0 to 5. TXNLEVEL( ) returns 0 if a transaction is not in progress.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE Customer     &amp;&amp; Open customer table
        CLEAR
        BEGIN TRANSACTION
        tLevel = ALLTRIM(STR(TXNLEVEL()))
        =MESSAGEBOX("Current Transaction: " + tLevel, 0, "Transaction Level")
        BEGIN TRANSACTION
        tLevel = ALLTRIM(STR(TXNLEVEL()))
        =MESSAGEBOX("Current Transaction: " + tLevel, 0, ;
        "Transaction Level")
        END TRANSACTION
        END TRANSACTION
      </code>
    </example>
  </txnlevel>
  <txtwidth>
    <summary>
      Returns the length of a character expression with respect to the average character width for a font.
    </summary>
    <param name="cExpression">

      Specifies a character expression for which TXTWIDTH( ) returns the length. If you include only cExpression, the length of the character expression is returned for the current font for the main X# window or the active output window. A non-proportional font always returns a value equal to the number of characters in cExpression.
      Include the optional arguments cFontName, nFontSize and cFontStyle to determine the length of a character expression with a specific font, font point size, or font style.

    </param>
    <param name="cFontName">

      Specifies the name of the font. Include cFontName to return the length of a character expression with a specific font.

    </param>
    <param name="nFontSize">

      Specifies a number that corresponds to the point size of the font. Include nFontSize to return the length of a character expression with a specific point size.

    </param>
    <param name="cFontStyle">

      Specifies a special font style for the character expression. cFontStyle is a font style code specified by a character or a set of characters. The Normal font style is used if cFontStyle isn't included. Here are the characters for each font style:
      B
      Bold
      I
      Italic
      O
      Outline
      Q
      Opaque
      Shadow
      -
      Strikeout
      Transparent
      U
      Underline
      You can include more than one character to specify a combination of font styles. For example, BI specifies a Bold Italic font style.
      The following command displays a message in a Courier normal 24-point font, centered horizontally in the main X# window:
       <code language="X#">
        @ 25,(WCOLS( )-TXTWIDTH('Hello!','Courier ',24)* ;
        FONTMETRIC(6,'Courier ',24)/FONTMETRIC(6))/2  ;
        SAY 'Hello!' FONT 'Courier ',24
      </code>
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      TXTWIDTH( ) returns the number of characters a character expression cExpression occupies, based on the average character width of a specified font (the average character width of a font is called a foxel). Use FONTMETRIC(6) to determine the average character width of a font.
      If you don't include a font in TXTWIDTH( ), the value returned by TXTWIDTH( ) is determined by the current font for the main X# window, as long as output is directed to the main X# window when TXTWIDTH( ) is issued. If output is being directed to a user-defined window, the value returned is determined by the window's current font.
    </remarks>
  </txtwidth>
  <unique>
    <summary>
      Included for compatibility with dBASE.
       
    </summary>
  </unique>
  <vartype>
    <summary>
      Returns the data type of an expression.
      <b>VARTYPE( )</b> is similar to the <b>TYPE( )</b> function, but <b>VARTYPE( )</b> is faster and does not require quotation marks to enclose the expression for which the data type is returned.
    </summary>
    <param name="eExpression">

      Specifies the expression for which the data type is returned. <b>VARTYPE( )</b> returns a single character indicating the data type of the expression.
      The following table lists the characters that <b>VARTYPE( )</b> returns for each data type.
      C
      <b>Character</b>, <b>Memo</b>, <b>Varchar</b>, <b>Varchar</b> (Binary)
      D
      <b>Date</b>
      G
      <b>General</b>
      L
      <b>Logical</b>
      N
      <b>Numeric</b>, <b>Float</b>, <b>Double</b>, or <b>Integer</b>
      O
      Object
      Q
      <b>Blob</b>, <b>Varbinary</b>
      <b>DateTime</b>
      U
      Unknown or variable does not exist
      X
      Null
      <b>Currency</b>
      If eExpression is an array, the first element in the array is evaluated.

    </param>
    <param name="lNullDataType">

      Specifies whether <b>VARTYPE( )</b> returns the data type when eExpression contains the null value.
      The following table lists the values of lNullDataType.
      True (.T.)
      Return data type for eExpression.
      False (.F.) or omitted
      Return 'X' to indicate eExpression contains a null value.
    </param>
    <returns>
      Character. <b>VARTYPE( )</b> returns a character representing the data type of the specified expression.
    </returns>
  </vartype>
  <week>
    <summary>
      Returns a number representing the week of the year from a Date or DateTime expression.
    </summary>
    <param name="nFirstWeek">
      0
      Specifies that WEEK( ) return the week that is currently selected in the <b>First Week of Year</b> box on the Regional tab of the Options dialog box.
      1
      First week contains January 1st. This is the default when you omit nFirstWeek.
      2
      The larger half (four days) of the first week is in the current year.
      3
      First week has seven days.
      [, nFirstDayOfWeek]
      Specifies the first day of the week. The following table lists the values for nFirstDayOfWeek.
    </param>
    <param name="nFirstDayOfWeek">
      0
      Specifies that WEEK( ) return the day that is currently selected in the <b>Week Starts on</b> box on the Regional tab of the Options dialog box.
      1
      Sunday. This is the default when you omit nFirstDayOfWeek and is the first day of the week used in earlier FoxPro versions.
      2
      Monday
      3
      Tuesday
      4
      Wednesday
      5
      Thursday
      6
      Friday
      7
      Saturday
    </param>
    <returns>
      Numeric type. WEEK( ) returns a number representing the week of the year.
    </returns>
    <remarks>
      WEEK( ) returns a number from 1 to 53 that represents the week of the year. For example, WEEK( ) returns 1 for the first week of the year, 2 for the second week of the year, and so on. Note that a week can be split between years — the first week of the year can be in the current year and the previous year.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? WEEK(DATE( ))
        ? WEEK({^1998-02-16})  &amp;&amp; Displays 8
      </code>
    </example>
  </week>
  <wvisible>
    <summary>
      Determines if the specified window has been activated and isn't hidden.
    </summary>
    <param name="WindowName">

      Specifies the name of the window WVISIBLE( ) evaluates. In X#, you can also specify the name of a toolbar. You can also include the empty string in WindowName to specify the main X# window.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      WVISIBLE( ) returns true (.T.) if the specified window is shown or activated and isn't hidden. Windows are shown and activated with SHOW WINDOW and ACTIVATE WINDOW.
      WVISIBLE( ) returns false (.F.) if the window has not been activated, has been hidden with HIDE WINDOW, has been deactivated with DEACTIVATE WINDOW, or doesn't exist.
    </remarks>
    <example>
       <code language="X#">
        ACTIVATE WINDOW View
        ? WVISIBLE( "View" ) &amp;&amp; return .T.
        DEACTIVATE WINDOW View
        ? WVISIBLE( "View" ) &amp;&amp; return .F.
      </code>
    </example>
  </wvisible>
  <xmltocursor>
    <summary>
      Converts XML text into a X# cursor or table.
    </summary>
    <param name="eExpression">

      Specifies the XML text or an expression that evaluates to valid XML data. The eExpression parameter can be a X# memory variable, memo field contents, the return from an HTTP request, the return result from a SOAP method call, XML from the XMLDOM, or an ADO stream.
      XMLTOCURSOR( ) generates an error if eExpression is not found or if eExpression does not parse to valid XML.

    </param>
    <param name="cXMLFile">

      Specifies the name, and, optionally, the path of a physical XML file that resides on your local computer or network.
      If you do not specify a path, X# searches the path along the X# directory for the XML file.

    </param>
    <param name="cCursorName">

      Specifies the name of the cursor to store the result and creates the cursor in the current work area.
      If the cursor name already exists or is open, X# closes the cursor and creates a new one in an unused work area. If you omit or pass an empty string ("") for cCursorName, X# creates a cursor named "XMLRESULT" for returning the result.
      If cCursorName contains data and nFlags is set to 8192, X# appends the data being imported from the XML file to the existing table or cursor. The table or cursor must be open or in use. If cCursorName is an empty string (""), X# imports XML into the table or cursor that is open in the current work area.

    </param>
    <param name="nFlags">

      Specifies how XMLSource eExpression is handled in <b>XMLTOCURSOR( )</b>. The following table describes the values for nFlags.
      0
      0000
      (Default) Treats the first parameter as a string containing XML data.
      4
      0100
      Preserves white space in data and overrides the xml:space attribute of the XML data.
      512
      01000000000
      Specifies that the first parameter, either an eExpression or a cXMLFile, is a string containing the name and path of an XML data file.
      1024
      10000000000
      NOCPTRANS – Creates <b>Character</b> and <b>Memo</b> fields in the resultant cursor with the NOCPTRANS option and inserts the text or XML values in the incoming elements into the <b>Character</b> or <b>Memo</b> field on an untranslated, byte-for-byte basis.
      When used with flag 1024, <b>XMLTOCURSOR( )</b> returns a string padded with trailing spaces equal to the actual string, that is, a string twice the length.
      2048
      100000000000
      Use when the imported schema has an XML schema definition (XSD) schema containing decimal data type with restrictions, or facets, of totalDigits="19" and fractionDigits="4."
      XSD data type values are mapped to the X# <b>Currency</b> data type in the resulting cursor.
      4096
      1000000000000   
      Disables <b>base64</b> decoding.
      In X#, base64 encoding is intended for encoding only binary data.
      8192
      1100000000
      Specifies that cCursorName is the name or alias of an existing table or cursor and imports the data from the specified XML file into an existing table or predefined cursor.
      If cCursorName contains data, the data imported from the XML file is appended to the existing data. If cCursorName is an empty string (""), the data from the XML file is imported into the table or cursor in the current work area.
      Setting nFlags to 8192 can be useful when an XML schema is not available or not practical for use.
      32768
      0x8000
      Indicates that a code page should be used.
      65536
      0x10000
      Maps XML Char fields to native Fox Varchar fields. If not specified, XML Char fields are mapped to Fox Character fields.
      131072
      0x20000
      Maps XML base64Binary fields to native Fox Varbinary fields if less than 255 bytes or Blob fields if greater than this length. If not specified, XML base64Binary fields are mapped to Fox Memo fields.
      When you use flag 8192, be aware of the following:
      You must make sure the table schema matches the incoming XML elements in the appropriate manner. X# enforces the data types in cCursorName as described in the Data Type Matching table in this topic but makes no other assumptions about data types. Attempting to import incompatible values generates the appropriate message.
      If the XML contains or references a schema, and the data types in the schema conflict with the data types of the cursor or table, the data types in the cursor or table are used.
      Element names in the XML file are mapped to the column names in cCursorName. In addition, X# imports only data from the element names in the XML file that match the column names in cCusorName.
      The cursor or table can have fewer columns than those in the XML file, but it must have at least one matching column. The cursor or table can have additional columns that do not correspond to an element in the XML file.
      If the table contains autoincrementing fields, <b>XMLTOCURSOR( )</b> fails if <b>AUTOINCERROR</b> is set to <b>ON</b>. Setting <b>AUTOINCERROR</b> to <b>OFF</b> or turning off autoincrementing in the target table by using <b>CURSORSETPROP( )</b> allows <b>XMLTOCURSOR( )</b> to succeed. The target table's autoincrementing field or fields are incremented according to the values specified, and the values in the source table are not copied.
      The following table describes data type matching restrictions when setting nFlags to 8192.
      <b>Character</b>, <b>Character</b> (Binary), <b>Memo</b>, <b>Memo</b> (Binary)
      Accepts any data but truncates any data exceeding the length of a <b>Character</b> column.
      Accepts numeric data within accepted range of the <b>Currency</b> type but truncates numbers outside this range.
      <b>Date</b>
      Accepts XML format date and dateTime values.
      X# converts the XML date and dateTime formats to the corresponding X# date. X# preserves only the M/D/Y portion of the XML date or dateTime value.
      <b>DateTime</b>
      X# converts the XML date and dateTime formats to the corresponding X# date and discards precision beyond the extent supported by X#.
      <b>Double</b>
      Accepts numeric data within the accepted range of the <b>Double</b> type but truncates numbers outside this range.
      <b>Integer</b>
      Accepts integer data within the accepted range of the <b>Integer</b> type but truncates numbers outside this range.
      <b>Logical</b>
      Accepts the values True, .T., 1, False, .F., and 0.
      <b>Numeric</b>, <b>Float</b>
      Accepts numeric data with or without decimals but truncates numbers outside the accepted range for these types according to X# rules or replaces with the numeric overflow indicator ("*************").
    </param>
    <returns>
      Numeric data type. <b>XMLTOCURSOR( )</b> returns the number of records created.
    </returns>
    <remarks>
      You can use <b>XMLTOCURSOR( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not supported because the <b>_VFP</b> system variable is not supported in the OLE DB Provider.
      To use the X# OLE DB Provider with <b>XMLTOCURSOR( )</b>, you must install MSXML 3.0 on the computer with the OLE DB Provider.

      <b>XMLTOCURSOR( )</b> generates a syntax error for record lengths greater than approximately 160 columns. The exact number of columns that cause an error depends on the length of the column names.

      <b>XMLTOCURSOR( ) </b>does not use the <b>Varchar</b> type when creating a cursor from an XML document. However, <b>XMLTOCURSOR( )</b> supports appending data into an existing cursor with <b>Varchar</b> fields.
      When calling <b>XMLTOCURSOR( )</b> in append mode, X# adds an empty row if no XML element name matches any table or cursor column.

      <b>XMLTOCURSOR( )</b> converts <b>Decimal</b> data type to <b>Numeric</b> 20,19 (width, precision). In versions prior to X# 8.0, <b>Decimal</b> mapped to <b>Numeric</b> 8,0.

      <b>Numeric Overflow Conditions</b>   <b>XMLTOCURSOR( )</b> imports XML data containing X# numeric overflow conditions, for example, "*******", in place of a numeric or integer value. If a schema is provided, X# creates the correct data type in the resulting cursor but changes the overflow from asterisk (*) characters to 0.0 or 0 values. Therefore, the XML parser used by <b>XMLTOCURSOR( )</b> does not throw an error as a result of character values stored in a decimal type element.
      For more information about converting XML to X# data, see Converting Between XML and X# Data.
    </remarks>
  </xmltocursor>
  <xmlupdategram>
    <summary>
      Mirrors changes made in a buffered table or cursor in an XML UpdateGram and returns a character string that contains the UpdateGram.
      An XML UpdateGram represents the before and after conditions of the changed portion of a X# table or cursor. Through additional processes, you can use an UpdateGram to commit these changes to the data represented by the XML UpdateGram document.
      To use <b>XMLUPDATEGRAM( )</b>, you must use <b>SET MULTILOCKS ON</b> and enable table buffering.
      Before calling <b>XMLUPDATEGRAM( )</b>, you should specify the key field list by calling <b>CURSORSETPROP( )</b> with the <b>KeyFieldList</b> property against existing cursors and tables. If you do not specify key fields, both the before and after representations contains all the fields in the table. If you specify one or more key fields, only those fields appear in the before section.
    </summary>
    <param name="cAliasList">

      Specifies a comma-separated list of open tables or cursors, listed either by name or work area numbers in any combination, to include in the XML UpdateGram. If you specify no value or an empty string ("") for cAliasList, X# uses all open tables and cursors in the current data session that contain buffered changes.

    </param>
    <param name="nFlags">

      Specifies whether to return a formatted file. The following table lists the additive flags for nFlags.
      nFlag
      0
      0000
      (Default) Use UTF-8 formatted XML.
      1
      0001
      Use unformatted, for example, continuous string XML.
      2
      0010
      Enclose empty elements with both open and closing elements, for example, &lt;cc04&gt;&lt;cc04/&gt;.
      0100
      Preserve white space in fields.
      1000
      Wrap Memo fields in CDATA sections.
      16
      10000
      Output encoding.
      32
      100000
      32768
      none
      Indicates that a code page should be used.
      When output encoding is UTF-8 (default), the XML Declaration does not contain an Encoding= attribute (no encoding attribute = UTF-8).
      When output encoding is set to default to the code page of the cursor or table, the encoding attribute will be written according to the following table.
      Encoding flags are set by combining bits 4 and 5 (0010000).
      +0
      (Default) Windows 1252
      +16
      Set output encoding attribute to the code page of the cursor.
      +32
      Set output encoding attribute to UTF-8 (no character translation).
      +48
      11
      Set output encoding attribute to UTF-8 and translate double-byte characters to UTF-8.

    </param>
    <param name="cSchemaLocation">

      Specifies the name and location of the mapping schema, if it exists.
      You must supply the mapping schema.
      For example, suppose you pass the a schema called codemySchema.xsd/code to cSchemaLocation, the UpdateGram created contains a mapping schema attirbute as it appears in the following XML:
       <code language="X#">
        &lt;ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram"&gt;
        &lt;updg:sync mapping-schema="mySchema.xsd" &gt;
        &lt;updg:before&gt;
      </code>
    </param>
    <returns>
      Character data type. <b>XMLUPDATEGRAM( )</b> returns a character string that contains the XML UpdateGram.
    </returns>
    <remarks>
      You can use <b>XMLUPDATEGRAM( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not supported because the <b>_VFP</b> system variable is not supported in the OLD EB Provider.
      To use the X# OLE DB Provider with <b>XMLUPDATEGRAM( )</b>, you must install MSXML 3.0 on the computer with the OLE DB Provider.
      SQL Server and Visual Studio support the DiffGram format for updating XML. However, SQL XML requires a mapping schema to support this format. Therefore, <b>XMLUPDATEGRAM( )</b> does not support this format.
      To avoid possible errors generated by <b>XMLUPDATEGRAM( )</b> on tables containing <b>Memo</b> or <b>General</b> fields, use the <b>CURSORSETPROP( )</b> function. The following example shows how to include memo data in an XML UpdateGram by setting the <b>KeyFieldList</b> property using <b>CURSORSETPROP( )</b>:
       <code language="X#">
        SET MULTILOCKS ON
        CREATE CURSOR Test (mField M, cField I AUTOINC)
        INSERT INTO Test (mField) VALUES ("123456789")
        INSERT INTO Test (mField) VALUES ("23456789")
        INSERT INTO Test (mField) VALUES ("3456789")
        INSERT INTO Test (mField) VALUES ("456789")
        CURSORSETPROP("Buffering",5)
        CURSORSETPROP("keyfieldlist",'cField')
        UPDATE Test SET mField = "XXXXXXX" WHERE cField &lt; 3
        STRTOFILE(XMLUPDATEGRAM(),'xmlupdate.txt')
        MODIFY FILE xmlupdate.txt
        RETURN
      </code>
      To write memo data in the XML UpdateGram to SQL Server, you must use an explicit schema on the SQL Server and reference the schema in the XML UpdateGram.
      Unlike the <b>CURSORTOXML( )</b> function, <b>XMLUPDATEGRAM( )</b> disregards <b>SET FIELDS</b> statements and reads from the underlying cursor directly. To change the table structure before calling<b> XMLUPDATEGRAM( )</b>, you must copy the data into a new cursor. For example, to change a <b>Numeric</b> field to a <b>Currency</b> field, the following example uses a SQL <b>SELECT</b> statement to create a new cursor and uses that cursor with <b>XMLUPDATEGRAM( )</b>. The example makes the Total_Price field a currency field, enables buffering with <b>CURSORSETPROP( )</b>, adds sales tax with the <b>REPLACE</b> command, and creates an XML UpdateGram using the <b>XMLUPDATEGRAM( )</b> function.
       <code language="X#">
        SELECT OrderID, CustID, NTOM(Total_Price) as Total_Price;
        FROM Orders INTO CURSOR New_Orders READWRITE
        CURSORSETPROP("Buffering", 5, "New_Orders")
        REPLACE Total_Price WITH (Total_Price * 1.083)
        cXMLUpdg = XMLUPDATEGRAM("New_Orders")
      </code>
      When using flag 32768, the flag's 16 and 32 settings can affect which code page is applied depending on the type of data you are writing to XML. The following tables show the possible combinations of settings and the code page each combination applies.
      For XML documents written with the 32768 flag set, the following code pages are applied.
      Flag 16
      Flag 32
      Flag 32768 is Set
      Not set
      Not set
      XML documents: Window-1252.
      Unicode data: code page 1252.
      Character data: default code page, unless a field is marked as <b>NOCPTRANS</b>.
      True (.T)
      Not set
      XML documents: Plus-<b>CodePage</b> property of the cursor. If XMLField <b>CodePage</b> property is greater than zero (0) and it doesn’t match the cursor’s code page, an error is reported.
      Unicode data: the <b>Code page</b> property of the cursor object.
      Character data: none. Raw data from the X# tables (.dbf) are used instead.
      Not set
      Set
      XML documents: UTF-8 code page.
      Unicode data: UTF-8 code page.
      Character data: Default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
      Set
      Set
      XML documents: UTF-8 code page.
      Unicode data: UTF-8 code page.
      Character data: default code page unless a field is marked as <b>NOCPTRANS</b>, in which case the data are translated to UTF-8 using the <b>SYS(3005)</b> setting.
      For XML documents written without setting the 32768 flag, the following code pages are applied.
      Flag 16
      Flag 32
      Without the 32768 flag
      Not set
      Not set
      XML documents: Window-1252.
      Unicode data: code page 1252.
      Character data: default code page unless a field is marked as <b>NOCPTRANS</b>.
      True (.T)
      Not set
      XML documents: <b>CodePage</b> property of the cursor.
      Character data: none. Raw data from the X# tables (.dbf) are used instead.
      Unicode data: code page property of the cursor object.
      Not set
      Set
      XML documents: UTF-8 code page.
      Unicode data: UTF-8 code page.
      Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
      Set
      Set
      XML documents: UTF-8 code page.
      Unicode data: UTF-8 code page.
      Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case, they are translated to UTF-8 using code page for the current <b>SYS(3005)</b> setting.
      For more information about converting XML to X# data, see Converting Between XML and X# Data.
    </remarks>
  </xmlupdategram>
</Runtimefunctions>
