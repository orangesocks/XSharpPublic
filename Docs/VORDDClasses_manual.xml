<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>VORDDClasses</name>
  </assembly>
  <members>
    <member name="T:VO.DbFileSpec">
      <summary>
        <para>Hold the file name and path for a .DBF file and provide DBF-related functions, such as creating, copying, deleting, moving, and renaming files.</para>
      </summary>
    </member>
    <member name="T:VO.DbServer">
      <summary>
        <para>Create a data server that can operate with existing .DBF database files and their associated index files.</para>
      </summary>
      <remarks>
        <para>
          <b>Note</b>
        </para>
        <para>There have been some major changes in the DbServer class in Visual Objects 2.8. Please read the section on the bottom of this topic carefully !</para>
      </remarks>
    </member>
    <member name="T:VO.OrderSpec">
      <summary>
        <para>OrderSpec class was designed to model index information at the order level — not file level — and complement the DBFileSpec class.</para>
      </summary>
      <remarks>
        <para>
          Instantiation requires a DBFileSpec object. Each order will require a separate OrderSpec object. For single-order index formats such as DBFNTX, this is
          equivalent to one OrderSpec object per physical file. For multi-order index formats such as DBFCDX, this would mean multiple OrderSpec objects for one physical
          file.
        </para>
        <para></para>
        <para>For more information on the conditional index order instance variables, refer to the OrdCondSet() function.</para>
      </remarks>
    </member>
    <member name="M:VO.DbFileSpec.#ctor(XSharp.__Usual[])">
      <summary>
        <para>Instantiates a DBFileSpec object and fills its instance variables with DBF information.</para>
      </summary>
      <returns>A DBFileSpec object.</returns>
    </member>
    <member name="M:VO.DbFileSpec.Copy(XSharp.__Usual[])">
      <summary>
        <para>Copies all files associated with DBFileSpec objects to a different drive and/or directory.</para>
      </summary>
      <returns>TRUE if the file was successfully copied; otherwise, FALSE.</returns>
    </member>
    <member name="M:VO.DbFileSpec.CopyTo(XSharp.__Usual[])">
      <summary>
        <para>Copies the DBFileSpec object's DBF file to another data format. This can be used for copying out to another RDD, to a delimited file, or to an SDF file.</para>
      </summary>
      <returns>
        <para>TRUE if the file was successfully copied; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbFileSpec.Create(XSharp.__Usual[])">
      <summary>
        <para>Create a new DBF file with the given name, using a provided DBStruct array.</para>
      </summary>
      <returns>
        <para>TRUE if the file was successfully created; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbFileSpec.DBFSGetInfo(XSharp.__Usual[])">
      <summary>
        <para>
          Fills in the DBFileSpec object's instance variables. This method is not required when using the Find() method, which will invoke this method internally if
          the file is found.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbFileSpec.Delete(XSharp.__Usual[])">
      <summary>
        <para>
          Physically deletes all files that are associated with the DBFileSpec object, including memo files and any index files associated with the DBF through
          OrderSpec objects.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbFileSpec.Find(XSharp.__Usual[])">
      <summary>
        <para>
          Locates the file defined in the DBFileSpec object using the current directory, SetDefault(), or SetPath(). Fills in the instance variables of the DBFileSpec
          if successful.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbFileSpec.Move(XSharp.__Usual[])">
      <summary>
        <para>
          Moves and/or renames all files associated with DBFileSpec objects to a different drive and/or directory. Updates DBFileSpec and/or OrderSpec instance
          variables. Will also rename auto-open index files. Only DBF, MEMO and auto-open index files will get renamed.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbFileSpec.Rename(XSharp.__Usual[])">
      <summary>
        <para>
          Renames files associated with DBFileSpec object. Only DBF/MEMO and auto-open index files will get renamed. Rename() will not rename a file if it is already
          open or there is a file name conflict. To rename files to another directory, use the Move() method and supply a different target file name.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="P:VO.DbFileSpec.DBFAttr">
      <summary>
        <para>The DBF file attributes returned as a string type.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.DBFDateChanged">
      <summary>
        <para>The DBF file date stamp returned as a date type.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.DBFName">
      <summary>
        <para>The DBF file name and extension.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.DBFSize">
      <summary>
        <para>The DBF file size.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.DBFTime">
      <summary>
        <para>The DBF file time stamp returned as a string.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.DbStruct">
      <summary>
        <para>An array containing the structure of the DBF file.</para>
      </summary>
      <remarks>
        <para>
          The structure of the current database file in an array whose length is equal to the number of fields in the database file. Each element of the array is a
          subarray containing information for one field. The subarrays have the following format:
        </para>
        <para></para>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Attribute</description>
          </listheader>
          <item>
            <term>DBS_NAME</term>
            <description>cName</description>
          </item>
          <item>
            <term>DBS_TYPE</term>
            <description>cType</description>
          </item>
          <item>
            <term>DBS_LEN</term>
            <description>nLength</description>
          </item>
          <item>
            <term>DBS_DEC</term>
            <description>nDecimals</description>
          </item>
          <item>
            <term>DBS_ALIAS</term>
            <description>cAlias</description>
          </item>
        </list>
        <para></para>
      </remarks>
    </member>
    <member name="P:VO.DbFileSpec.Delim">
      <summary>
        <para>Access the delimiter used for the CopyTo() method.</para>
        <para></para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.FCount">
      <summary>
        <para>The number of fields in the DBF file.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.Fields">
      <summary>
        <para>The 1-D array of DBF fields to copy out to when using the CopyTo() method.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.FileName">
      <summary>
        <para>Assign a file name to the DBFileSpec object.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.ForBlock">
      <summary>
        <para>The FOR condition code block used for the CopyTo() method.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.FullPath">
      <summary>
        <para>Assign a full path — including drive, directory, file name, and extension — to the DBFileSpec object.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.HeaderSize">
      <summary>
        <para>The size of the DBF file header.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.HidRDDs">
      <summary>
        <para>The 1-D array of "hidden" RDDs (i.e., DBFMEMO) used for the CopyTo() method.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.IndexNames">
      <summary>
        <para>The 1-D array of index files with drive, path, file name, and extension information.</para>
      </summary>
      <remarks>
        <para>
          <b>Note</b> It is not required to assign this array when using the OrderSpec:OrderCreate() and OrderSpec:OrderAdd() methods.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbFileSpec.IsAnsi">
      <summary>
        <para>The ANSI/OEM setting used in the DBF file header.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.LastUpDate">
      <summary>
        <para>The date of the last update made to the DBF file as reported in the DBF header.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemAttr">
      <summary>
        <para>The memo file attributes.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemBlockSize">
      <summary>
        <para>The memo block size used in the memo file.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemDateChanged">
      <summary>
        <para>The memo file date stamp returned as a date type.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemFileExt">
      <summary>
        <para>The memo file name extension excluding the file name.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemFileName">
      <summary>
        <para>The base memo file name excluding the file name extension.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemFullPath">
      <summary>
        <para>The full path of the memo file, including drive, directory, file name, and extension.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemName">
      <summary>
        <para>The memo file name and extension.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemSize">
      <summary>
        <para>The memo file size.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.MemTime">
      <summary>
        <para>The memo file time stamp returned as a string.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.Orders">
      <summary>
        <para>The 1-D array of OrderSpec objects that are associated with this DBFileSpec object.</para>
      </summary>
      <remarks>
        <para>
          <b>Note</b> It is not required to assign this array when using OrderSpec:OrderCreate() and OrderSpec:OrderAdd() methods.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbFileSpec.RDD_Name">
      <summary>
        <para>The name of the RDD used for instantiation.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.RDD_Version">
      <summary>
        <para>The version number of the RDD.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.RDDs">
      <summary>
        <para>An array of "hidden" RDDs (such as DBFMEMO) used for instantiation.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.RecCount">
      <summary>
        <para>The number of records in the DBF. </para>
      </summary>
      <remarks>
        <b>Note</b> that "LastRec" is not available in this class, only in the dbServer class.
      </remarks>
    </member>
    <member name="P:VO.DbFileSpec.Recno">
      <summary>
        <para>The record number for the CopyTo() method when a single record is required.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.Records">
      <summary>
        <para>The number of records for the CopyTo() method.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.RecSize">
      <summary>
        <para>The record size of the DBF.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.Rest">
      <summary>
        <para>A logical determining if the CopyTo() method is to copy all records or the current record to EOF.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.RLockCount">
      <summary>
        <para>The number of locked records in the DBF.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.SDF">
      <summary>
        <para>A logical determining if the CopyTo() method is to copy out to an SDF file.</para>
      </summary>
    </member>
    <member name="P:VO.DbFileSpec.WhileBlock">
      <summary>
        <para>A WHILE condition code block used with the CopyTo() method.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.#ctor(XSharp.__Usual[])">
      <summary>
        <para>Construct a DBServer object.</para>
        <para></para>
      </summary>
      <returns>
        <para>
          As with all constructors, the instantiation returns the object. An object is created even if the file was not successfully opened, perhaps because the
          file does not exist, is corrupted or is locked by another user. Thus, before using the DBServer error, verify that it was successfully opened with the
          DBServer:Used or Status access methods.
        </para>
        <para></para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Append(XSharp.__Usual[])">
      <summary>
        <para>
          Append a blank record to the table; this blank record becomes the current position and is ready for assignment of data values. The record is automatically
          locked if the Append() method returns TRUE.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.AppendDB(XSharp.__Usual[])">
      <summary>
        <para>Append new records to the table from another DBF file.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.AppendSDF(XSharp.__Usual[])">
      <summary>
        <para>Append new records to the table from an SDF-formatted file.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE (although this can still have caused records to be appended).</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Average(XSharp.__Usual[])">
      <summary>
        <para>Calculate the average of a series of numeric expressions, based on the number of actual records involved.</para>
      </summary>
      <returns>
        <para>An array that contains the averages for each field or expression specified. If a single expression was specified, an array length of 1 is returned.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.BLOBDirectGet(XSharp.__Usual[])">
      <summary>
        <para>Retrieve data stored in a BLOB file without referencing a specific field.</para>
      </summary>
      <returns>
        <para>
          The data retrieved from the BLOB file. The data type of the return value depends on the actual data stored. Use ValType() or UsualType() to determine the
          data type.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.BLOBDirectPut(XSharp.__Usual[])">
      <summary>
        <para>Put data in a BLOB file without referencing a specific field.</para>
      </summary>
      <returns>
        <para>
          A numeric pointer to the &lt;<i>uBLOB</i>&gt; data.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.BLOBExport(XSharp.__Usual[])">
      <summary>
        <para>Copy the contents of a BLOB, identified by its memo field number, to a file.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.BLOBGet(XSharp.__Usual[])">
      <summary>
        <para>Get the contents of a BLOB, identified by its memo field number.</para>
      </summary>
      <returns>
        <para>
          The BLOB data retrieved from the memo field. The data type of the return value depends on the actual data stored. Use ValType() or UsualType() to determine
          the data type. If the indicated field is not a memo field, DBServer:BLOBGet() returns NIL.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.BLOBImport(XSharp.__Usual[])">
      <summary>
        <para>Read the contents of a file as a BLOB, identified by a memo field number.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.BLOBRootGet(XSharp.__Usual[])">
      <summary>
        <para>Retrieve the data from the root area of a BLOB file.</para>
      </summary>
      <returns>
        <para>
          The data retrieved from the root of the BLOB file. The data type of the return value depends on the actual data stored. Use ValType() or UsualType() to
          determine the data type.
        </para>
      </returns>
      <remarks>
        <b>Note</b> that DBServer:BLOBRootGet() returns NIL if the root reference has never been written to with DBServer:BLOBRootPut().
      </remarks>
    </member>
    <member name="M:VO.DbServer.BLOBRootLock(XSharp.__Usual[])">
      <summary>
        <para>Obtain a lock on the root area of a BLOB file.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.BLOBRootPut(XSharp.__Usual[])">
      <summary>
        <para>Store data in the root area of a BLOB file.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.BLOBRootUnlock(XSharp.__Usual[])">
      <summary>
        <para>Release the lock on a BLOB file's root area.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.ClearFilter(XSharp.__Usual[])">
      <summary>
        <para>Clear a filter condition specified with the DBServer:SetFilter() method.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, it returns FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.ClearIndex(XSharp.__Usual[])">
      <summary>
        <para>Clear all indexes currently associated with the server.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, it returns FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.ClearLocate(XSharp.__Usual[])">
      <summary>
        <para>Clear the LOCATE condition of the server, if any.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, it returns FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.ClearRelation(XSharp.__Usual[])">
      <summary>
        <para>Clear all active relations held by this server to other servers.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, it returns FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.ClearScope(XSharp.__Usual[])">
      <summary>
        <para>Clear the settings that define the default scope for multi-record operations.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Close(XSharp.__Usual[])">
      <summary>
        <para>Close the database file and its associated index files.</para>
      </summary>
      <returns>
        <para>TRUE if the operation was successful; FALSE if not.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Commit(XSharp.__Usual[])">
      <summary>
        <para>Commit all changes to disk from the buffer, ensuring that all buffers are flushed.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Continue(XSharp.__Usual[])">
      <summary>
        <para>Resume a pending DBServer:Locate() operation, searching for the next record that matches (like the DBContinue() function).</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE. After the operation, the DBServer:Found access can be used to determine if a record was found.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.CopyDB(XSharp.__Usual[])">
      <summary>
        <para>Copy records to another DBF file.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.CopyDelimited(XSharp.__Usual[])">
      <summary>
        <para>Copy records to a delimited file.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE. </para>
      </returns>
      <remarks>
        <b>Note</b> that after a FALSE indication, records can still have been copied to the target: the operation can have failed
        halfway through because the disk had been filled or other problems.
      </remarks>
    </member>
    <member name="M:VO.DbServer.CopySDF(XSharp.__Usual[])">
      <summary>
        <para>Copy records to an SDF file.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE. </para>
      </returns>
      <remarks>
        <b>Note</b> that after a FALSE indication, records can still have been copied to the target: the operation can have failed
        halfway through because the disk had been filled or other problems.
      </remarks>
    </member>
    <member name="M:VO.DbServer.CopyStructure(XSharp.__Usual[])">
      <summary>
        <para>Create a DBF file with the same record layout as the server object to which the message is sent.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Count(XSharp.__Usual[])">
      <summary>
        <para>Return the number of records that match a specified scope.</para>
      </summary>
      <returns>
        <para>The number of records that match the scope.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.CreateIndex(XSharp.__Usual[])">
      <summary>
        <para>Create an index file with an order in it.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.CreateOrder(XSharp.__Usual[])">
      <summary>
        <para>Create an order within an existing index file. The behavior depends on which driver is used.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.DataField(XSharp.__Usual[])">
      <summary>
        <para>Retrieve the data field object at the specified field position.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.Delete(XSharp.__Usual[])">
      <summary>
        <para>Delete the current record or the records specified with the scoping parameters.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE. </para>
      </returns>
      <remarks>
        <b>Note</b> that after a FALSE indication of a scoped operation, some records can have been deleted: the operation can have
        failed halfway through because of lock conflicts or technical problems.
      </remarks>
    </member>
    <member name="M:VO.DbServer.DeleteAll(XSharp.__Usual[])">
      <summary>
        <para>Delete all records of the table.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
      <remarks>
        <b>Note</b> that, even with FALSE, some records may have been deleted. This could happen if the operation failed halfway
        through because of lock conflicts or technical problems.
      </remarks>
    </member>
    <member name="M:VO.DbServer.DeleteOrder(XSharp.__Usual[])">
      <summary>
        <para>Delete an order from an index file.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Error(XSharp.__Usual[])">
      <summary>
        <para>Provide a method for handling error conditions raised during database processing.</para>
      </summary>
      <remarks>
        <para>
          <b>Note</b> This is an event handler and is automatically called by other methods; the developer does not normally need to call the DBServer:Error()
          method, but might want to replace or amend it.
        </para>
      </remarks>
    </member>
    <member name="M:VO.DbServer.Eval(XSharp.__Usual[])">
      <summary>
        <para>
          Evaluate a code block for each record matching a scope and condition. If neither conditions nor scope is passed to the method, it is subject to the general
          server scope.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE (but note that even in the case of a failure, some records may have been processed).</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.FIELDGET(XSharp.__Usual[])">
      <summary>
        <para>Get the contents of a field that is identified by its position.</para>
      </summary>
      <returns>
        <para>
          The value of the specified field. If &lt;<i>nFieldPos</i>&gt; does not correspond to the position of any field in the current data server,
          DBServer:FieldGet() returns NIL.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.FieldInfo(XSharp.__Usual[])">
      <summary>
        <para>Return and optionally change information about a field.</para>
      </summary>
      <returns>
        <para>
          If &lt;<i>uNewSetting</i>&gt; is not specified, DBServer:FieldInfo() returns the current setting. If &lt;<i>uNewSetting</i>&gt; is specified, the previous
          setting is returned.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.FieldName(XSharp.__Usual[])">
      <summary>
        <para>Return the name of a specified field as a string.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.FieldPos(XSharp.__Usual[])">
      <summary>
        <para>Return the position of a specified field within the data server, as a number starting with 1.</para>
      </summary>
      <returns>
        <para>The field position in the dbServer structure, or zero if not found.</para>
        <para>See Also</para>&lt;span style="color: #000000;"&gt; &lt;/span&gt;
      </returns>
    </member>
    <member name="M:VO.DbServer.FIELDPUT(XSharp.__Usual[])">
      <summary>
        <para>Set the value of a field identified by its position.</para>
      </summary>
      <returns>
        <para>
          The value assigned to the field. If &lt;<i>nFieldPos</i>&gt; does not correspond to the position of any field in the data server, DBServer:FieldPut()
          returns NIL.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.FieldSpec(XSharp.__Usual[])">
      <summary>
        <para>Return the FieldSpec object in the specified field.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.FieldStatus(XSharp.__Usual[])">
      <summary>
        <para>Return the status of a field after the last operation.</para>
      </summary>
      <returns>
        <para>
          A HyperLabel object if any error condition had occurred or if a validation has failed, NIL if everything is OK, if the validation passed, or if there has
          been no validation attempt.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.FieldSym(XSharp.__Usual[])">
      <summary>
        <para>Return the name of a specified field.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.FieldValidate(XSharp.__Usual[])">
      <summary>
        <para>
          Perform all the validations defined to the FieldSpec object of a field (for example, required, maximum and minimum digits, maximum and minimum value,
          validation rule) and return the result of the test.
        </para>
      </summary>
      <returns>
        <para>FALSE if any of the validations fail; otherwise, TRUE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.FLOCK(XSharp.__Usual[])">
      <summary>
        <para>Lock the table used by this server for exclusive access.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.GetArray(XSharp.__Usual[])">
      <summary>
        <para>Retrieve an array of values from a field in the server, subject to the currently active selection, if any.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.GetLocate(XSharp.__Usual[])">
      <summary>
        <para>Retrieve the code block of the current LOCATE condition, or NIL if no code block is set.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.GetLookupTable(XSharp.__Usual[])">
      <summary>
        <para>Retrieve a two-column array of values from two fields in the server, subject to the currently active selection, if any.</para>
      </summary>
      <returns>
        <para>The method returns a two-column array of values found for the specified fields</para>
      </returns>
      <remarks>
        <para>
          The data is collected moving sequentially until the specified maximum number of rows or until end
          of file. If a selection is active, the method includes only records from that selection. The values are retrieved under the current controlling order, if
          any.
        </para>
        <para>
          <b>Note</b> that the method does not reposition to the beginning before starting to fill the array. Either provide a start value, or explicitly position the server
          before using the method. (This allows incremental reading, building up an array in pieces.)
        </para>
      </remarks>
    </member>
    <member name="M:VO.DbServer.GoBottom(XSharp.__Usual[])">
      <summary>
        <para>Position the data server at the last record.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.GoTo(XSharp.__Usual[])">
      <summary>
        <para>Position the data server at a specified record number.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.GoTop(XSharp.__Usual[])">
      <summary>
        <para>Position the data server at the first record.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.INDEXKEY(XSharp.__Usual[])">
      <summary>
        <para>Return the key expression of a specified single-order index.</para>
      </summary>
      <returns>
        <para>
          The key expression of the specified index as a string; if there is no corresponding order or the order name is not unique, the method returns a
          NULL_STRING.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.INDEXORD(XSharp.__Usual[])">
      <summary>
        <para>Return the ordinal position of the controlling order in the order list. (Similar to the IndexOrd() function.)</para>
      </summary>
      <returns>
        <para>
          An integer numeric value. The value returned is equal to the position of the controlling index in the list of open indexes for the current work area. A
          value of 0 indicates that there is no controlling index and records are being accessed in natural order.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Info(XSharp.__Usual[])">
      <summary>
        <para>Return and optionally change information about a data server.</para>
      </summary>
      <returns>
        <para>
          If &lt;<i>uNewSetting</i>&gt; is not specified, DBServer:RDDInfo() returns the current setting. If &lt;<i>uNewSetting</i>&gt; is specified, the previous
          setting is returned.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Join(XSharp.__Usual[])">
      <summary>
        <para>Join this DBServer object with another DBServer object and place the results in the file specified.</para>
      </summary>
      <returns>
        <para>
          TRUE if successful; otherwise, FALSE, although even with FALSE, some records may have been processed. This would happen if the operation failed halfway
          through because of lock conflicts or technical problems.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Locate(XSharp.__Usual[])">
      <summary>
        <para>
          Search sequentially for a record matching a condition. If neither conditions nor scope is passed to the method, it is subject to the general server
          scope.
        </para>
      </summary>
      <returns>
        <para>
          TRUE if a record was found that matches the conditions, FALSE if no match was found or if the operation failed for some other reason. Afterwards, the Found
          and Status access methods can be used to determine exactly what happened.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.LockSelection(XSharp.__Usual[])">
      <summary>
        <para>Lock all the records in the currently active selection.</para>
      </summary>
      <returns>
        <para>
          TRUE if successful; otherwise, FALSE. If it fails, some records may remain locked; this allows the program to try again, incrementally locking more and more
          records as other applications free them. If the application gives up on the attempt, the locks should be explicitly released.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.NoIVarGet(XSharp.__Usual[])">
      <summary>
        <para>
          Provide a general error interception that is automatically called (in any class) whenever an access reference is made to a non-existent exported instance
          variable. In the DBServer class, it is used to implement the virtual field variable.
        </para>
      </summary>
      <remarks>
        <para>
          <b>
            <i>Important!</i>
          </b>
          <i>NoIVarGet() should not be called directly; it is called by the system for handling invalid references.</i>
        </para>
      </remarks>
    </member>
    <member name="M:VO.DbServer.NoIVarPut(XSharp.__Usual[])">
      <summary>
        <para>
          Provide a general error interception that is automatically called (in any class) whenever an assignment reference is made to a non-existent exported
          instance variable. In the DBServer class, it is used to implement the virtual field variable.
        </para>
      </summary>
      <remarks>
        <para>
          <b>
            <i>Important!</i>
          </b>
          <i>NoIVarPut() should not be called directly; it is called by the system for handling invalid references.</i>
        </para>
      </remarks>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Notify(XSharp.__Usual[])">
      <summary>
        <para>
          An event handler that responds to events that have occurred in methods of this server, or in other servers that are linked to this server in some way. The
          standard implementation notifies all the server's clients of the event.
        </para>
        <para>
          <b>
            <i>Important!</i>
          </b>
          <i>
            This method is automatically called by the various action methods of the data server, and should normally not be called by
            application code.
          </i>
        </para>
      </summary>
      <returns>
        <para>
          SELF, except if NOTIFYINTENTTOMOVE is specified for &lt;<i>kNotifyName</i>&gt;. In this case, the return value is TRUE if successful; otherwise, FALSE.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.OrderDescend(XSharp.__Usual[])">
      <summary>
        <para>Return and optionally change the descending flag of an order.</para>
      </summary>
      <returns>
        <para>
          If &lt;<i>lNewDescend</i>&gt; is not specified, DBServer:OrderDescend() returns the current setting. If &lt;<i>lNewDescend</i>&gt; is specified, the
          previous setting is returned.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.OrderInfo(XSharp.__Usual[])">
      <summary>
        <para>Return and optionally change information about orders and index files.</para>
      </summary>
      <returns>
        <para>
          If &lt;<i>uNewSetting</i>&gt; is not specified, DBServer:OrderInfo() returns the current setting. If &lt;<i>uNewSetting</i>&gt; is specified, the previous
          setting is returned.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.OrderIsUnique(XSharp.__Usual[])">
      <summary>
        <para>Return the status of the unique flag for a given order.</para>
      </summary>
      <returns>
        <para>The status of the indicated order's unique flag as a logical value.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.OrderKeyAdd(XSharp.__Usual[])">
      <summary>
        <para>Add a key to a custom built order.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.OrderKeyCount(XSharp.__Usual[])">
      <summary>
        <para>Return the number of keys in an order.</para>
      </summary>
    </member>
    <member name="M:VO.DbServer.OrderKeyDel(XSharp.__Usual[])">
      <summary>
        <para>Delete a key from a custom built order.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.OrderKeyGoTo(XSharp.__Usual[])">
      <summary>
        <para>Move to a record specified by its logical record number in the controlling order.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.OrderKeyNo(XSharp.__Usual[])">
      <summary>
        <para>Get the logical record number of the current record.</para>
      </summary>
      <returns>
        <para>
          The relative position of the current record in the specified order, as a numeric value. DBServer:OrderKeyNo() respects the scope and for condition of the
          order by returning zero if the record pointer is positioned on an invalid record or if DBServer:EOF is TRUE.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.OrderScope(XSharp.__Usual[])">
      <summary>
        <para>Set the boundaries for scoping key values in the controlling order.</para>
      </summary>
      <returns>
        <para>
          If &lt;<i>uNewValue</i>&gt; is not specified, DBServer:OrderScope() returns the current setting. If &lt;<i>uNewValue</i>&gt; is specified, the previous
          setting is returned.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Pack(XSharp.__Usual[])">
      <summary>
        <para>Remove deleted records from a database file.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.RDDINFO(XSharp.__Usual[])">
      <summary>
        <para>Return and optionally change settings controlled directly by the RDD.</para>
      </summary>
      <returns>
        <para>
          If &lt;<i>uNewSetting</i>&gt; is not specified, DBServer:RDDInfo() returns the current setting. If &lt;<i>uNewSetting</i>&gt; is specified, the previous
          setting is returned.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Recall(XSharp.__Usual[])">
      <summary>
        <para>Recall those deleted records indicated by a specified scope.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE. </para>
      </returns>
      <remarks>
        <b>Note</b> that after a FALSE indication of a scoped operation, some records can have been recalled: the operation can have
        failed halfway through because of lock conflicts or technical problems.
      </remarks>
    </member>
    <member name="M:VO.DbServer.RecallAll(XSharp.__Usual[])">
      <summary>
        <para>Recall all deleted records in the table.</para>
      </summary>
      <returns>
        <para>
          TRUE if successful; otherwise, FALSE, although even with FALSE, some records may be recalled. This would happen if the operation failed halfway through
          because of lock conflicts or technical problems.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.RecordInfo(XSharp.__Usual[])">
      <summary>
        <para>Retrieve information about the indicated record.</para>
      </summary>
      <returns>
        <para>The data type of the return value depends on the value requested.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Refresh(XSharp.__Usual[])">
      <summary>
        <para>Reread the current record from the database, discarding any changes that have been made.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Reindex(XSharp.__Usual[])">
      <summary>
        <para>Recreate all active indexes for this server.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Relation(XSharp.__Usual[])">
      <summary>
        <para>Return the linking expression of a specified relation.</para>
      </summary>
      <returns>
        <para>
          A string containing the linking expression of the relation specified by &lt;<i>nRelation</i>&gt;. If there is no relation set for &lt;<i>nRelation</i>&gt;,
          DBServer:Relation() returns a NULL_STRING.
        </para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Replace(XSharp.__Usual[])">
      <summary>
        <para>Replace one or several fields with a new expression, for all records that match a specified scope.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE (although this can still have caused records to be modified).</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.RLOCK(XSharp.__Usual[])">
      <summary>
        <para>Lock a record for exclusive write access; other users can still make read-only reference to the record.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE (including if the indicated record was successfully locked but other record locks cannot be maintained).</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.RLockVerify(XSharp.__Usual[])">
      <summary>
        <para>Determine if the current record in this data server has any pending updates and lock it for exclusive write access if there are none.</para>
      </summary>
      <returns>
        <para>TRUE if the record is unchanged and the lock was successfully taken; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Seek(XSharp.__Usual[])">
      <summary>
        <para>Move to the record having the specified key value in the controlling order.</para>
      </summary>
      <returns>
        <para>TRUE if the specified key value was found; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.SetDataField(XSharp.__Usual[])">
      <summary>
        <para>Assign a DataField object to a specified field.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.SetFilter(XSharp.__Usual[])">
      <summary>
        <para>Set a filter condition.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.SetIndex(XSharp.__Usual[])">
      <summary>
        <para>Open an index file and select its order as the controlling order, if this is the first index being opened.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.SetOrder(XSharp.__Usual[])">
      <summary>
        <para>Select an order from one of the open index files as the controlling order.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.SetRelation(XSharp.__Usual[])">
      <summary>
        <para>Set a relation from this server to the child server.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Skip(XSharp.__Usual[])">
      <summary>
        <para>Move the record pointer forward or backward a specified number of records.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Sort(XSharp.__Usual[])">
      <summary>
        <para>
          Copy records to another database file in sorted order. If neither conditions nor scope is passed to the method, it is subject to the general server
          scope.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE. </para>
      </returns>
      <remarks>
        <b>Note</b> that after a FALSE indication, some records can have been copied: the operation can have failed halfway through
        because of lock conflicts or technical problems.
      </remarks>
    </member>
    <member name="M:VO.DbServer.Sum(XSharp.__Usual[])">
      <summary>
        <para>Calculate the sum of a series of numeric expressions.</para>
      </summary>
      <returns>
        <para>An array that contains the sums for each expression or field specified.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Total(XSharp.__Usual[])">
      <summary>
        <para>Aggregate records by key value, producing grouped summarizations, and write the aggregate records to another database.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE. </para>
      </returns>
      <remarks>
        <b>Note</b> that after a FALSE indication of a scoped operation, some records can have been written to the target file: the
        operation can have failed halfway through because of lock conflicts or technical problems.
      </remarks>
    </member>
    <member name="M:VO.DbServer.UnLock(XSharp.__Usual[])">
      <summary>
        <para>Release a specified lock or all locks.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Update(XSharp.__Usual[])">
      <summary>
        <para>Update this server with data from another server or table.</para>
      </summary>
      <remarks>
        <para>
          <b>Note</b> This method requires a file lock or exclusive access.
        </para>
        <b>Note 2:</b> If the method returns  FALSE, some records may have been updated. This can happen if the operation failed halfway through
        because of technical problems.
      </remarks>
      <returns>
        <para>TRUE if successful; otherwise, FALSE</para>
      </returns>
    </member>
    <member name="M:VO.DbServer.Zap(XSharp.__Usual[])">
      <summary>
        <para>Permanently remove all records from the server and release the disk space.</para>
      </summary>
      <remarks>
        <para>
          <b>Note</b> This method requires exclusive access.
        </para>
      </remarks>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="P:VO.DbServer.Alias">
      <summary>
        <para>A string representing the alias of the work area.</para>
      </summary>
      <remarks>
        <para>
          <b>Note</b> "Hybrid" operation, with procedural commands referencing a DBServer object, is strongly discouraged. See the discussion of hybrid operation
          under CLASS DBServer.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.AliasSym">
      <summary>
        <para>A symbol representing the alias of a DBServer object.</para>
      </summary>
      <remarks>
        <para>
          <b>Note</b> "Hybrid" operation, with procedural commands referencing a DBServer object, is strongly discouraged. See the discussion of hybrid operation
          under CLASS DBServer.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.BoF">
      <summary>
        <para>A logical value indicating whether the server is positioned at the beginning of the file, on the first record.</para>
      </summary>
      <remarks>
        <para>
          It returns TRUE after an attempt to move backward beyond the first logical record in a database file; otherwise, it returns FALSE. If the current database
          file contains no records, BOF also returns TRUE.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.ConcurrencyControl">
      <summary>
        A constant, identifying the mode of automatic concurrency control for this data server
      </summary>
      <remarks>
        <para>
          One of the following constants, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and
          released:
        </para>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>CCNONE</term>
            <description>
              The data server provides no automatic record locking; the application is required to do all locking explicitly.
            </description>
          </item>
          <item>
            <term>CCOPTIMISTIC</term>
            <description>
              No locks are maintained continuously except when appending —
              the record just appended is locked, and the lock is only
              released when moving off the record or explicitly calling the DataServer or
              DBServer Unlock() method. For all other records, the record is reread from disk
              before any update is done. This is the default.
            </description>
          </item>
          <item>
            <term>CCSTABLE</term>
            <description>
              The record that the window is sitting on is always kept locked.
              Note that when in browse view, the row that the cursor is on
              represents the current record.
            </description>
          </item>
          <item>
            <term>CCREPEATABLE</term>
            <description>
              All records that have been read are maintained locked.
              The user is guaranteed that when moving back among previously viewed
              data, they are unchanged.
            </description>
          </item>
          <item>
            <term>CCFILE</term>
            <description>
              All the records in the entire set provided by the server are locked throughout.
              This is not very practical for windows associated with
              all the records of a server, since it would correspond to a file lock.
              It is intended to be used in conjunction with method DBServer:SetSelectiveRelation().
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.DbServer.DBStruct">
      <summary>
        <para>An array containing the structure of this data server, whose length (that is, number of elements) is equal to the number of fields in the server.</para>
      </summary>
      <remarks>
        <para>
          Each sub-array is comprised of five elements, which contain the following information, <i>in this order</i>:
        </para>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Attribute</description>
          </listheader>
          <item>
            <term>DBS_NAME</term>
            <description>cName</description>
          </item>
          <item>
            <term>DBS_TYPE</term>
            <description>cType</description>
          </item>
          <item>
            <term>DBS_LEN</term>
            <description>nLength</description>
          </item>
          <item>
            <term>DBS_DEC</term>
            <description>nDecimals</description>
          </item>
          <item>
            <term>DBS_ALIAS</term>
            <description>cAlias</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.DbServer.Deleted">
      <summary>
        <para>A logical value indicating whether the current record is marked as deleted.</para>
      </summary>
      <remarks>
        <b>Note</b> that a pointer change, such as GoTop(), must be invoked in order for the filter condition to become active.
      </remarks>
    </member>
    <member name="P:VO.DbServer.Driver">
      <summary>
        <para>A string representing the name of the database driver in use with this server.</para>
      </summary>
      <remarks>
        <para>
          The server can be specified as an instantiation parameter to the server. If no driver is set, the default driver is used; it can be set by RDDSetDefault()
          or DBSetDriver().
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.EoF">
      <summary>
        <para>A logical value indicating whether the server is positioned at the end of the file, on the last record.</para>
      </summary>
      <remarks>
        <para>
          It returns TRUE after an attempt is made to move the record pointer beyond the last logical record in a database file; otherwise, FALSE. If the current
          database file contains no records, EOF returns TRUE.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.ErrInfo">
      <summary>
        <para>An Error object identifying the error condition after the last operation. If the last operation was successful, DBServer:ErrInfo returns NULL_OBJECT.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.FCount">
      <summary>
        <para>The number of fields in the server.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.FileSpec">
      <summary>
        <para>The FileSpec object that defines the path and file name of the DBF file. </para>
      </summary>
      <remarks>
        <para>
          If the DBServer was originally instantiated with a FileSpec object, this is that
          original FileSpec object; if the server was originally instantiated with a file name in string format, a FileSpec object is created.
        </para>
        <para>
          <b>Note</b> that the path of the file specification is exactly as originally entered. To store the full path of the file in the file specification, use the
          FileSpec:Find() method.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.Filter">
      <summary>
        <para>A string representing the current active filter. </para>
      </summary>
      <remarks>
        If no filter has been set, NULL_STRING is returned. Assigning a string or a code block to DBServer:Filter
        is equivalent to calling DBSetFilter().
      </remarks>
    </member>
    <member name="P:VO.DbServer.ForBlock">
      <summary>
        <para>The "FOR block" component of the "general server scope,".</para>
      </summary>
      <remarks>
        <para>
          The FOR block  affects several bulk processing methods if they are called with no explicit scope. The FOR
          block can be specified as a code block or a string. This access always returns a code block.
        </para>
        <para>
          Specifying a FOR block makes the method process all those records where the FOR block evaluates TRUE, subject to other scope settings, of course. Specifying
          a FOR block makes the Scope default to ALL in those cases where it is otherwise "current record," unless a WhileBlock is also specified in which case it is set
          to REST.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.Found">
      <summary>
        <para>A logical value indicating whether the previous search operation succeeded. </para>
      </summary>
      <remarks>
        <b>Note</b> that this is old technology and is mainly here for backwards compatibility.
        Typically if you are doing a SEEK/FOUND scenario, you would simply do a "IF oDB:Seek(…)" to check if the seek was successful (FOUND) or not.
      </remarks>
    </member>
    <member name="P:VO.DbServer.Header">
      <summary>
        <para>A numeric value representing the length of the database file header.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.IndexExt">
      <summary>
        <para>A string representing the default index extension based on the database driver currently linked (for example, ".NTX" for the DBFNTX driver).</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.LastRec">
      <summary>
        <para>The number of records in the current database file. </para>
      </summary>
      <remarks>
        Filtering commands such as SET FILTER or SET DELETED have no effect on the return value.
      </remarks>
    </member>
    <member name="P:VO.DbServer.Lupdate">
      <summary>
        <para>The last modification date of the DBF file used in the server.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.OrderBottomScope">
      <summary>
        <para>A key value representing the record of the bottom boundary in the range of key values that will be included in the controlling order's current scope.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.OrderKeyVal">
      <summary>
        <para>The key value of the current record from the controlling order. </para>
      </summary>
      <remarks>
        The data type is the same as the that of the key expression used to create the order. Use ValType() or UsualType() to determine the data type.
      </remarks>
    </member>
    <member name="P:VO.DbServer.OrderTopScope">
      <summary>
        <para>A key value representing the record of the top boundary in the range of key values that will be included in the controlling order's current scope.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.RddName">
      <summary>
        <para>A string representing the name of the database driver in use with this server.</para>
      </summary>
      <remarks>
        <para>
          The server can be specified as an instantiation parameter to the server. If no driver is set, the default driver is used; it can be set by RDDSetDefault()
          or DBSetDriver().
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.ReadOnly">
      <summary>
        <para>A logical value indicating whether the file was opened as a read-only file. This is determined by an instantiation parameter of the server.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.RecCount">
      <summary>
        <para>The number of records in the current database file. </para>
      </summary>
      <remarks>
        Filtering commands such as SET FILTER or SET DELETED have no effect on the return value. This access is identical to the :LastRec Access.
      </remarks>
    </member>
    <member name="P:VO.DbServer.RecNo">
      <summary>
        <para>A numeric value representing the current record number, identifying the position of the record pointer.</para>
      </summary>
      <remarks>
        <para>Assigning a value to RecNo is equivalent to executing GoTo(); both reposition the record pointer on the given record.</para>
        <para>These two statements are equivalent:</para>
        <example>
          <para>oDBServer:RecNo := 1168</para>
          <para>oDBServer:GoTo(1168)</para>
        </example>
        <para>
          If the server contains a database file with 0 records, RecNo returns 1, BOF and EOF both return TRUE, and RecCount/LastRec return 0. If the record pointer
          is moved past the last record, RecNo returns LastRec + 1 and EOF returns TRUE. If an attempt is made to move before the first record, RecNo returns the record
          number of the first logical record in the database file and BOF returns TRUE.
        </para>
        <para>The DBServer:RecNo assign sends a NotifyIntentToMove message before the operation.</para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.RecSize">
      <summary>
        <para>A numeric value representing the record length of the server in bytes.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.RLockList">
      <summary>
        <para>An array of record numbers that are currently locked.</para>
      </summary>
    </member>
    <member name="P:VO.DbServer.Scope">
      <summary>
        <para>
          The "scope" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope. The initial
          value of the scope is NIL.
        </para>
      </summary>
      <remarks>
        <para>
          The following constants represent the range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing
          commands:
        </para>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>DBSCOPEALL</term>
            <description>
              The scope is all the records in the table. This is the default, although if a WHILE condition is specified, the scope becomes
              DBSCOPEREST.
            </description>
          </item>
          <item>
            <term>DBSCOPEREST</term>
            <description>The scope is the remaining records in the table from the current position.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.DbServer.Shared">
      <summary>
        <para>A logical value indicating whether the server is sharable or exclusive. </para>
      </summary>
      <remarks>
        DBServer:Shared is determined by an instantiation parameter of the server; if not specified, the default set by SetExclusive() is used.
      </remarks>
    </member>
    <member name="P:VO.DbServer.Status">
      <summary>
        <para>A HyperLabel object identifying the status after the last operation.</para>
      </summary>
      <remarks>
        <para>
          If the last operation was successful, DBServer:Status returns NULL_OBJECT; if something
          went wrong (whether it raised an error condition or merely returned a failure code), DBServer:Status returns an informative HyperLabel object.
        </para>
        <para>
          By accessing the properties of this hyperlabel, you can retrieve not only a description of the condition that was raised, but also context-sensitive help on
          the condition that was raised.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.Used">
      <summary>
        <para>A logical value indicating whether the server is currently open. </para>
      </summary>
      <remarks>
        <para>
          DBServer:Used returns TRUE if the server was successfully opened, and FALSE if the server
          has been closed or if a serious error has occurred that renders the table unusable. In that case, more information can be retrieved through DBServer:Status or
          by intercepting the error condition.
        </para>
        <para>If DBServer:Used is FALSE, the properties and methods return NIL, FALSE, or some similar null value.</para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.WhileBlock">
      <summary>
        <para>The "WHILE block" component of the "general server scope,"</para>
      </summary>
      <remarks>
        <para>
          The WHILE block  affects several bulk processing methods if they are called with no explicit scope. The
          access always returns a code block.
        </para>
        <para>
          Specifying a WHILE block makes the method process all remaining records until the WHILE block evaluates FALSE, subject to other scope settings, of course.
          Specifying a WHILE block makes the scope default to REST.
        </para>
      </remarks>
    </member>
    <member name="P:VO.DbServer.WorkArea">
      <summary>
        <para>A number representing the workarea of the server</para>
      </summary>
    </member>
    <member name="M:VO.OrderSpec.#ctor(XSharp.__Usual[])">
      <summary>
        <para>Instantiates an OrderSpec object using an existing DBFileSpec object.</para>
      </summary>
      <returns>
        <para>An OrderSpec object.</para>
      </returns>
    </member>
    <member name="M:VO.OrderSpec.OrderAdd(XSharp.__Usual[])">
      <summary>
        <para>
          Adds order information from an existing index file to the OrderSpec object and associates this OrderSpec object with the DBFileSpec object used for
          instantiation.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.OrderSpec.OrderCreate(XSharp.__Usual[])">
      <summary>
        <para>Create new orders, and if empty, fills in OrderSpec information and associates the created order with the DBFileSpec object.</para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="M:VO.OrderSpec.OrderDelete(XSharp.__Usual[])">
      <summary>
        <para>
          Deletes orders from a multi-order file or a physical index file of a single-order file. NULLs out OrderSpec object information in the OrderSpec object and
          the DBFileSpec object specific to this order.
        </para>
      </summary>
      <returns>
        <para>TRUE if successful; otherwise, FALSE.</para>
      </returns>
    </member>
    <member name="P:VO.OrderSpec.Add">
      <summary>
        <para>
          A logical value specifying whether open orders should remain open while the new order is being created. TRUE specifies that they should remain open. FALSE
          specifies that all open orders should be closed. The default is FALSE.
        </para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.All">
      <summary>
        <para>
          Used for a conditional index. A logical value determining whether the record scope is for all records in the DBF (TRUE). Defaults to FALSE so that
          OrderSpec:Records and OrderSpec:Interval can be used.
        </para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.AutoOpen">
      <summary>
        <para>Determines if this index file will open when the DBF file is opened.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.AutoOrder">
      <summary>
        <para>Determines if this index file will set the first order when it is opened.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.AutoShare">
      <summary>
        <para>Determines if this index file will be opened in the same share mode as the DBF file.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.Current">
      <summary>
        <para>
          A logical value determining whether only those records in the controlling order and in the scope are included in this order. Defaults to FALSE so that all
          records in DBF are included.
        </para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.Custom">
      <summary>
        <para>A logical value determining if this is to be a custom order. Valid for RDDs that support custom orders. Defaults to FALSE for a non-custom order.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.DBF">
      <summary>
        <para>The DBFileSpec object with which this OrderSpec object is associated.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.Descend">
      <summary>
        <para>A logical value determining if this is to be a descending order. Defaults to FALSE for ascending order.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.EvalBlock">
      <summary>
        <para>The code block to be evaluated based upon OrderSpec:Interval. The code block should return a TRUE value.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.FileName">
      <summary>
        <para>
          The drive, path and file name of the order. The drive and path default to either the current window's drive and path or to the drive and path used in
          SetDefault(), if omitted.
        </para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.ForBlock">
      <summary>
        <para>The FOR condition code block to build this order.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.ForCond">
      <summary>
        <para>The FOR condition string used to build this order.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.HPLock">
      <summary>
        <para>A logical value determining whether the DBFNTX RDD will use the HPLocking scheme for building this order. The default is FALSE, i.e., no HPLocking.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.Interval">
      <summary>
        <para>An integer determining the interval for the execution of OrderSpec:EvalBlock during order building.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.IsCond">
      <summary>
        <para>
          A logical value indicating whether this is a conditional order. This is assigned TRUE internally when any of the conditional ASSIGNs are assigned values and
          is not required to be assigned manually to create a conditional order.
        </para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.KeyInfo">
      <summary>
        <para>The 1-D, 4-element array containing the structure of the OrderSpec object.</para>
      </summary>
      <remarks>
        <para>Each subarray is comprised of four elements, which contain the following order key information:</para>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>ORD_KEYTYPE</term>
            <description>Data type of index key.</description>
          </item>
          <item>
            <term>ORD_KEYCOUNT</term>
            <description>Number of keys included in this order.</description>
          </item>
          <item>
            <term>ORD_KEYSIZE</term>
            <description>Length of this order key.</description>
          </item>
          <item>
            <term>ORD_KEYDEC</term>
            <description>Number of decimals in this order</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.OrderSpec.LockOffSet">
      <summary>
        <para>The current NTX locking offset as a numeric value.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.NoOptimize">
      <summary>
        <para>A logical value determining whether the FOR condition used to build this order should be optimized. </para>
      </summary>
      <remarks>
        Valid for RDDs that support query optimizations. Defaults to FALSE for no optimization.
      </remarks>
    </member>
    <member name="P:VO.OrderSpec.OrderBlock">
      <summary>
        <para>The code block of the index key expression used to create this order.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.OrderExpr">
      <summary>
        <para>The string of the index key expression used to create this order.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.OrderName">
      <summary>
        <para>
          The order (<b>tag</b>) name for this order. Used for creating multi-order order files (<b>bags</b>).
        </para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.Recno">
      <summary>
        <para>The individual record number to be processed. Defaults to zero (0) for all records.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.Records">
      <summary>
        <para>The number of records to be processed starting from OrderSpec:Start.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.Rest">
      <summary>
        <para>A logical value indicating that records are to be processed starting from OrderSpec:Start (TRUE). </para>
      </summary>
      <remarks>
        Defaults to FALSE to process all records from the beginning of file.
      </remarks>
    </member>
    <member name="P:VO.OrderSpec.Start">
      <summary>
        <para>Determines the starting record number from which to start building this order.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.StrictRead">
      <summary>
        <para>A logical value determining whether the records will be read directly from disk during order creation.</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.Unique">
      <summary>
        <para>A logical value determining whether this order is to be a unique order (no duplicate keys).</para>
      </summary>
    </member>
    <member name="P:VO.OrderSpec.WhileBlock">
      <summary>
        <para>A WHILE condition code block used during the building of this order.</para>
      </summary>
    </member>
  </members>
</doc>
